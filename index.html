<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Question Bank</title>
    <style>
        /* --- START OF styles.css --- */
        :root {
            /* Light Theme Variables */
            --body-bg: #f8fafc;            --container-bg: #ffffff;
            --text-color: #1e293b;         --text-muted: #64748b;
            --text-heading: #0f172a;       --border-color: #e2e8f0;
            --border-color-hover: #cbd5e1; --accent-color: #2563eb;
            --accent-color-dark: #1d4ed8;  --accent-color-light: #dbeafe;
            --button-bg: #ffffff;          --button-border: #e0e0e0;
            --button-text: #334155;        --button-hover-bg: #f1f5f9;
            --button-active-bg: #0f172a;   --button-active-text: #ffffff;
            --button-secondary-bg: #64748b;--button-secondary-hover-bg: #475569;
            --button-disabled-bg: #94a3b8; --input-bg: #ffffff;
            --input-border: #cbd5e1;       --feedback-bg: #f1f5f9;
            --feedback-border: #e2e8f0;    --correct-bg: #dcfce7;
            --correct-border: #16a34a;     --correct-text: #065f46;
            --incorrect-bg: #fee2e2;       --incorrect-border: #ef4444;
            --incorrect-text: #b91c1c;     --partial-bg: #fef9c3;
            --partial-border: #f59e0b;     --partial-text: #854d0e;
            --shadow-color: rgba(0,0,0,0.05); --matched-item-bg: #e5e7eb;
            --matched-item-border: #9ca3af; --modal-overlay-bg: rgba(15, 23, 42, 0.6);
            --modal-bg: #ffffff;           --lesson-stat-text: #475569;
            /* --- Use these for the gradient/border logic --- */
            --lesson-perfect-bg: #e0fadf;  /* Base for 100% gradient part */
            --lesson-perfect-border: #54c780; /* Border color for 100% */
            /* No longer need imperfect bg/border for the main box style */
            --table-border: #e2e8f0;       --table-header-bg: #f1f5f9;
        }

        body.dark-theme {
            /* Dark Theme Overrides */
            --body-bg: #0f172a;           --container-bg: #1e293b;
            --text-color: #cbd5e1;        --text-muted: #94a3b8;
            --text-heading: #f1f5f9;      --border-color: #334155;
            --border-color-hover: #475569;--accent-color: #3b82f6;
            --accent-color-dark: #2563eb; --accent-color-light: #1e3a8a;
            --button-bg: #334155;         --button-border: #475569;
            --button-text: #e2e8f0;       --button-hover-bg: #475569;
            --button-active-bg: #f1f5f9;  --button-active-text: #0f172a;
            --button-secondary-bg: #475569;--button-secondary-hover-bg: #52525b;
            --button-disabled-bg: #334155;--input-bg: #0f172a;
            --input-border: #475569;      --feedback-bg: #1e293b;
            --feedback-border: #334155;   --correct-bg: #064e3b;
            --correct-border: #10b981;    --correct-text: #a7f3d0;
            --incorrect-bg: #7f1d1d;      --incorrect-border: #f87171;
            --incorrect-text: #fecaca;    --partial-bg: #713f12;
            --partial-border: #fbbf24;    --partial-text: #fef08a;
            --shadow-color: rgba(0,0,0,0.2); --matched-item-bg: #475569;
            --matched-item-border: #64748b; --modal-overlay-bg: rgba(0, 0, 0, 0.7);
            --modal-bg: #1e293b;          --lesson-stat-text: #94a3b8;
             /* --- Dark theme gradient/border variables --- */
            --lesson-perfect-bg: #064e3b;  /* Base for 100% gradient part */
            --lesson-perfect-border: #10b981; /* Border color for 100% */
             /* No longer need imperfect bg/border for the main box style */
            --table-border: #334155;       --table-header-bg: #0f172a;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0; padding: 0; background-color: var(--body-bg);
            color: var(--text-color); transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* --- RTL Layout --- */
        .rtl-layout { direction: rtl; }
        .rtl-layout * { direction: rtl; } /* Inherit by default */
        .rtl-layout [dir="ltr"] * { direction: ltr; } /* Allow overriding for specific LTR content */

        .rtl-layout .header { text-align: right; }
        .rtl-layout .header .header-buttons { flex-direction: row-reverse; }
        .rtl-layout .nav-btn { flex-direction: row-reverse; }
        .rtl-layout .nav-btn span:first-child { margin-left: 0; margin-right: 6px; }
        /* --- MODIFIED: Base RTL border --- */
        .rtl-layout .section-content {
            text-align: right;
            border-left-width: 1px; border-left-color: var(--button-border); /* Standard thin border */
            border-right-width: 4px; border-right-color: transparent; /* Thick side starts transparent */
        }
        /* --- REMOVED: Specific RTL border colors for lesson-complete classes --- */

        .rtl-layout .lesson-title-text { margin-right: 0; margin-left: 10px; }
        .rtl-layout .lesson-stats-display { margin-left: 10px; margin-right: auto; }
        .rtl-layout .lesson-q-count { margin-left: 0; margin-right: 10px; }
        .rtl-layout #quiz-header { text-align: right; }
        .rtl-layout #quiz-header #back-to-topics-btn { flex-direction: row-reverse; }
        #back-to-topics-btn > span:first-child,
        .rtl-layout #back-to-topics-btn > span:first-child {
            display: inline-block; margin: 0 4px;
        }
        .rtl-layout .question-progress { text-align: left; }
        .rtl-layout .question-text { text-align: right; }
        .rtl-layout .question-text strong { margin-right: 0; margin-left: 5px; }
        .rtl-layout .option-label { flex-direction: row-reverse; }
        .rtl-layout .option-input { margin-right: 0; margin-left: 15px; }
        .rtl-layout .matching-container { flex-direction: row-reverse; } /* Flip columns */
        .rtl-layout .matching-column h4 { text-align: right; }
        .rtl-layout .ordering-item { flex-direction: row-reverse; }
        .rtl-layout .ordering-select { margin-right: 0; margin-left: 15px; }
        .rtl-layout #feedback-container { text-align: right; }
        .rtl-layout .incorrect-feedback span { text-align: right; }
        .rtl-layout .feedback-explanation { text-align: right; }
        .rtl-layout .feedback-explanation[dir="ltr"] { text-align: left; }
        .rtl-layout #quiz-buttons-container { justify-content: flex-start; }
        .rtl-layout .results-actions .back-to-topics-btn { margin-left: 0; margin-right: auto; }
        .rtl-layout .review-actions .back-to-topics-btn { margin-left: 0; margin-right: auto; }
        .rtl-layout .results-details { text-align: right; }
        .rtl-layout .results-details p { flex-direction: row-reverse; }
        .rtl-layout .results-details p strong { min-width: auto; margin-right: 0; margin-left: 10px; }
        .rtl-layout .review-question-header { flex-direction: row-reverse; }
        .rtl-layout .review-question-text { text-align: right; }
        .rtl-layout .review-mc-answer p, .rtl-layout .review-matching-answer p, .rtl-layout .review-ordering-answer p { text-align: right; }
        .rtl-layout .review-mc-answer p strong, .rtl-layout .review-matching-answer p strong, .rtl-layout .review-ordering-answer p strong { margin-right: 0; margin-left: 5px; }
        .rtl-layout .review-matching-grid { flex-direction: row-reverse; }
        .rtl-layout .review-matching-column div { text-align: right; }
        .rtl-layout .review-ordering-list-item { flex-direction: row-reverse; }
        .rtl-layout .review-order-number { margin-right: 0; margin-left: 8px; }
        .rtl-layout #settings-modal *, .rtl-layout #stats-modal * { direction: rtl; }
        .rtl-layout .modal-header { flex-direction: row-reverse; }
        .rtl-layout .theme-options label { flex-direction: row-reverse; }
        .rtl-layout .theme-options input[type="radio"] { margin-right: 0; margin-left: 10px;}
        .rtl-layout .modal-footer { text-align: left; }
        .rtl-layout .question-review { border-left-width: 1px; border-left-color: var(--border-color); border-right-width: 5px; border-right-color: transparent; }
        .rtl-layout .question-review.correct { border-right-color: var(--correct-border); }
        .rtl-layout .question-review.incorrect { border-right-color: var(--incorrect-border); }
        .rtl-layout .question-review.partial { border-right-color: var(--partial-border); }
        .rtl-layout .btn > span:first-child { margin-left: 0; margin-right: 6px; }
        .rtl-layout #stats-table th, .rtl-layout #stats-table td { text-align: right; }
        .rtl-layout #stats-table td:first-child, .rtl-layout #stats-table th:first-child { padding-left: 10px; padding-right: 0; }


        /* Welcome View */
        #welcome-view { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; text-align: center; background-color: var(--body-bg); color: var(--text-color); padding: 40px 20px; }
        #welcome-view h1 { font-size: 28px; color: var(--text-heading); margin-bottom: 15px; }
        #welcome-view p { font-size: 16px; color: var(--text-muted); max-width: 600px; line-height: 1.6; margin-bottom: 25px; }
        #welcome-view .info-section { margin-bottom: 20px; font-size: 14px; }
        #welcome-view .info-section strong { display: block; margin-bottom: 5px; color: var(--text-heading); }
        #welcome-view .get-started-btn { margin-top: 30px; }

        /* Main Container */
        .container { max-width: 1200px; margin: 20px auto; background-color: var(--container-bg); padding: 20px 30px; border-radius: 12px; box-shadow: 0 2px 10px var(--shadow-color); border: 1px solid var(--border-color); transition: background-color 0.3s ease, border-color 0.3s ease, opacity 0.5s ease; opacity: 1; }
        .container.initially-hidden { opacity: 0; pointer-events: none; }

        .header { display: flex; justify-content: space-between; align-items: center; text-align: left; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .header h1 { font-size: 24px; margin: 0; color: var(--text-heading); flex-grow: 1; }
        .header .header-buttons { display: flex; gap: 10px; }
        #settings-btn, #stats-btn { background: none; border: 1px solid var(--button-border); color: var(--text-muted); padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 20px; line-height: 1; transition: all 0.2s ease; }
        #settings-btn:hover, #stats-btn:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); color: var(--text-color); }

        /* Nav Section */
        .nav-section { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; transition: opacity 0.3s ease, max-height 0.3s ease, visibility 0.3s ease, margin 0.3s ease, padding 0.3s ease; overflow: hidden; max-height: 500px; opacity: 1; visibility: visible; }
        .nav-section.hidden { max-height: 0; opacity: 0; margin-bottom: 0; padding: 0; border: none; visibility: hidden; }
        .subjects { display: flex; flex-wrap: wrap; gap: 10px; }
        .secondary-nav { display: flex; gap: 10px; align-items: center; }
        .nav-btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 6px; background-color: var(--button-bg); border: 1px solid var(--button-border); transition: all 0.2s ease; color: var(--button-text); }
        .nav-btn:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); }
        .nav-btn.active { background-color: var(--button-active-bg); color: var(--button-active-text); border-color: var(--button-active-bg); }

        body.dark-theme .nav-btn.active span { filter: none; }
        body:not(.dark-theme) .nav-btn.active span { filter: brightness(0) invert(1); }

        .semester-toggle { display: flex; gap: 5px; background-color: var(--feedback-bg); padding: 4px; border-radius: 6px; border: 1px solid var(--button-border); }
        .semester-btn { padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; background: none; color: var(--text-muted); transition: all 0.2s ease; }
        .semester-btn.active { background-color: var(--container-bg); color: var(--text-heading); box-shadow: 0 1px 3px var(--shadow-color); }

        /* Topic List */
        #content {}
        .semester-title-container { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .unit-title { font-size: 20px; font-weight: 600; color: var(--text-heading); margin: 0; }
        .section { background-color: var(--container-bg); border-radius: 12px; padding: 20px 25px; box-shadow: 0 1px 3px var(--shadow-color); border: 1px solid var(--border-color); margin-bottom: 20px; }
        .semester-content > .section:last-of-type { margin-bottom: 0; }
        .section-title { font-size: 17px; font-weight: 600; margin-bottom: 15px; color: var(--text-heading); }
        /* --- MODIFIED: Base section-content style --- */
        .section-content {
            padding: 12px 15px;
            background-color: var(--button-bg); /* Default background */
            border-radius: 8px;
            border: 1px solid var(--button-border); /* Default border */
            margin-bottom: 10px;
            cursor: pointer;
            transition: background-color 0.2s ease, border-color 0.2s ease, transform 0.2s ease, background 0.3s ease; /* Added background transition for gradient */
            font-size: 15px;
            color: var(--button-text); /* Default text color */
            display: flex;
            justify-content: space-between;
            align-items: center;
            text-align: left;
            position: relative;
            overflow: hidden;
            border-left-width: 4px; /* Thick border on left */
            border-left-color: transparent; /* Start transparent */
        }
        .section-content:last-child { margin-bottom: 0; }
        .section-content:hover {
            background-color: var(--button-hover-bg); /* Keep hover effect */
            border-color: var(--border-color-hover);
            transform: translateY(-1px);
        }
        /* --- REMOVED: Background/Border/Text color rules for .lesson-complete-perfect/.imperfect --- */

        .lesson-title-text { flex-grow: 1; margin-right: 10px; }
        .lesson-stats-display { font-size: 0.8em; color: var(--lesson-stat-text); font-weight: 500; white-space: nowrap; flex-shrink: 0; margin-left: auto; padding: 0 10px; }
        .lesson-q-count { font-size: 0.8em; color: var(--lesson-stat-text); font-weight: 400; white-space: nowrap; flex-shrink: 0; }
        /* --- REMOVED: Specific color overrides for q-count in completed lessons --- */

        .semester-content { display: none; }
        .semester-content.active { display: block; }

        /* Quiz View */
        #quiz-view { padding: 20px 0; }
        #quiz-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        #quiz-title { font-size: 20px; font-weight: 600; color: var(--text-heading); }
        #quiz-container { margin-bottom: 20px; }
        .question-type-wrapper { padding: 25px; border: 1px solid var(--border-color); border-radius: 8px; background-color: var(--container-bg); margin-bottom: 20px; box-shadow: 0 1px 2px var(--shadow-color); }
        .question-progress { font-size: 14px; color: var(--text-muted); margin-bottom: 15px; text-align: right; }
        .question-text { font-size: 18px; margin-bottom: 25px; line-height: 1.6; color: var(--text-color); }
        .question-text strong { font-weight: 600; margin-right: 5px; }

        /* MC */
        .options-container { display: flex; flex-direction: column; gap: 12px; margin-bottom: 0; }
        .option-label { display: flex; align-items: center; padding: 12px 15px; border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; transition: all 0.2s ease; background-color: var(--input-bg); }
        .option-label:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); }
        .option-label input:checked + .option-text { font-weight: 500; color: var(--accent-color); }
        .option-label input:checked { accent-color: var(--accent-color); }
        .option-input { margin-right: 15px; flex-shrink: 0; }
        .option-text { flex-grow: 1; font-size: 16px; color: var(--text-color); }

        /* Matching */
        .matching-instructions { font-size: 15px; color: var(--text-muted); margin-bottom: 20px; }
        .matching-container { position: relative; display: flex; justify-content: space-between; gap: 5%; margin-bottom: 0; }
        .matching-column { flex-basis: 47%; display: flex; flex-direction: column; gap: 10px; }
        .matching-column h4 { margin: 0 0 10px 0; font-size: 15px; font-weight: 600; color: var(--text-muted); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .matching-item { padding: 10px 15px; border: 1px solid var(--input-border); background-color: var(--input-bg); border-radius: 6px; cursor: pointer; transition: all 0.2s ease; font-size: 15px; display: flex; align-items: center; min-height: 30px; color: var(--text-color); }
        .matching-item:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); }
        .matching-item.selected { background-color: var(--accent-color-light); border-color: var(--accent-color); font-weight: 500; }
        .matching-item.matched { background-color: var(--matched-item-bg); border-color: var(--matched-item-border); cursor: pointer; opacity: 1.0; }
        .matching-item:focus-visible { outline: 2px solid var(--accent-color); outline-offset: 1px; }
        #matching-arrow-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; z-index: 1; }
        #matching-arrow-svg line { stroke: var(--accent-color); stroke-width: 2; transition: stroke 0.3s ease, opacity 0.3s ease; marker-end: url(#arrowhead); }
        #matching-arrow-svg #arrowhead polygon { fill: var(--accent-color); transition: fill 0.3s ease; }

        /* Ordering */
        .ordering-instructions { font-size: 15px; color: var(--text-muted); margin-bottom: 20px; }
        .ordering-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 0; }
        .ordering-item { display: flex; align-items: center; padding: 10px 15px; border: 1px solid var(--border-color); background-color: var(--input-bg); border-radius: 6px; }
        .ordering-select { margin-right: 15px; padding: 5px 8px; border-radius: 4px; border: 1px solid var(--input-border); font-size: 14px; min-width: 60px; background-color: var(--input-bg); color: var(--text-color); }
        .ordering-text { flex-grow: 1; font-size: 16px; color: var(--text-color); }

        /* Feedback & Buttons */
        #feedback-container { padding: 15px; margin-top: 20px; border-radius: 6px; background-color: var(--feedback-bg); border: 1px solid var(--feedback-border); }
        #feedback-container.hidden { display: none; }
        .correct-feedback { color: var(--correct-text); font-weight: 600; font-size: 16px; }
        .incorrect-feedback { color: var(--incorrect-text); font-weight: 600; font-size: 16px; }
        .incorrect-feedback span { display: block; font-weight: 500; margin-top: 8px; font-size: 15px; color: var(--text-muted); line-height: 1.5; }
        .partial-feedback { color: var(--partial-text); font-weight: 600; font-size: 16px; }
        .correct-option { background-color: var(--correct-bg) !important; border-color: var(--correct-border) !important; }
        .correct-option .option-text { color: var(--correct-text) !important; }
        .incorrect-option { background-color: var(--incorrect-bg) !important; border-color: var(--incorrect-border) !important; }
        .incorrect-option .option-text { color: var(--incorrect-text) !important; }
        .feedback-explanation {
            margin-top: 12px; padding-top: 12px; border-top: 1px solid var(--feedback-border);
            font-size: 0.9em; color: var(--text-muted); line-height: 1.6;
            text-align: left;
        }
        .feedback-explanation[dir="ltr"] { direction: ltr; text-align: left; }
        .rtl-layout .feedback-explanation { text-align: right; }
        .rtl-layout .feedback-explanation[dir="ltr"] { text-align: left; }
        .review-answer-content .feedback-explanation { margin-top: 15px; }

        /* Button container */
        #quiz-buttons-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; margin-top: 25px; border-top: 1px solid var(--border-color); padding-top: 20px; }
        .results-actions, .review-actions { justify-content: space-between; width: 100%; }
        .results-actions { flex-wrap: wrap; justify-content: center; gap: 15px; }
        .results-actions .back-to-topics-btn { margin-left: auto; }
        .review-actions .back-to-topics-btn { margin-left: auto; }
        @media (max-width: 550px) { .results-actions, .review-actions { justify-content: center; } .results-actions .back-to-topics-btn, .review-actions .back-to-topics-btn { margin-left: 0; } }

        /* Buttons */
        .btn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500; transition: all 0.2s ease; line-height: 1.5; background-color: var(--button-bg); color: var(--button-text); border: 1px solid var(--button-border); display: inline-flex; align-items: center; gap: 6px; }
        .btn:hover:not(:disabled) { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); transform: translateY(-1px); }
        .submit-btn { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        .submit-btn:hover:not(:disabled) { background-color: var(--accent-color-dark); border-color: var(--accent-color-dark); }
        .submit-btn:disabled { background-color: var(--button-disabled-bg); border-color: var(--button-disabled-bg); color: var(--text-muted); cursor: not-allowed; transform: none; }
        .next-btn { background-color: var(--correct-border); color: var(--correct-text); border-color: var(--correct-border); } body.dark-theme .next-btn { color: white; } .next-btn:hover { filter: brightness(1.1); }
        .review-btn { background-color: var(--correct-border); color: var(--correct-text); border-color: var(--correct-border); } body.dark-theme .review-btn { color: white; } .review-btn:hover { filter: brightness(1.1); }
        .redo-btn { background-color: #f97316; color: white; border-color: #f97316; } .redo-btn:hover { background-color: #ea580c; border-color: #ea580c; }
        .close-btn, .back-to-topics-btn, .back-btn { background-color: var(--button-secondary-bg); color: white; border-color: var(--button-secondary-bg); } .close-btn:hover, .back-to-topics-btn:hover, .back-btn:hover { background-color: var(--button-secondary-hover-bg); border-color: var(--button-secondary-hover-bg); }
        .reset-data-btn { background-color: var(--incorrect-border); color: var(--incorrect-text); border-color: var(--incorrect-border); } body.dark-theme .reset-data-btn { color: white; } .reset-data-btn:hover { filter: brightness(1.1); }

        .hidden { display: none !important; }

        /* Error Message */
        .error-display { padding: 30px; text-align: center; background-color: var(--incorrect-bg); border: 1px solid var(--incorrect-border); border-radius: 8px; }
        .error-message { color: var(--incorrect-text); font-weight: 500; margin-bottom: 20px; }

        /* Results */
        .results-container { padding: 20px 0; text-align: center; }
        .results-header { font-size: 28px; font-weight: 600; margin-bottom: 30px; color: var(--text-heading); }
        .results-score { margin: 30px 0 40px 0; }
        .score-circle { width: 150px; height: 150px; border-radius: 50%; background-color: var(--feedback-bg); display: flex; flex-direction: column; align-items: center; justify-content: center; margin: 0 auto; border: 8px solid var(--accent-color); box-shadow: 0 0 20px color-mix(in srgb, var(--accent-color) 25%, transparent), inset 0 0 10px color-mix(in srgb, var(--accent-color) 15%, transparent); transition: border-color 0.3s ease; }
        .score-number { font-size: 44px; font-weight: bold; color: var(--text-heading); line-height: 1; }
        .score-percent-sign { font-size: 20px; font-weight: 500; color: var(--text-muted); margin-top: 4px; }
        .results-details { max-width: 500px; margin: 0 auto 35px auto; text-align: left; background-color: var(--feedback-bg); padding: 20px 30px; border-radius: 10px; border: 1px solid var(--feedback-border); box-shadow: 0 2px 5px var(--shadow-color); }
        .results-details p { margin: 12px 0; font-size: 16px; color: var(--text-color); display: flex; align-items: center; gap: 10px; }
        .results-details p strong { color: var(--text-heading); min-width: 80px; display: inline-block; font-weight: 600; }
        .results-details p .detail-value { color: var(--text-muted); font-weight: 500; }
        .results-details p .detail-icon { font-size: 18px; color: var(--accent-color); width: 20px; text-align: center; }

        /* Review Answers */
        .review-container { padding: 10px 0; }
        .question-review { padding: 20px; margin-bottom: 20px; border-radius: 8px; border: 1px solid var(--border-color); border-left-width: 5px; background-color: var(--container-bg); }
        .question-review.correct { border-left-color: var(--correct-border); }
        .question-review.incorrect { border-left-color: var(--incorrect-border); }
        .question-review.partial { border-left-color: var(--partial-border); }
        .review-question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .review-question-number { font-weight: 600; color: var(--text-heading); font-size: 16px; }
        .review-status { font-weight: 600; font-size: 14px; padding: 3px 8px; border-radius: 4px; text-align: center; }
        .question-review.correct .review-status { color: var(--correct-text); background-color: var(--correct-bg); }
        .question-review.incorrect .review-status { color: var(--incorrect-text); background-color: var(--incorrect-bg); }
        .question-review.partial .review-status { color: var(--partial-text); background-color: var(--partial-bg); }
        .review-question-text { margin-bottom: 15px; font-size: 16px; color: var(--text-color); }
        .review-mc-answer, .review-matching-answer, .review-ordering-answer { background-color: var(--feedback-bg); padding: 15px; border-radius: 6px; border: 1px solid var(--feedback-border); margin-top: 15px; }
        .review-mc-answer p, .review-matching-answer p, .review-ordering-answer p { margin: 8px 0; font-size: 15px; color: var(--text-color); }
        .review-mc-answer p strong, .review-matching-answer p strong, .review-ordering-answer p strong { color: var(--text-heading); margin-right: 5px; display: inline-block; min-width: 110px; }
        .review-mc-answer .correct-answer-text, .review-matching-answer .correct-answer-text, .review-ordering-answer .correct-answer-text { color: var(--correct-text); font-weight: 500; }
        .review-mc-answer .user-answer-text.incorrect { color: var(--incorrect-text); text-decoration: line-through; }
        .review-mc-answer .user-answer-text.correct { color: var(--correct-text); font-weight: 500; }
        .review-matching-grid { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 10px; }
        .review-matching-column { flex: 1; min-width: 200px;}
        .review-matching-column div { padding: 5px 8px; margin-bottom: 5px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--container-bg); }
        .review-matched-pair-correct { background-color: var(--correct-bg) !important; border-color: var(--correct-border) !important; color: var(--correct-text) !important; }
        .review-matched-pair-incorrect { background-color: var(--incorrect-bg) !important; border-color: var(--incorrect-border) !important; }
        body.dark-theme .review-matched-pair-incorrect span { color: var(--incorrect-text) !important; opacity: 0.7; }
        body.dark-theme .review-matched-pair-incorrect span + span { color: var(--correct-text) !important; opacity: 1; }
        body:not(.dark-theme) .review-matched-pair-incorrect span { color: var(--incorrect-text) !important; opacity: 0.7; }
        body:not(.dark-theme) .review-matched-pair-incorrect span + span { color: var(--correct-text) !important; opacity: 1; }
        .review-ordering-list { margin-top: 10px; display: flex; flex-direction: column; gap: 5px; }
        .review-ordering-list-item { display: flex; align-items: center; padding: 6px 10px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--container-bg); }
        .review-order-number { font-weight: 600; margin-right: 8px; }
        .review-order-correct { color: var(--correct-text); }
        .review-order-incorrect { color: var(--incorrect-text); text-decoration: line-through; opacity: 0.8; }

        /* --- Modal Base Styles (Shared by Settings and Stats) --- */
        #settings-modal, #stats-modal { position: fixed; inset: 0; background-color: var(--modal-overlay-bg); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        #settings-modal.visible, #stats-modal.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: var(--modal-bg); padding: 25px 30px; border-radius: 12px; box-shadow: 0 5px 20px var(--shadow-color); width: 90%; max-width: 450px; border: 1px solid var(--border-color); position: relative; transform: scale(0.95); transition: transform 0.3s ease; max-height: 90vh; display: flex; flex-direction: column; }
        #stats-modal .modal-content { max-width: 700px; }
        #settings-modal.visible .modal-content, #stats-modal.visible .modal-content { transform: scale(1); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .modal-title { font-size: 20px; font-weight: 600; color: var(--text-heading); }
        .modal-close-btn { font-size: 24px; background: none; border: none; color: var(--text-muted); cursor: pointer; line-height: 1; padding: 0 5px; }
        .modal-body { margin-bottom: 20px; overflow-y: auto; flex-grow: 1;}
        .modal-section { margin-bottom: 20px; }
        .modal-section h4 { font-size: 16px; font-weight: 500; color: var(--text-heading); margin: 0 0 12px 0; }
        .modal-footer { margin-top: auto; padding-top: 15px; border-top: 1px solid var(--border-color); text-align: right; flex-shrink: 0; }

        /* Settings Modal Specific */
        .theme-options label { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; cursor: pointer; font-size: 15px; color: var(--text-color); }
        .theme-options input[type="radio"] { accent-color: var(--accent-color); }

        /* Stats Modal Table */
        #stats-table { width: 100%; border-collapse: collapse; margin-top: 15px; table-layout: fixed; }
        #stats-table th, #stats-table td { border: 1px solid var(--table-border); padding: 8px 10px; text-align: center; font-size: 14px; white-space: nowrap; }
        #stats-table th { background-color: var(--table-header-bg); font-weight: 600; color: var(--text-heading); }
        #stats-table td:first-child, #stats-table th:first-child { text-align: left; font-weight: 500; padding-right: 10px; }
        #stats-table td { color: var(--text-muted); }
        #stats-table tr:last-child td { border-bottom: none; }
        #stats-table th:last-child, #stats-table td:last-child { font-weight: bold; color: var(--text-color); }


        /* --- END OF styles.css --- */
    </style>
</head>
<body>

    <!-- Welcome View -->
    <div id="welcome-view">
        <h1>Welcome!</h1> <p>Practice makes perfect.</p>
        <div class="info-section"><strong>By:</strong><span>ابراهيم</span></div>
        <div class="info-section"><strong>Testers:</strong><span>Snoozie</span></div>
        <div class="info-section"><strong>Mentions:</strong><span>وهل يخفى القمر؟</span></div>
        <button class="btn submit-btn get-started-btn">Start</button>
    </div>

    <!-- Main Container -->
    <div class="container initially-hidden">
        <div class="header">
            <h1>Question Bank</h1>
            <div class="header-buttons">
                <button id="stats-btn" title="View Statistics">📊</button>
                <button id="settings-btn" title="Settings">⚙️</button>
            </div>
        </div>
        <div class="nav-section">
             <div class="subjects">
                <button class="nav-btn" data-subject="اللغة العربية"><span>📚</span> اللغة العربية</button>
                <button class="nav-btn active" data-subject="english"><span>🌎</span> English</button>
                <button class="nav-btn" data-subject="التاريخ"><span>📜</span> التاريخ</button>
                <button class="nav-btn" data-subject="دين"><span>📖</span> دين</button>
            </div>
            <div class="secondary-nav">
                 <div class="semester-toggle">
                     <button class="semester-btn active" data-semester="first" id="semester-btn-first">First Semester</button>
                     <button class="semester-btn" data-semester="second" id="semester-btn-second">Second Semester</button>
                 </div>
             </div>
        </div>
        <div id="content"></div>
        <div id="quiz-view" class="hidden">
            <div id="quiz-header">
                <h2 id="quiz-title">Quiz</h2>
                <button class="btn back-to-topics-btn" id="back-to-topics-btn" onclick="showTopicList()"><span>⬅️</span> <span class="btn-text">Back to Topics</span></button>
            </div>
            <div id="quiz-container"></div>
            <div id="feedback-container" class="feedback-container hidden"></div>
            <div id="quiz-buttons-container" class="quiz-buttons"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="hidden">
        <div class="modal-content">
            <div class="modal-header"> <h3 class="modal-title">Settings</h3> <button class="modal-close-btn" id="settings-modal-close-header" onclick="toggleSettingsModal(false)">×</button> </div>
            <div class="modal-body">
                <div class="modal-section"> <h4>Theme</h4> <div class="theme-options"> <label><input type="radio" name="theme" value="light"> Light ☀️</label> <label><input type="radio" name="theme" value="dark"> Dark 🌙</label> </div> </div>
                <div class="modal-section"> <h4>Data</h4> <button class="btn reset-data-btn" id="reset-data-button">Reset Data</button> <p style="font-size:12px;color:var(--text-muted);margin-top:8px;">Clears theme, welcome status, and stats.</p> </div>
            </div>
            <div class="modal-footer"> <button class="btn close-btn" id="settings-modal-close-footer" onclick="toggleSettingsModal(false)">Close</button> </div>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div id="stats-modal" class="hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="stats-modal-title">Overall Statistics</h3>
                <button class="modal-close-btn" id="stats-modal-close-header" onclick="toggleStatsModal(false)">×</button>
            </div>
            <div class="modal-body">
                <table id="stats-table">
                    <thead>
                        <tr>
                            <th>المادة</th>
                            <th>التاريخ</th>
                            <th>دين</th>
                            <th>اللغة العربية</th>
                            <th>English</th>
                            <th>المجموع</th>
                        </tr>
                    </thead>
                    <tbody id="stats-table-body">
                        <!-- Rows will be populated by JS -->
                    </tbody>
                </table>
                 <p style="font-size:12px;color:var(--text-muted);margin-top:15px;">Stats based on best performance per lesson.</p>
            </div>
            <div class="modal-footer">
                <button class="btn close-btn" id="stats-modal-close-footer" onclick="toggleStatsModal(false)">Close</button>
            </div>
        </div>
    </div>


    <script>
        // --- START OF topics.js ---
        // Data includes explanation fields now
        const topicsData = {
    "english": {
        "first": {
            "title": "First Semester",
            "units": [
                {
                    "title": "Unit 1",
                    "lessons": [
                        {
                            "title": "Vocabulary & Grammar Basics",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "Device in 'curtain of night fell'?",
                                    "options": ["Simile", "Metaphor", "Alliteration", "Hyperbole","test"],
                                    "answer": "Metaphor",
                                    "explanation": "A metaphor directly compares two unlike things without using 'like' or 'as'. 'Curtain of night' compares the falling night to a curtain closing."
                                },
                                {
                                    "type": "multiple_choice",
                                    "question": "'Ambiguous' means:",
                                    "options": ["Clear", "Uncertain", "Definite", "Determined"],
                                    "answer": "Uncertain"
                                    // No explanation provided for this one - it's optional
                                },
                                {
                                    "type": "ordering",
                                    "question": "Order alphabetically:",
                                    "items": ["Banana", "Apple", "Cherry", "Date", "Fig"],
                                    "answer": ["Apple", "Banana", "Cherry", "Date", "Fig"],
                                    "explanation": "Items are sorted based on the standard English alphabet order (A, B, C, D, F)."
                                },
                                {
                                    "type": "matching",
                                    "question": "Match country and capital:",
                                    "prompts": ["France", "Japan", "Egypt", "Brazil", "Canada"],
                                    "matches": ["Cairo", "Tokyo", "Paris", "Brasília", "Ottawa"],
                                    "answer": {
                                        "0": 2,
                                        "1": 1,
                                        "2": 0,
                                        "3": 3,
                                        "4": 4
                                    },
                                    "explanation": "Paris is the capital of France, Tokyo of Japan, Cairo of Egypt, Brasília of Brazil, and Ottawa of Canada."
                                },
                                {
                                    "type": "ordering",
                                    "question": "Order tea steps:",
                                    "items": ["Add tea bag", "Boil water", "Pour water"],
                                    "answer": ["Boil water", "Add tea bag", "Pour water"],
                                    "explanation": "You must boil the water first. Then, add the tea bag to the cup before pouring the hot water over it."
                                },
                                {
                                    "type": "multiple_choice",
                                    "question": "'Concise' means:", // Changed question for variety
                                    "options": ["Lengthy", "Wordy", "Brief", "Complicated"],
                                    "answer": "Brief",
                                    "explanation": "'Concise' means expressing much in few words; it's the opposite of lengthy or wordy."
                                },
                                ]
                        },
                        {
                            "title": "Past & Present Tenses & Question Tags",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "Correct tense: 'She ___ to school every day.'", // Added frequency
                                    "options": ["go", "goes", "going", "went"],
                                    "answer": "goes",
                                     "explanation": "For third-person singular subjects (like 'She') in the present simple tense (used for routines like 'every day'), we add '-es' to verbs ending in 'o'."
                                },
                                {
                                    "type": "multiple_choice",
                                    "question": "Correct tag: 'You are studying, ___?'", // Corrected question
                                    "options": ["aren't you", "don't you", "isn't you", "won't you"],
                                    "answer": "aren't you",
                                    "explanation": "Question tags use the opposite form of the auxiliary verb ('are' becomes 'aren't') and the same subject pronoun ('you')."
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "Unit 2",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Future Forms", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 3",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Habits & Clauses", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 4",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Narration & Inversion", "questions": [] }
                    ]
                }
            ]
        },
        "second": {
            "title": "Second Semester",
            "units": [
                {
                    "title": "Unit 1",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Modal & Related & Articles", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 2",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Reported Speech & Reporting Verbs", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 3",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "The Passive", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 4",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Conditionals & Modals", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 5",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Modals & Clauses", "questions": [] }
                    ]
                }
            ]
        }
    },

    "اللغة العربية": {
        "first": {
            "title": "الفصل الأول",
            "units": [
                {
                    "title": "الوحدة الأولى",
                    "lessons": [
                        {
                            "title": "من القيم الإنسانية في القرآن",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "ما معنى كلمة 'البر' في قوله تعالى 'لن تنالوا البر حتى تنفقوا مما تحبون'؟",
                                    "options": ["الخير", "الصدق", "العدل", "الوفاء"],
                                    "answer": "الخير",
                                    "explanation": "البر هو اسم جامع لكل أنواع الخير والطاعة."
                                },
                                {
                                    "type": "ordering",
                                    "question": "رتب مراحل الوحي حسب نزولها:",
                                    "items": ["اقرأ باسم ربك", "المدثر", "الفاتحة"],
                                    "answer": ["اقرأ باسم ربك", "المدثر", "الفاتحة"],
                                    "explanation": "أول ما نزل من القرآن هو صدر سورة العلق ('اقرأ')، ثم تلاها فترة انقطاع، ثم نزلت سورة المدثر، وتعتبر الفاتحة أول سورة كاملة نزلت."
                                },
                                {
                                    "type": "matching",
                                    "question": "صل بين المصطلح وتعريفه:",
                                    "prompts": ["التجويد", "التفسير", "الناسخ والمنسوخ"],
                                    "matches": ["علم كيفية النطق الصحيح للقرآن", "علم بيان معاني القرآن", "علم الآيات التي تغير حكمها"],
                                    "answer": { "0": 0, "1": 1, "2": 2 },
                                    "explanation": "التجويد يتعلق بالنطق، التفسير ببيان المعنى، والناسخ والمنسوخ بتغير الأحكام."
                                 }
                            ]
                        },
                        {
                            "title": "اسلوب الطلب وجوابه المجزوم والتشبيه المفرد",
                            "questions": []
                        }
                    ]
                },
                {
                    "title": "الوحدة الثانية",
                    "lessons": [
                        { "title": "عمانيات", "questions": [] },
                        { "title": "صور الفاعل والتشبيه التمثيلي", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثالثة",
                    "lessons": [
                        { "title": "الزهايمر-الخرف المبكر", "questions": [] },
                        { "title": "صور المبتدأ والخبر والجملة الخبرية والإنشائية", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الرابعة",
                    "lessons": [
                        { "title": "الإعلام ومشروع النهوض باللغة العربية", "questions": [] },
                        { "title": "المفعول معه والأمر", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الخامسة",
                    "lessons": [
                        { "title": "التعليم التقني بوابة المستقبل في عالم متغير", "questions": [] },
                        { "title": "انواع ما والإستفهام", "questions": [] }
                    ]
                }
            ]
        },
        "second": {
            "title": "الفصل الثاني",
            "units": [
                {
                    "title": "الوحدة الأولى",
                    "lessons": [
                        { "title": "في فتح القدس", "questions": [] },
                        { "title": "معاني حروف الجر والتشخيص", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثانية",
                    "lessons": [
                        { "title": "قصة-حفنة تمر", "questions": [] },
                        { "title": "اسم الفاعل واسم المفعول والطباق والمقابلة", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثالثة",
                    "lessons": [
                        { "title": "شاعرات من بلدي", "questions": [] },
                        { "title": "اسم الزمان واسم المكان وجمع التكسير (القلة والكثرة)", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الرابعة",
                    "lessons": [
                        { "title": "من مقامات بديع الزمان الهمذاني", "questions": [] },
                        { "title": "مصدر المرة ومصدر الهيئة والبحر المتدارك", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الخامسة",
                    "lessons": [
                        { "title": "الذكاء الاصطناعي-عالم جديد", "questions": [] },
                        { "title": "اسم الآلة", "questions": [] }
                    ]
                }
            ]
        }
    },

    "التاريخ": {
        "first": {
            "title": "الفصل الأول",
            "units": [
                {
                    "title": "الأردن في العصور القديمة",
                    "lessons": [
                        {
                            "title": "الأردن في العصور الحجرية",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "أي موقع أثري في الأردن يعود للعصر الحجري الحديث ويشتهر بالتماثيل العينية؟",
                                    "options": ["عين غزال", "جاوا", "بيضا", "أم قيس"],
                                    "answer": "عين غزال"
                                },
                                {
                                    "type": "ordering",
                                    "question": "رتب العصور الحجرية من الأقدم للأحدث:",
                                    "items": ["الحجري الحديث", "الحجري القديم", "الحجري الوسيط"],
                                    "answer": ["الحجري القديم", "الحجري الوسيط", "الحجري الحديث"]
                                }
                            ]
                        },
                        { "title": "الأردن في العصر الحديدي", "questions": [] },
                        { "title": "مملكة الأنباط", "questions": [] },
                        { "title": "مظاهر الحضارة اليونانية في الأردن", "questions": [] },
                        { "title": "مظاهر الحضارة الرومانية-البيزنطية في الأردن", "questions": [] }
                    ]
                },
                {
                    "title": "الأردن في صدر الإسلام",
                    "lessons": [
                        { "title": "الأردن في صدر الإسلام", "questions": [] },
                        { "title": "الأردن في العصر الأموي", "questions": [] },
                        { "title": "الأردن في العصر العباسي", "questions": [] },
                        { "title": "الأردن خلال حملات الفرنجة", "questions": [] },
                        { "title": "الأردن في العصر الأيوبي", "questions": [] },
                        { "title": "الأردن في العصر المملوكي", "questions": [] }
                    ]
                },
                {
                    "title": "الأردن في العصر الحديث",
                    "lessons": [
                        { "title": "الأوضاع السياسية والإدارية في الأردن في العهد العثماني", "questions": [] },
                        { "title": "الأوضاع الإجتماعية والإقتصادية الأردن في العهد العثماني", "questions": [] },
                        { "title": "الثورة العربية الكبرى", "questions": [] },
                        { "title": "الأردن في عهد المملكة العربية السورية والحكومات المحلية", "questions": [] }
                    ]
                }
            ]
        },
        "second": {
            "title": "الفصل الثاني",
            "units": [
                {
                    "title": "الحياة السياسية في الأردن",
                    "lessons": [
                        { "title": "تأسيس الإمارة الأردنية", "questions": [
                            {
                                "type": "multiple_choice",
                                "question": "على ماذا استولت فرنسا؟",
                                "options": [
                                    "دمشق",
                                    "بغداد",
                                    "القدس",
                                    "عمان"
                                ],
                                "answer": "دمشق",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "احدى التالية ليست من تبعات استيلاء فرنسا على دمشق:",
                                "options": [
                                    "انتهاء الحكومة العربية في دمشق",
                                    "لجوء القيادات السياسية العربية الى ملك الحجاز",
                                    "ايفاد الامير فيصل بن الحسين الى بلاد الشام",
                                    "استشهاد يوسف العظمة."
                                ],
                                "answer": "ايفاد الامير فيصل بن الحسين الى بلاد الشام",
                                "explanation": "اوفد الامير عبدالله بن الحسين، واستشهد يوسف العظمة في معركة ميلسون (الفصل الاول)."
                            },
                            {
                                "type": "multiple_choice",
                                "question": "سبب لجوء القيادات العربية السياسية الى الحسين بن علي ملك الحجاز:",
                                "options": [
                                    "استيلاء فرنسا على دمشق",
                                    "انشاء كيان عربي موحد",
                                    "طلب المعدات العسكرية",
                                    "عقد مؤتمر حوار وطني"
                                ],
                                "answer": "استيلاء فرنسا على دمشق",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "اوفد الشريف الحسين بن علي:",
                                "options": [
                                    "نجله الاول الحسين بن عبدالله",
                                    "نجله الثاني عبدالله بن الحسين",
                                    "ابنه الوحيد فيصل بن الحسين",
                                    "نجله الاول عبدالله بن الحسين"
                                ],
                                "answer": "نجله الثاني عبدالله بن الحسين",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "ما الكيان الذي استولى على دمشق؟",
                                "options": [
                                    "بريطانيا",
                                    "فرنسا",
                                    "الحركات الثورية.",
                                    "اسبانيا"
                                ],
                                "answer": "فرنسا",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "مطلب القيادات السياسية العربية من ملك الحجاز:",
                                "options": [
                                    "الدعم السياسي ضد فرنسا",
                                    "ايفاد احد انجاله لقيادة الحركة العربية",
                                    "امداد الحركة العربية بالمعدات اللازمة.",
                                    "انشاء كيان عسكري موحد للوقوف في وجه فرنسا."
                                ],
                                "answer": "ايفاد احد انجاله لقيادة الحركة العربية",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "متى وصل الامير عبدالله الى معان؟",
                                "options": [
                                    "21 تشرين الاول 1920",
                                    "21 تشرين الثاني 1920",
                                    "1 تشرين الثاني 1921",
                                    "1 تشرين الاول 1921"
                                ],
                                "answer": "21 تشرين الثاني 1920",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "المكان الذي اصدر فيه بيان تحدث عن تحرير سورية:",
                                "options": [
                                    "دمشق",
                                    "عمان",
                                    "معان",
                                    "الحجاز"
                                ],
                                "answer": "معان",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "احدى التالية من البيان الذي اصدره الامير عبدالله بن الحسين في معان:",
                                "options": [
                                    "استقلال سورية العربية",
                                    "اعادة الحكم الاسلامي والخلافة",
                                    "تحرير سورية واعادة الحكم العربي"
                                ],
                                "answer": "تحرير سورية واعادة الحكم العربي",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "التف حول الامير عبدالله عدد من الشخصيات في معان:",
                                "options": [
                                    "الفلسطينية والسورية",
                                    "السورية والعربية",
                                    "الاردنية والعربية",
                                    "البريطانية والعربية"
                                ],
                                "answer": "الاردنية والعربية",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "انعقد المؤتمر البريطاني في القاهرة في:",
                                "options": [
                                    "اذار 1921",
                                    "ايار 1921",
                                    "اذار 1920",
                                    "ايار 1920"
                                ],
                                "answer": "اذار 1921",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "ترأس المؤتمر البريطاني في القاهرة:",
                                "options": [
                                    "الخديوي المصري",
                                    "وزير الدفاع السوري",
                                    "وزير المستعمرات البريطاني",
                                    "المندوب السامي البريطاني"
                                ],
                                "answer": "وزير المستعمرات البريطاني",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "المندوب السامي البريطاني هو:",
                                "options": [
                                    "هربرت صموئيل",
                                    "كنغ كرين",
                                    "ونستون تشرتشل"
                                ],
                                "answer": "هربرت صموئيل",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "الهدف من المؤتمر البريطاني في القاهرة:",
                                "options": [
                                    "التوصل الى حل مع معضلة فلسطين",
                                    "محاربة الحركات العربية الرامية الى تحرير سورية ولبنان",
                                    "بحث مستقبل وجود بريطانيا في المنطقة",
                                    "اعلان اعادة الحكم العربي لما كان عليه برئاسة الشريف الحسين"
                                ],
                                "answer": "بحث مستقبل وجود بريطانيا في المنطقة",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "الذي رشح ليكون ملكا على العراق هو:",
                                "options": [
                                    "فيصل بن الحسين",
                                    "عبدالله بن الحسين",
                                    "الحسين بن علي",
                                    "يوسف العظمة"
                                ],
                                "answer": "فيصل بن الحسين",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "الذي دعاه وزير المستعمرات لاجتماع القدس:",
                                "options": [
                                    "حزب الاستقلال السوري",
                                    "عبدالله بن الحسين",
                                    "فيصل بن الحسين",
                                    "ملك الحجاز"
                                ],
                                "answer": "عبدالله بن الحسين",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "الاجتماع الذي تم فيه الاتفاق على اقامة حكومة وطنية شرقي الاردن:",
                                "options": [
                                    "مؤتمر القاهرة",
                                    "اجتماع ميلسون",
                                    "اجتماع القدس",
                                    "اجتماع عمان"
                                ],
                                "answer": "اجتماع القدس",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "النظام الذي فرضته عصبة الامم المتحدة على شرقي الاردن وفلسطين هو:",
                                "options": [
                                    "الاقطاعي",
                                    "الوكالة",
                                    "الانتداب",
                                    "الاستعمار"
                                ],
                                "answer": "الانتداب",
                                "explanation": ""
                            },
                            {
                                "type": "multiple_choice",
                                "question": "احدى التالية ليست من بنود اتفاق القدس:",
                                "options": [
                                    "اقامة حكومة وطنية في شرقي الاردن برئاسة الامير عبدالله",
                                    "استقلال الاردن استقلالا اداريا تاما",
                                    "تساعدها بريطانيا مالياً لتوطيد الامن فيه",
                                    "تسترشد هذه الحكومة بالمندوب السامي البريطاني"
                                ],
                                "answer": "تسترشد هذه الحكومة بالمندوب السامي البريطاني", // Note: Answer still doesn't include the period from the option text
                                "explanation": ""
                            }
                        ] },
                        { "title": "استقلال المملكة الأردنية الهاشمية", "questions": [] },
                        { "title": "تطور الحياة السياسية في الأردن بين عامي (1948-1957)", "questions": [] },
                        { "title": "تطور الحياة السياسية في الأردن بين عامي (1958-1999)", "questions": [] },
                        { "title": "الحياة السياسية في الأردن منذ 1999", "questions": [] },
                        { "title": "الأردن والعلاقات العربية والدولية", "questions": [] },
                        { "title": "القوات المسلحة الأردنية - الجيش العربي", "questions": [] },
                        { "title": "الأجهزة الأمنية الأردنية", "questions": [] }
                    ]
                },
                {
                    "title": "الحياة الاقتصادية في الأردن",
                    "lessons": [
                        { "title": "الحياة الاقتصادية في الأردن بين عامي (1921-1950)", "questions": [] },
                        { "title": "الحياة الاقتصادية في الأردن بين عامي (1951-1967)", "questions": [] },
                        { "title": "الحياة الاقتصادية في الأردن بين عامي (1968-1999)", "questions": [] },
                        { "title": "الحياة الاقتصادية في الأردن منذ عام 1999", "questions": [] }
                    ]
                },
                {
                    "title": "الحياة الاجتماعية في الأردن",
                    "lessons": [
                        { "title": "الحياة الاجتماعية في الأردن بين عامي (1921-1950)", "questions": [] },
                        { "title": "الحياة الاجتماعية في الأردن بين عامي (1951-1999)", "questions": [] },
                        { "title": "الحياة الاجتماعية في الأردن منذ عام 1999", "questions": [] }
                    ]
                },
                {
                    "title": "التعليم والثقافة في الأردن",
                    "lessons": [
                        { "title": "التعليم العام في الأردن بين عامي (1921-1950)", "questions": [] },
                        { "title": "التعليم العام في الأردن بين عامي (1951-1987)", "questions": [] },
                        { "title": "التعليم العام في الأردن بين عامي (1988-2024)", "questions": [] },
                        { "title": "التعليم العالي والبحث العلمي في الأردن منذ عام 1951", "questions": [] },
                        { "title": "الحياة الثقافية في الأردن في عهد الإمارة", "questions": [] },
                        { "title": "الحياة الثقافية في الأردن منذ عام 1946", "questions": [] }
                    ]
                },
                {
                    "title": "الأردن والقضية الفلسطينية",
                    "lessons": [
                        { "title": "موقف الأردن من القضية الفلسطينية بين عامي (1916-1951)", "questions": [] },
                        { "title": "موقف الأردن من القضية الفلسطينية منذ عام 1951", "questions": [] },
                        { "title": "الوصاية والإعمار الهاشمي للمقدسات الدينية في القدس", "questions": [] }
                    ]
                }
            ]
        }
    },

    "دين": {
        "first": {
            "title": "الفصل الأول",
            "units": [
                {
                    "title": "الوحدة الأولى",
                    "lessons": [
                        {
                            "title": "سورة آل عمران (102-105)",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "ما هو الأمر الذي نهى الله عنه في قوله تعالى 'ولا تفرقوا'؟",
                                    "options": ["التعصب", "الخلاف المذموم المؤدي للعداوة", "الاختلاف الفقهي", "ترك الصلاة"],
                                    "answer": "الخلاف المذموم المؤدي للعداوة"
                                },
                                {
                                    "type": "multiple_choice",
                                    "question": "ما المقصود بـ 'حبل الله' في الآية؟",
                                    "options": ["القرآن والسنة", "الصلاة", "الزكاة", "الحج"],
                                    "answer": "القرآن والسنة"
                                }
                            ]
                        },
                        { "title": "حديث اتقاء الشبهات", "questions": [] },
                        { "title": "من صور الضلال", "questions": [] },
                        { "title": "كرامة الإنسان في الشريعة", "questions": [] },
                        { "title": "الزواج-مشروعيته ومقدماته", "questions": [] },
                        { "title": "الجهاد في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثانية",
                    "lessons": [
                        { "title": "جهود علماء المسلمين في خدمة القرآن", "questions": [] },
                        { "title": "العزيمة والرخصة", "questions": [] },
                        { "title": "معركة مؤتة (8 هجري)", "questions": [] },
                        { "title": "المحرمات من النساء", "questions": [] },
                        { "title": "التعايش الإنساني", "questions": [] },
                        { "title": "الحقوق الإجتماعية للمرأة في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثالثة",
                    "lessons": [
                        { "title": "سورة آل عمران (169-174)", "questions": [] },
                        { "title": "حديث - رضا الله تعالى", "questions": [] },
                        { "title": "فتح مكة (8 هجري)", "questions": [] },
                        { "title": "من خصائص الشريعة - الإيجابية", "questions": [] },
                        { "title": "شروط صحة عقد الزواج", "questions": [] },
                        { "title": "الحقوق المالية للمرأة في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الرابعة",
                    "lessons": [
                        { "title": "سورة الروم (21-24)", "questions": [] },
                        { "title": "مكانة السنة النبوية في التشريع", "questions": [] },
                        { "title": "مراعاة الأعراف في الشريعة", "questions": [] },
                        { "title": "حقوق الزوجين", "questions": [] },
                        { "title": "تنظيم النسل وتحديده", "questions": [] },
                        { "title": "الأمن الغذائي في الإسلام", "questions": [] },
                        { "title": "الإسلام والوحدة الوطنية", "questions": [] }
                    ]
                }
            ]
        },
        "second": {
            "title": "الفصل الثاني",
            "units": [
                {
                    "title": "الوحدة الأولى",
                    "lessons": [
                        { "title": "سورة البقرة (284-286)", "questions": [] },
                        { "title": "دلائل وجود الله تعالى", "questions": [] },
                        { "title": "إعجاز القرآن الكريم", "questions": [] },
                        { "title": "الأمر بالمعروف والنهي عن المنكر", "questions": [] },
                        { "title": "اليوم الآخر - احداثه وآثار الإيمان به", "questions": [] },
                        { "title": "الإجتهاد في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثانية",
                    "lessons": [
                        { "title": "سورة الأعراف (31-34)", "questions": [] },
                        { "title": "مراعاة المصالح في الشريعة", "questions": [] },
                        { "title": "جهود علماء المسلمين في الحفاظ على السنة النبوية", "questions": [] },
                        { "title": "حديث - منهج الإسلام في الحياة", "questions": [] },
                        { "title": "رسائل النبي الى الملوك والزعماء في عصره", "questions": [] },
                        { "title": "يوم تبوك (9 هجري)", "questions": [] },
                        { "title": "الحقوق السياسية للمرأة في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثالثة",
                    "lessons": [
                        { "title": "سورة الفرقان (63-77)", "questions": [] },
                        { "title": "الطلاق", "questions": [] },
                        { "title": "العدة", "questions": [] },
                        { "title": "الوصية في الشريعة", "questions": [] },
                        { "title": "الميراث في الشريعة", "questions": [] },
                        { "title": "من خصائص الشريعة - الوسطية", "questions": [] },
                        { "title": "مجالات الوقف ودورها في التنمية", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الرابعة",
                    "lessons": [
                        { "title": "حديث - مفهوم الإفلاس بين الدنيا والآخرة", "questions": [] },
                        { "title": "مقاصد الشريعة", "questions": [] },
                        { "title": "منهج الإسلام في مكافحة الجريمة", "questions": [] },
                        { "title": "من وصايا النبي في حجة الوداع", "questions": [] },
                        { "title": "المسؤولية المجتمعية في الإسلام", "questions": [] },
                        { "title": "حقوق الإنسان بين الإسلام والإعلان العالمي لحقوق الإنسان", "questions": [] }
                    ]
                }
            ]
        }
    }
}; // --- Keep your full topicsData here ---

        function generateSemesterContent(subject, semester) {
            const sanitizedSubject = subject.replace(/\s+/g, '-'); const id = `${sanitizedSubject}-${semester}`;
            if (!topicsData[subject]?.[semester]) return `<div id="${id}" class="semester-content"><div class="section"><p>Unavailable.</p></div></div>`;
            const semesterData = topicsData[subject][semester]; let html = `<div id="${id}" class="semester-content">`;
            html += `<div class="semester-title-container"><div class="unit-title">${semesterData.title}</div></div>`;
            if (!semesterData.units?.length) { html += `<div class="section"><p>No units.</p></div>`; }
            else { semesterData.units.forEach(unit => { if (unit?.title) { html += `<div class="section"><div class="section-title">${unit.title}</div>`; if (unit.lessons?.length) { unit.lessons.forEach(lesson => { if (lesson?.title) { const qCount = lesson.questions?.length || 0; const countText = qCount === 1 ? "1 Q" : `${qCount} Qs`; html += `<div class="section-content" data-subject="${subject}" data-semester="${semester}" data-unit="${unit.title}" data-lesson="${lesson.title}"> <span class="lesson-title-text">${lesson.title}</span> <span class="lesson-stats-display"></span> <span class="lesson-q-count">(${countText})</span> </div>`; } }); } else { html += `<p style="font-size:14px;color:var(--text-muted);">(No lessons)</p>`; } html += `</div>`; } }); } html += `</div>`; return html;
        }
        function generateAllContent() { let c = ''; const d = document.getElementById('content'); if (!d) return; Object.keys(topicsData).forEach(s => { Object.keys(topicsData[s]).forEach(sem => { c += generateSemesterContent(s, sem); }); }); d.innerHTML = c; }
        generateAllContent();
        // --- END OF topics.js ---
    </script>

    <script>
        // --- START OF questions.js ---
        let quizState = { currentQuestionIndex: 0, correctAnswers: 0, totalQuestions: 0, startTime: null, endTime: null, selectedAnswers: [], questions: [], originalQuestions: [], subject: '', unit: '', lesson: '', semester: '', matchingState: { selectedPromptElement: null, selectedMatchElement: null, userPairs: {} } };
        let allLessonStats = {};
        let subjectTotalQuestions = {};

        const LS_THEME_KEY = 'quizAppTheme';
        const LS_VISITED_KEY = 'quizAppVisited';
        const LS_STATS_KEY = 'quizAppLessonStats';
        const RTL_SUBJECTS = ["اللغة العربية", "دين", "التاريخ"];
        const STATS_SUBJECT_ORDER = ["التاريخ", "دين", "اللغة العربية", "english"];

        // Define UI Strings
        const uiStrings = {
            en: {
                firstSemester: "First Semester", secondSemester: "Second Semester",
                backToTopics: "Back to Topics", submit: "Submit", next: "Next Question",
                viewResults: "View Results",
                resultsSubjectLabel: "Subject:", resultsSemesterLabel: "Semester:",
                resultsUnitLabel: "Unit:", resultsLessonLabel: "Lesson:", resultsCorrectLabel: "Correct:",
                resultsTimeLabel: "Time:", resultsYourAnswerLabel: "Your Answer:", resultsCorrectAnswerLabel: "Correct Answer:",
                redoQuiz: "Redo Quiz", reviewAnswers: "Review Answers",
                backToResults: "Back to Results",
                settingsTitle: "Settings", settingsThemeHeading: "Theme",
                settingsLightMode: "Light Mode", settingsDarkMode: "Dark Mode", settingsDataHeading: "Data Management",
                settingsResetBtn: "Reset Saved Data", settingsResetInfo: "Clears theme, welcome status, and all saved lesson statistics.",
                settingsCloseBtn: "Close",
                statsTitle: "Overall Statistics", statsAnswersLabel: "Answers", statsTimeLabel: "Time", statsTotalLabel: "Total",
                matchingInstruction: "Click an item on the left, then its corresponding item on the right. Click a matched item again to deselect the pair.",
                orderingInstruction: "Select the correct order number ({num}) for each item.",
                matchingItemsHeader: "Items", matchingMatchesHeader: "Matches",
                defaultErrorMessage: "Could not load questions for this lesson.",
                leaveQuizConfirm: "Leave the current quiz? Progress will be lost.",
                resetDataConfirm: "Reset all saved data (theme, stats)? This cannot be undone.",
                resetDataAlert: "Data has been reset. Reloading the page.",
                reviewStatusCorrect: "✓ Correct", reviewStatusIncorrect: "✗ Incorrect",
                reviewStatusPartial: "~ Partial ({correct}/{total})", reviewStatusUnanswered: "Unanswered",
                quizResultExcellent: "Excellent! 🎉", quizResultGreat: "Great Job! 👍",
                quizResultGood: "Good Effort! 💪", quizResultPractice: "Keep Practicing! 📚",
                quizResultNoQuestions: "No questions in this quiz.",
                quizTitlePrefix: "Quiz", reviewTitlePrefix: "Review",
                selectAnswerPrompt: "Please select an answer.", // Added for MC check
                correctFeedback: "Correct! ✓", // Added for default correct
                incorrectFeedback: "Incorrect.", // Added for default incorrect
                correctAnswerIs: "Correct answer:", // Added for default incorrect feedback
                matchingNoMatchNeeded: "No matching needed.", // Added for matching check
                matchingAllCorrect: "Correct! ✓ All matched.", // Added for matching check
                matchingPartialCorrect: "Partial correct: {correct}/{total}.", // Added for matching check
                matchingNoneCorrect: "Incorrect: 0/{total} matched.", // Added for matching check
                orderingInvalidData: "Error: Invalid ordering setup.", // Added for ordering check
                orderingSelectionError: "Error processing selections.", // Added for ordering check
                orderingSelectAll: "Please select an order for all items.", // Added for ordering check
                orderingUseEachNumOncePlural: "numbers 1-{n}", // Added for ordering check
                orderingUseEachNumOnceSingular: "number 1", // Added for ordering check
                orderingDuplicateUse: "Please use each order {nums} exactly once.", // Added for ordering check
                orderingSequenceError: "Error processing sequence.", // Added for ordering check
            },
            ar: {
                 firstSemester: "الفصل الأول", secondSemester: "الفصل الثاني",
                 backToTopics: "العودة للمواضيع", submit: "إرسال", next: "السؤال التالي",
                 viewResults: "عرض النتائج",
                 resultsSubjectLabel: "المادة:", resultsSemesterLabel: "الفصل:",
                 resultsUnitLabel: "الوحدة:", resultsLessonLabel: "الدرس:", resultsCorrectLabel: "الصحيحة:",
                 resultsTimeLabel: "الوقت:", resultsYourAnswerLabel: "إجابتك:", resultsCorrectAnswerLabel: "الإجابة الصحيحة:",
                 redoQuiz: "إعادة الاختبار", reviewAnswers: "مراجعة الإجابات",
                 backToResults: "العودة للنتائج",
                 settingsTitle: "الإعدادات", settingsThemeHeading: "السمة",
                 settingsLightMode: "وضع فاتح", settingsDarkMode: "وضع داكن", settingsDataHeading: "إدارة البيانات",
                 settingsResetBtn: "إعادة تعيين البيانات", settingsResetInfo: "يمسح تفضيلات السمة وحالة شاشة الترحيب وجميع إحصائيات الدروس المحفوظة.",
                 settingsCloseBtn: "إغلاق",
                 statsTitle: "الإحصائيات العامة", statsAnswersLabel: "الاجابات", statsTimeLabel: "الوقت", statsTotalLabel: "المجموع",
                 matchingInstruction: "انقر على عنصر في القائمة الأولى، ثم على العنصر المقابل له في القائمة الثانية. انقر على زوج متطابق مرة أخرى لإلغاء التحديد.",
                 orderingInstruction: "حدد رقم الترتيب الصحيح ({num}) لكل عنصر.",
                 matchingItemsHeader: "العناصر", matchingMatchesHeader: "المطابقات",
                 defaultErrorMessage: "تعذر تحميل أسئلة هذا الدرس.",
                 leaveQuizConfirm: "هل تريد مغادرة الاختبار الحالي؟ سيتم فقدان التقدم.",
                 resetDataConfirm: "هل أنت متأكد من إعادة تعيين جميع البيانات المحفوظة (السمة، الإحصائيات)؟ لا يمكن التراجع عن هذا الإجراء.",
                 resetDataAlert: "تمت إعادة تعيين البيانات. جارٍ إعادة تحميل الصفحة.",
                 reviewStatusCorrect: "✓ صحيح", reviewStatusIncorrect: "✗ خطأ",
                 reviewStatusPartial: "~ جزئي ({correct}/{total})", reviewStatusUnanswered: "لم تتم الإجابة",
                 quizResultExcellent: "ممتاز! 🎉", quizResultGreat: "عمل رائع! 👍",
                 quizResultGood: "مجهود جيد! 💪", quizResultPractice: "استمر في الممارسة! 📚",
                 quizResultNoQuestions: "لا توجد أسئلة في هذا الاختبار.",
                 quizTitlePrefix: "اختبار", reviewTitlePrefix: "مراجعة",
                 selectAnswerPrompt: "الرجاء اختيار إجابة.", // Added AR
                 correctFeedback: "صحيح! ✓", // Added AR
                 incorrectFeedback: "خطأ.", // Added AR
                 correctAnswerIs: "الإجابة الصحيحة:", // Added AR
                 matchingNoMatchNeeded: "لا يوجد تطابق مطلوب.", // Added AR
                 matchingAllCorrect: "صحيح! ✓ تمت مطابقة الكل.", // Added AR
                 matchingPartialCorrect: "صحيح جزئياً: {correct}/{total}.", // Added AR
                 matchingNoneCorrect: "خطأ: 0/{total} مطابقة.", // Added AR
                 orderingInvalidData: "خطأ: إعداد الترتيب غير صالح.", // Added AR
                 orderingSelectionError: "خطأ في معالجة الاختيارات.", // Added AR
                 orderingSelectAll: "الرجاء تحديد ترتيب لجميع العناصر.", // Added AR
                 orderingUseEachNumOncePlural: "الأرقام من 1 إلى {n}", // Added AR
                 orderingUseEachNumOnceSingular: "الرقم 1", // Added AR
                 orderingDuplicateUse: "الرجاء استخدام كل ترتيب {nums} مرة واحدة بالضبط.", // Added AR
                 orderingSequenceError: "خطأ في معالجة التسلسل.", // Added AR
            }
        };

        let contentElement, quizViewElement, quizTitleElement, quizContainerElement, feedbackContainerElement, quizButtonsContainerElement, matchingSvgElement, navSectionElement, welcomeViewElement, mainContainerElement;
        let settingsModalElement, settingsButtonElement, statsModalElement, statsButtonElement;
        let matchingArrowObserver = null; let resizeTimeout = null;

        // --- Utility Functions ---
        function shuffleArray(array) { const newArray=[...array]; for(let i=newArray.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[newArray[i],newArray[j]]=[newArray[j],newArray[i]];} return newArray; }
        function debounce(func,wait){ let timeout; return function(...args){const later=()=>{clearTimeout(timeout);func(...args);};clearTimeout(timeout);timeout=setTimeout(later,wait);}; }
        function formatTime(s){if(s===null||s<=0||isNaN(s))return'0s';const m=Math.floor(s/60),c=Math.floor(s%60);return m>0?`${m}m ${c}s`:`${c}s`;}
        function getLessonStorageKey(s,sem,u,l){const c=str=>(str || '').replace(/\s+/g,'_').replace(/-/g,'__');return`${c(s)}-${c(sem)}-${c(u)}-${c(l)}`;}
        function getCurrentLang() { return document.documentElement.lang || 'en'; }
        function getStrings() { return uiStrings[getCurrentLang()] || uiStrings.en; }

        // --- Lesson Stats Management ---
        function loadLessonStats(){try{const s=localStorage.getItem(LS_STATS_KEY);allLessonStats=s?JSON.parse(s):{};}catch(e){console.error("Failed to load lesson stats:",e);allLessonStats={};}}
        function saveLessonStats(subj,sem,unit,lesson,score,total,time){
            const k=getLessonStorageKey(subj,sem,unit,lesson);
            const currentStat = allLessonStats[k];
            let shouldUpdate = false;

            // First time saving or stored total is different from current total (update required)
            if (!currentStat || !currentStat.totalQuestions || currentStat.totalQuestions !== total) {
                allLessonStats[k] = { bestScore: score, totalQuestions: total, bestTime: time };
                shouldUpdate = true;
            } else {
                // Existing stat, check for improvement
                if (score > currentStat.bestScore) {
                    currentStat.bestScore = score;
                    currentStat.bestTime = time; // Update time only when score improves
                    // Keep stored totalQuestions as is, it matches the current 'total'
                    shouldUpdate = true;
                } else if (score === currentStat.bestScore && time < currentStat.bestTime) {
                    currentStat.bestTime = time; // Update time if score is same but time is better
                    shouldUpdate = true;
                }
                // No need to explicitly update totalQuestions here if it hasn't changed
            }

            if (shouldUpdate) {
                try {
                    localStorage.setItem(LS_STATS_KEY, JSON.stringify(allLessonStats));
                } catch (e) {
                    console.error("Failed to save lesson stats:", e);
                }
            }
        }

        // --- MODIFIED: updateLessonBoxDisplays (Gradient Logic) ---
        function updateLessonBoxDisplays() {
            const activeSemesterContent = document.querySelector('.semester-content.active');
            if (!activeSemesterContent) return;

            const lessonBoxes = activeSemesterContent.querySelectorAll('.section-content');
            lessonBoxes.forEach(box => {
                const subj = box.dataset.subject;
                const sem = box.dataset.semester;
                const unit = box.dataset.unit;
                const lesson = box.dataset.lesson;
                const statsDisplaySpan = box.querySelector('.lesson-stats-display');
                const qCountSpan = box.querySelector('.lesson-q-count');

                if (!subj || !sem || !unit || !lesson || !statsDisplaySpan || !qCountSpan) {
                    // console.warn("Missing data attributes or spans for lesson box:", box);
                    return; // Skip if essential data is missing
                }

                // Always get the CURRENT question count
                const currentQuestionCount = getLessonQuestionCount(subj, sem, unit, lesson);

                // Update the (X Qs) display
                const countText = currentQuestionCount === 1 ? "1 Q" : `${currentQuestionCount} Qs`;
                qCountSpan.textContent = `(${countText})`;
                qCountSpan.style.display = ''; // Ensure it's visible

                // Reset styles initially - Background and Borders
                box.style.background = ''; // Clear potential inline gradient
                box.style.borderColor = 'var(--button-border)'; // Reset to default border color
                box.style.borderLeftColor = 'transparent'; // Reset thick border color (LTR)
                box.style.borderRightColor = 'transparent'; // Reset thick border color (RTL)
                statsDisplaySpan.textContent = '';

                // Check for stored stats
                const storageKey = getLessonStorageKey(subj, sem, unit, lesson);
                const storedStat = allLessonStats[storageKey];
                // Check if main container exists and has the rtl-layout class
                const isRTL = mainContainerElement && mainContainerElement.classList.contains('rtl-layout');


                // Use current count for display and style logic
                if (storedStat && storedStat.bestScore !== undefined && currentQuestionCount > 0) {
                    const score = storedStat.bestScore;
                    const percentage = Math.round((score / currentQuestionCount) * 100);

                    // Display score using CURRENT total
                    const scoreText = `🏆 ${score}/${currentQuestionCount}`;
                    const timeText = `⏱️ ${formatTime(storedStat.bestTime)}`;
                    statsDisplaySpan.textContent = `${scoreText} | ${timeText}`;

                    // Apply Gradient Background
                    const direction = isRTL ? 'to left' : 'to right';
                    const completeColor = 'var(--lesson-perfect-bg)'; // Use defined variable
                    const incompleteColor = 'var(--button-bg)'; // Use default button background for incomplete part

                    box.style.background = `linear-gradient(${direction}, ${completeColor} ${percentage}%, ${incompleteColor} ${percentage}%)`;

                    // Apply special border *only* if 100% complete
                    if (percentage === 100) {
                        const perfectBorderColor = 'var(--lesson-perfect-border)';
                        box.style.borderColor = perfectBorderColor; // Set all borders first
                        if (isRTL) {
                            box.style.borderRightColor = perfectBorderColor; // Override thick border side
                            // Keep border widths as defined in base CSS (1px left, 4px right)
                        } else {
                            box.style.borderLeftColor = perfectBorderColor; // Override thick border side
                             // Keep border widths as defined in base CSS (4px left, 1px right)
                        }
                    }
                    // If not 100%, the borders remain default/transparent as set initially

                } else if (storedStat && currentQuestionCount === 0) {
                    // Stats exist but lesson now has 0 questions -> Clear display, keep borders default
                    statsDisplaySpan.textContent = '';
                }
                 // If no stored stats, spans/styles are already cleared/reset above.
            });
        }

        // --- UI Language Update ---
        function updateUiLanguage(lang = 'en') {
            const strings = uiStrings[lang] || uiStrings.en; // Use provided lang or fallback
            const isRTL = lang === 'ar';
            document.documentElement.lang = lang; // Set page language

            // Helper to set text, handling potential inner spans for buttons
            const setText = (elementId, textKey, options = {}) => {
                const element = document.getElementById(elementId);
                let text = strings[textKey] || uiStrings.en[textKey] || ''; // Fallback text
                 if (options.num !== undefined) { text = text.replace('{num}', `1-${options.num}`); } // Placeholder

                if (element) {
                    const textSpan = element.querySelector('.btn-text');
                    if (textSpan) {
                        textSpan.textContent = text;
                    } else {
                        element.textContent = text; // Set text directly if no span
                    }
                } else if (options.selector) { // Allow using selectors for non-ID elements
                     const elements = document.querySelectorAll(options.selector);
                     elements.forEach(el => { el.textContent = text; });
                }
            };
            // Helper for results details labels
             const setDetailLabel = (key, textKey) => {
                 const text = strings[textKey] || uiStrings.en[textKey] || '';
                 const pElement = document.querySelector(`.results-details p[data-detail-key="${key}"] strong`);
                 if (pElement) pElement.textContent = text;
             };

            // --- Update Static & Dynamic Elements ---
            setText('semester-btn-first', 'firstSemester');
            setText('semester-btn-second', 'secondSemester');
            setText('settings-modal-close-footer', 'settingsCloseBtn'); // Use ID if unique - Footer button
            setText('reset-data-button', 'settingsResetBtn');
            setText('stats-modal-close-footer', 'settingsCloseBtn'); // Use ID for stats modal close
             setText('stats-modal-title', 'statsTitle'); // Update Stats Modal Title

            // Buttons that might exist depending on view
            setText('back-to-topics-btn', 'backToTopics'); // In quiz header
            setText('submit-btn', 'submit'); // In quiz footer (initially)

            // Smart update for Next/View Results button
            const nextBtn = document.getElementById('next-btn');
            if (nextBtn) {
                 const nextBtnTextKey = (quizState.currentQuestionIndex === quizState.totalQuestions - 1 && quizState.totalQuestions > 0) ? 'viewResults' : 'next';
                 setText('next-btn', nextBtnTextKey);
            }

            // Buttons in results/review/error views (use IDs if unique)
            setText('redo-btn', 'redoQuiz');
            setText('review-btn', 'reviewAnswers');
            setText('back-to-topics-btn-results', 'backToTopics'); // Results view back button
            setText('back-btn', 'backToResults'); // Review view back button
            setText('back-to-topics-btn-review', 'backToTopics'); // Review view back button
            setText('back-to-topics-btn-error', 'backToTopics'); // Error view back button


            // Quiz Title (handle different states)
            if (quizTitleElement) {
                if (quizContainerElement && quizContainerElement.querySelector('.results-container')) {
                    quizTitleElement.textContent = strings.viewResults || 'Quiz Results';
                } else if (quizContainerElement && quizContainerElement.querySelector('.review-container')) {
                    quizTitleElement.textContent = `${strings.reviewTitlePrefix || 'Review'}: ${quizState.lesson || ''}`;
                } else if (quizContainerElement && quizContainerElement.querySelector('.error-display')) {
                     quizTitleElement.textContent = strings.defaultErrorMessage.includes('load') ? strings.defaultErrorMessage : 'Error';
                } else if (quizState.lesson) {
                    quizTitleElement.textContent = `${strings.quizTitlePrefix || 'Quiz'}: ${quizState.lesson}`;
                } else {
                    // Default or placeholder if no state matches
                     quizTitleElement.textContent = strings.quizTitlePrefix || 'Quiz';
                }
            }

            // Modal text
            const settingsM = document.getElementById('settings-modal');
            if(settingsM) {
                setText('settings-modal .modal-title', 'settingsTitle', { selector: '#settings-modal .modal-title' });
                setText('settings-modal .modal-section:nth-of-type(1) h4', 'settingsThemeHeading', { selector: '#settings-modal .modal-section:nth-of-type(1) h4' });
                const lightLabel = settingsM.querySelector('input[value="light"]')?.parentElement; if(lightLabel) lightLabel.childNodes[lightLabel.childNodes.length-1].nodeValue = ` ${strings.settingsLightMode || 'Light Mode'} ☀️`;
                const darkLabel = settingsM.querySelector('input[value="dark"]')?.parentElement; if(darkLabel) darkLabel.childNodes[darkLabel.childNodes.length-1].nodeValue = ` ${strings.settingsDarkMode || 'Dark Mode'} 🌙`;
                setText('settings-modal .modal-section:nth-of-type(2) h4', 'settingsDataHeading', { selector: '#settings-modal .modal-section:nth-of-type(2) h4' });
                setText('settings-modal .modal-section:nth-of-type(2) p', 'settingsResetInfo', { selector: '#settings-modal .modal-section:nth-of-type(2) p' });
            }

             // Results Details Labels (Ensure these are called *after* results view is rendered if dynamic)
             setDetailLabel('subject', 'resultsSubjectLabel');
             setDetailLabel('semester', 'resultsSemesterLabel');
             setDetailLabel('unit', 'resultsUnitLabel');
             setDetailLabel('lesson', 'resultsLessonLabel');
             setDetailLabel('correct', 'resultsCorrectLabel');
             setDetailLabel('time', 'resultsTimeLabel');

             // Instructions (if quiz view is active and elements exist)
             const matchingInstructions = document.querySelector('.matching-instructions');
             if(matchingInstructions) matchingInstructions.textContent = strings.matchingInstruction || '';

             const orderingInstructions = document.querySelector('.ordering-instructions');
             if(orderingInstructions) {
                 const numItems = quizState?.questions[quizState.currentQuestionIndex]?.items?.length || 0;
                 const instructionText = strings.orderingInstruction || '';
                 orderingInstructions.textContent = numItems > 0 ? instructionText.replace('{num}', `1-${numItems}`) : instructionText.replace('{num}', 'N/A');
             }

             // Matching Headers (if quiz view is active and elements exist)
             const itemsHeader = document.querySelector('#prompts-column h4');
             if (itemsHeader) itemsHeader.textContent = strings.matchingItemsHeader || 'Items';
             const matchesHeader = document.querySelector('#matches-column h4');
             if (matchesHeader) matchesHeader.textContent = strings.matchingMatchesHeader || 'Matches';

             // Result Header Message (Ensure this is called *after* results view is rendered)
             const resultHeader = document.querySelector('.results-header');
             if (resultHeader) {
                 const score = quizState.totalQuestions > 0 ? (quizState.correctAnswers / quizState.totalQuestions) * 100 : 0;
                 let msgKey = 'quizResultPractice';
                 if (quizState.totalQuestions === 0) msgKey = 'quizResultNoQuestions';
                 else if (score >= 90) msgKey = 'quizResultExcellent';
                 else if (score >= 70) msgKey = 'quizResultGreat';
                 else if (score >= 50) msgKey = 'quizResultGood';
                 resultHeader.textContent = strings[msgKey] || '';
             }
        }


        // --- RTL and Theme Management ---
        function setRtlLayout(enable) {
            if (mainContainerElement) {
                const lang = enable ? 'ar' : 'en';
                mainContainerElement.classList.toggle('rtl-layout', enable);
                if (document.documentElement.lang !== lang) {
                    updateUiLanguage(lang);
                }
            }
        }
        function applyTheme(t){document.body.classList.toggle('dark-theme',t==='dark');const r=settingsModalElement?.querySelectorAll('input[name="theme"]');if(r)r.forEach(rd=>rd.checked=rd.value===t);}
        function handleThemeChange(e){const n=e.target.value;applyTheme(n);localStorage.setItem(LS_THEME_KEY,n);}
        function loadAndApplyTheme(){const s=localStorage.getItem(LS_THEME_KEY);const c=s||'dark';applyTheme(c);if(!s)localStorage.setItem(LS_THEME_KEY,'dark');}
        function toggleSettingsModal(s){
            if(!settingsModalElement)return;
            if(s){
                const c=localStorage.getItem(LS_THEME_KEY)||'dark';
                const r=settingsModalElement.querySelectorAll('input[name="theme"]');
                r.forEach(rd=>rd.checked=rd.value===c);
                settingsModalElement.classList.remove('hidden');
                setTimeout(()=>settingsModalElement.classList.add('visible'),10);
            } else {
                settingsModalElement.classList.remove('visible');
                setTimeout(()=>settingsModalElement.classList.add('hidden'),300);
            }
        }

        // --- Function to calculate total questions per subject from topicsData ---
        function calculateSubjectTotals() {
            // console.log("Calculating total questions per subject..."); // Debug log
            subjectTotalQuestions = {}; // Reset before calculating
            for (const subject in topicsData) {
                if (topicsData.hasOwnProperty(subject)) {
                    let totalQs = 0;
                    // Iterate through both semesters for the subject
                    for (const semester in topicsData[subject]) {
                        if (topicsData[subject].hasOwnProperty(semester) && topicsData[subject][semester].units) {
                            topicsData[subject][semester].units.forEach(unit => {
                                if (unit.lessons) {
                                    unit.lessons.forEach(lesson => {
                                        // Safely add the count of questions, default to 0 if undefined/null
                                        totalQs += lesson.questions?.length || 0;
                                    });
                                }
                            });
                        }
                    }
                    subjectTotalQuestions[subject] = totalQs; // Store the total for this subject
                }
            }
            // console.log("Pre-calculated Subject Totals:", subjectTotalQuestions); // Debug log
        }

        // --- Stats Modal ---
        function toggleStatsModal(show) {
            if (!statsModalElement) return;
            if (show) {
                populateStatsModal(); // Calculate and fill data
                statsModalElement.classList.remove('hidden');
                setTimeout(() => statsModalElement.classList.add('visible'), 10);
            } else {
                statsModalElement.classList.remove('visible');
                setTimeout(() => statsModalElement.classList.add('hidden'), 300);
            }
        }

        function calculateOverallStats() {
            const subjectStats = {};
            // Initialize stats object using the pre-calculated totals
            STATS_SUBJECT_ORDER.forEach(subj => {
                subjectStats[subj] = {
                    answered: 0, // Start answered count at 0
                    total: subjectTotalQuestions[subj] || 0, // Get total from pre-calculated map
                    time: 0
                };
            });

            let overallAnswered = 0;
            let overallTime = 0;
            // overallTotal will be calculated at the end by summing subject totals

            // Iterate through COMPLETED lesson stats to get ANSWERED counts and TIME
            for (const key in allLessonStats) {
                if (allLessonStats.hasOwnProperty(key)) {
                    const parts = key.split('-');
                    // Decode subject name properly
                    const subject = parts[0].replace(/__/g, '-').replace(/_/g, ' ');
                    const stat = allLessonStats[key];

                    // Ensure the subject exists in our stats object and the completed lesson wasn't empty
                    if (subjectStats[subject] !== undefined && stat.totalQuestions > 0) {
                        // Add the best score achieved for completed lessons
                        subjectStats[subject].answered += stat.bestScore;
                        // Add the best time for completed lessons
                        subjectStats[subject].time += stat.bestTime;

                        // Accumulate overall answered and time
                        overallAnswered += stat.bestScore;
                        overallTime += stat.bestTime;

                        // !!! DO NOT update subjectStats[subject].total here !!!
                        // It's already set from subjectTotalQuestions
                    } else if (subjectStats[subject] === undefined) {
                        // This case should ideally not happen if STATS_SUBJECT_ORDER is correct
                        console.warn(`Subject "${subject}" found in stats but not in STATS_SUBJECT_ORDER or subjectTotalQuestions.`);
                    }
                }
            }

            // Calculate the overall total by summing the pre-calculated totals for the displayed subjects
            let overallTotal = 0;
            STATS_SUBJECT_ORDER.forEach(subj => {
                overallTotal += subjectTotalQuestions[subj] || 0;
            });

            // console.log("Calculated Stats:", { subjectStats, overallAnswered, overallTotal, overallTime }); // Debug log
            return { subjectStats, overallAnswered, overallTotal, overallTime };
        }

        function populateStatsModal() {
            const { subjectStats, overallAnswered, overallTotal, overallTime } = calculateOverallStats();
            const tbody = document.getElementById('stats-table-body');
            const strings = getStrings();
            if (!tbody) return;

            tbody.innerHTML = ''; // Clear previous rows

            // Answers Row
            const answersRow = tbody.insertRow();
            const answersLabelCell = answersRow.insertCell();
            answersLabelCell.textContent = strings.statsAnswersLabel || 'Answers';

            STATS_SUBJECT_ORDER.forEach(subj => {
                const cell = answersRow.insertCell();
                const stats = subjectStats[subj];
                // Display answered/total using the pre-calculated total
                cell.textContent = stats ? `${stats.answered}/${stats.total}` : '0/0';
            });
            const totalAnswersCell = answersRow.insertCell();
            totalAnswersCell.textContent = `${overallAnswered}/${overallTotal}`; // Use calculated overall total

            // Time Row
            const timeRow = tbody.insertRow();
            const timeLabelCell = timeRow.insertCell();
            timeLabelCell.textContent = strings.statsTimeLabel || 'Time';

            STATS_SUBJECT_ORDER.forEach(subj => {
                const cell = timeRow.insertCell();
                const stats = subjectStats[subj];
                cell.textContent = stats ? formatTime(stats.time) : '0s';
            });
            const totalTimeCell = timeRow.insertCell();
            totalTimeCell.textContent = formatTime(overallTime);
        }


        function resetSavedData(){
            const strings = getStrings();
            const confirmMsg = strings.resetDataConfirm || 'Confirm Reset?';
            if (confirm(confirmMsg)) {
                localStorage.removeItem(LS_THEME_KEY);
                localStorage.removeItem(LS_VISITED_KEY);
                localStorage.removeItem(LS_STATS_KEY);
                allLessonStats = {};
                alert(strings.resetDataAlert || 'Data reset. Reloading.');
                location.reload();
            }
        }

        // --- Welcome Screen Logic ---
        function handleWelcome(){
            if(!welcomeViewElement||!mainContainerElement)return;
            const hasVisited = localStorage.getItem(LS_VISITED_KEY);
            if(hasVisited){
                welcomeViewElement.classList.add('hidden');
                mainContainerElement.classList.remove('initially-hidden');
                setTimeout(()=>{mainContainerElement.style.opacity=1;},50);
            } else {
                welcomeViewElement.classList.remove('hidden');
                mainContainerElement.classList.add('initially-hidden');
                mainContainerElement.style.opacity=0;
                const startButton=welcomeViewElement.querySelector('.get-started-btn');
                if(startButton) startButton.addEventListener('click',()=>{
                    localStorage.setItem(LS_VISITED_KEY,'true');
                    welcomeViewElement.classList.add('hidden');
                    mainContainerElement.classList.remove('initially-hidden');
                    setTimeout(()=>{mainContainerElement.style.opacity=1;},50);
                },{once:true});
            }
        }

        // --- DOM Ready Listener ---
        document.addEventListener('DOMContentLoaded',()=>{
            // Get DOM elements
            welcomeViewElement=document.getElementById('welcome-view');
            mainContainerElement=document.querySelector('.container');
            contentElement=document.getElementById('content');
            quizViewElement=document.getElementById('quiz-view');
            quizTitleElement=document.getElementById('quiz-title');
            quizContainerElement=document.getElementById('quiz-container');
            feedbackContainerElement=document.getElementById('feedback-container');
            quizButtonsContainerElement=document.getElementById('quiz-buttons-container');
            navSectionElement=document.querySelector('.nav-section');
            settingsButtonElement=document.getElementById('settings-btn');
            settingsModalElement=document.getElementById('settings-modal');
            statsButtonElement = document.getElementById('stats-btn');
            statsModalElement = document.getElementById('stats-modal');

            // Initial Setup
            calculateSubjectTotals(); // Calculate totals from topicsData FIRST
            loadAndApplyTheme();
            loadLessonStats();
            handleWelcome(); // Handle welcome screen visibility
            const initialSubjectBtn = document.querySelector('.nav-btn.active');
            const initialSubject = initialSubjectBtn?.dataset.subject || 'english';
            const initialLang = RTL_SUBJECTS.includes(initialSubject) ? 'ar' : 'en';
            setRtlLayout(RTL_SUBJECTS.includes(initialSubject)); // Set initial RTL based on active button
            updateUiLanguage(initialLang); // Set initial language based on active button

            // Event Listeners
            if(settingsButtonElement) settingsButtonElement.addEventListener('click',()=>toggleSettingsModal(true));
            if(statsButtonElement) statsButtonElement.addEventListener('click', () => toggleStatsModal(true));
            if(settingsModalElement){
                const themeRadios=settingsModalElement.querySelectorAll('input[name="theme"]');
                themeRadios.forEach(rd=>rd.addEventListener('change',handleThemeChange));
                const resetBtn=document.getElementById('reset-data-button');
                if(resetBtn) resetBtn.addEventListener('click',resetSavedData);
                settingsModalElement.addEventListener('click',(e)=>{if(e.target===settingsModalElement)toggleSettingsModal(false);});
                const closeHeaderBtn = document.getElementById('settings-modal-close-header');
                if (closeHeaderBtn) closeHeaderBtn.addEventListener('click', () => toggleSettingsModal(false));
                const closeFooterBtn = document.getElementById('settings-modal-close-footer');
                 if (closeFooterBtn) closeFooterBtn.addEventListener('click', () => toggleSettingsModal(false));
            }
            if (statsModalElement) {
                statsModalElement.addEventListener('click', (e) => { if (e.target === statsModalElement) toggleStatsModal(false); });
                const closeHeaderBtn = document.getElementById('stats-modal-close-header');
                if (closeHeaderBtn) closeHeaderBtn.addEventListener('click', () => toggleStatsModal(false));
                const closeFooterBtn = document.getElementById('stats-modal-close-footer');
                if (closeFooterBtn) closeFooterBtn.addEventListener('click', () => toggleStatsModal(false));
            }


            // Subject/Semester Buttons
            document.querySelectorAll('.nav-btn[data-subject]').forEach(b=>{b.addEventListener('click',function(){
                const strings = getStrings();
                const confirmMsg = strings.leaveQuizConfirm || "Leave quiz?";
                if (!quizViewElement.classList.contains('hidden') && !confirm(confirmMsg)) return;
                showTopicList(); // Go back to topic view
                document.querySelectorAll('.nav-btn[data-subject]').forEach(btn=>btn.classList.remove('active'));
                this.classList.add('active');
                updateContent(); // Update content based on new selection
            });});
            document.querySelectorAll('.semester-btn').forEach(b=>{b.addEventListener('click',function(){
                const strings = getStrings();
                const confirmMsg = strings.leaveQuizConfirm || "Leave quiz?";
                if (!quizViewElement.classList.contains('hidden') && !confirm(confirmMsg)) return;
                showTopicList(); // Go back to topic view
                document.querySelectorAll('.semester-btn').forEach(btn=>btn.classList.remove('active'));
                this.classList.add('active');
                updateContent(); // Update content based on new selection
            });});

            // Lesson Click
            if(contentElement) contentElement.addEventListener('click',(e)=>{
                const lessonBox=e.target.closest('.section-content');
                if(lessonBox){
                    const strings = getStrings();
                    const confirmMsg = strings.leaveQuizConfirm || "Leave quiz?";
                    // Only confirm if actually in quiz view
                    if (!quizViewElement.classList.contains('hidden') && !confirm(confirmMsg)) return;
                    // If confirmed or not in quiz view, proceed
                    if (!quizViewElement.classList.contains('hidden')) {
                         cleanupQuizView();
                    }
                    const s=lessonBox.dataset.subject,sem=lessonBox.dataset.semester,u=lessonBox.dataset.unit,les=lessonBox.dataset.lesson;
                    handleSectionClick(s,sem,u,les);
                }
            });

            window.addEventListener('resize',debounce(updateAllArrowPositions,250));

            // Only update content if the user has passed the welcome screen
            if(localStorage.getItem(LS_VISITED_KEY)) {
                 updateContent();
            }
        });

        // --- View Management ---
        function showTopicList(){
            if(!mainContainerElement || !contentElement || !quizViewElement || !navSectionElement) return;
            const currentSubject = document.querySelector('.nav-btn.active')?.dataset.subject || 'english';
            const isRTL = RTL_SUBJECTS.includes(currentSubject);

            mainContainerElement.classList.remove('hidden');
            contentElement.classList.remove('hidden');
            quizViewElement.classList.add('hidden');
            navSectionElement.classList.remove('hidden');

            setRtlLayout(isRTL); // Ensure layout matches current subject
            updateContent(); // Refresh content and stats display

            // Cleanup quiz-specific things
            cleanupQuizView(); // <-- Use the cleanup function

            // Optional: Scroll to top of container
            mainContainerElement.scrollIntoView({behavior:'smooth',block:'start'});
        }
        function showQuizView(){
             if(mainContainerElement&&contentElement&&quizViewElement&&navSectionElement){
                 mainContainerElement.classList.remove('hidden');
                 contentElement.classList.add('hidden');
                 quizViewElement.classList.remove('hidden');
                 navSectionElement.classList.add('hidden');
                 // Scroll to the top of the quiz view
                 quizViewElement.scrollIntoView({behavior:'smooth',block:'start'});
            }
        }
        function cleanupQuizView() {
            // Disconnect MutationObserver if it exists
            if (matchingArrowObserver) {
                matchingArrowObserver.disconnect();
                matchingArrowObserver = null;
            }
            // Remove SVG element if it exists
            if (matchingSvgElement && matchingSvgElement.parentNode) {
                matchingSvgElement.remove();
                matchingSvgElement = null;
            }
            // Destroy SortableJS instances (if using Drag-and-Drop alternative)
            quizState.matchingState?.sortableInstances?.forEach(instance => instance.destroy());

            // Reset quiz state (important parts)
            quizState = {
                currentQuestionIndex: 0, correctAnswers: 0, totalQuestions: 0,
                startTime: null, endTime: null, selectedAnswers: [], questions: [],
                originalQuestions: [], subject: '', unit: '', lesson: '', semester: '',
                matchingState: { selectedPromptElement: null, selectedMatchElement: null, userPairs: {}, sortableInstances: [] } // Reset matching state including sortable instances
            };
             // Clear dynamic containers just in case
             if (quizContainerElement) quizContainerElement.innerHTML = '';
             if (feedbackContainerElement) {
                 feedbackContainerElement.innerHTML = '';
                 feedbackContainerElement.classList.add('hidden');
             }
             if (quizButtonsContainerElement) quizButtonsContainerElement.innerHTML = '';
        }

        // --- Core Functions ---
        function updateContent() {
            const activeSubjectBtn = document.querySelector('.nav-btn[data-subject].active');
            const activeSemesterBtn = document.querySelector('.semester-btn.active');
            if (!activeSubjectBtn || !activeSemesterBtn || !contentElement) return;
            const activeSubject = activeSubjectBtn.dataset.subject;
            const activeSemester = activeSemesterBtn.dataset.semester;
            const sanitizedSubject = activeSubject.replace(/\s+/g, '-');
            const isRTL = RTL_SUBJECTS.includes(activeSubject);
            const lang = isRTL ? 'ar' : 'en';

            setRtlLayout(isRTL); // Set RTL layout first
            if(document.documentElement.lang !== lang) {
                updateUiLanguage(lang); // Update language if needed based on subject
            }

            // Hide all semester contents first
            contentElement.querySelectorAll('.semester-content').forEach(c => c.classList.remove('active'));

            // Find and show the active semester content
            const contentId = `${sanitizedSubject}-${activeSemester}`;
            const semesterContentElement = contentElement.querySelector(`#${contentId}`);
            if (semesterContentElement) {
                semesterContentElement.classList.add('active');
                updateLessonBoxDisplays(); // Update the stats/gradient display for the visible lessons
            } else {
                console.warn(`Semester content ID "#${contentId}" not found.`);
                // Optionally display a message in the content area
                contentElement.innerHTML = `<p>Content for ${activeSubject} - ${activeSemester} not found.</p>`;
            }
        }

        function handleSectionClick(subj,sem,unit,lesson){
            if(!subj||!sem||!unit||!lesson) {
                const strings = getStrings();
                alert(strings.defaultErrorMessage || "Error identifying topic.");
                return;
            }
            try{
                const originalQuestions = getQuestions(subj,sem,unit,lesson);
                showQuizView(); // Show the quiz view area *before* trying to populate it
                if(originalQuestions?.length) {
                    startQuiz(subj,sem,unit,lesson,originalQuestions);
                } else {
                    showError(subj,unit,lesson); // Show specific error if no questions found
                }
            } catch(e){
                console.error("Error handling section click:",e);
                showError(subj,unit,lesson, (getStrings().defaultErrorMessage || "Error loading quiz.")); // Show generic error
            }
        }

        function startQuiz(subj,sem,unit,lesson,originalQuestions){
            const shuffledQuestions = shuffleArray(originalQuestions);
            // Reset state
             quizState = {
                currentQuestionIndex: 0, correctAnswers: 0, totalQuestions: shuffledQuestions.length,
                startTime: new Date(), endTime: null, selectedAnswers: new Array(shuffledQuestions.length).fill(null),
                questions: shuffledQuestions, originalQuestions: originalQuestions,
                subject: subj, unit: unit, lesson: lesson, semester: sem,
                matchingState: { selectedPromptElement: null, selectedMatchElement: null, userPairs: {}, sortableInstances: [] } // Reset matching state
            };

            const isRTL = RTL_SUBJECTS.includes(subj);
            setRtlLayout(isRTL); // Set layout for the quiz

            if(quizTitleElement) {
                const strings = getStrings();
                quizTitleElement.textContent = `${strings.quizTitlePrefix || 'Quiz'}: ${lesson}`;
            }

            displayQuestion(); // Display the first question
        }

        function displayQuestion(){
            if(!quizContainerElement||!feedbackContainerElement||!quizButtonsContainerElement)return;

            const currentQuestion = quizState.questions[quizState.currentQuestionIndex];
            if(!currentQuestion){ // Safeguard
                console.warn("DisplayQuestion called but no current question found. Index:", quizState.currentQuestionIndex);
                displayResults(); // Go to results if out of bounds
                return;
            }

            // Clear previous content & cleanup specific things
            quizContainerElement.innerHTML='';
            feedbackContainerElement.innerHTML='';
            feedbackContainerElement.classList.add('hidden');
            quizButtonsContainerElement.innerHTML='';
            if(matchingArrowObserver){matchingArrowObserver.disconnect();matchingArrowObserver=null;}
            if(matchingSvgElement&&matchingSvgElement.parentNode){matchingSvgElement.remove();matchingSvgElement=null;}
            quizState.matchingState?.sortableInstances?.forEach(instance => instance.destroy());
            quizState.matchingState = { selectedPromptElement: null, selectedMatchElement: null, userPairs: {}, sortableInstances: [] }; // Ensure clean state


            // Create question wrapper
            const questionWrapper=document.createElement('div');
            questionWrapper.className='question-display-wrapper';

            // Progress text
            const progressText=document.createElement('div');
            progressText.className='question-progress';
            progressText.textContent=`Q ${quizState.currentQuestionIndex+1}/${quizState.totalQuestions}`;
            questionWrapper.appendChild(progressText);

            // Question text
            const questionText=document.createElement('p');
            questionText.className='question-text';
            questionText.innerHTML=`<strong>Q:</strong> ${currentQuestion.question||'?'}`; // Use innerHTML for potential formatting
            questionWrapper.appendChild(questionText);

            // Wrapper for the specific question type content
            const typeWrapper=document.createElement('div');
            typeWrapper.className='question-type-wrapper';

            // Render based on type
            try{
                switch(currentQuestion.type){
                    case "matching":
                        renderMatching(currentQuestion,typeWrapper);
                        requestAnimationFrame(setupArrowObserver);
                        break;
                    case "ordering":
                        renderOrdering(currentQuestion,typeWrapper);
                        break;
                    case "multiple_choice":
                    default: // Default to multiple choice
                        renderMultipleChoice(currentQuestion,typeWrapper);
                        break;
                }
            } catch(e) {
                console.error("Render error for question type", currentQuestion.type, e);
                typeWrapper.innerHTML=`<p style="color:red;">Error displaying this question.</p>`;
            }

            questionWrapper.appendChild(typeWrapper);
            quizContainerElement.appendChild(questionWrapper);

            // Add buttons
            const submitButton=document.createElement('button');
            submitButton.className='btn submit-btn';
            submitButton.id='submit-btn';
            submitButton.innerHTML=`<span class="btn-text"></span>`; // Text set by updateUiLanguage
            submitButton.onclick=checkAnswer;

            const nextButton=document.createElement('button');
            nextButton.className='btn next-btn hidden'; // Start hidden
            nextButton.id='next-btn';
            nextButton.innerHTML=`<span class="btn-text"></span>`; // Text set by updateUiLanguage
            nextButton.onclick=nextQuestion;

            quizButtonsContainerElement.append(submitButton,nextButton);

            // Disable submit button initially for types requiring selection
            submitButton.disabled = true;
            if(currentQuestion.type === 'multiple_choice' || currentQuestion.type === 'ordering' || currentQuestion.type === 'matching') {
                 // Keep disabled, will be enabled by interaction handlers
            } else {
                 submitButton.disabled = false; // Enable for unknown/simple types
            }

            updateUiLanguage(getCurrentLang()); // Ensure button text is set correctly
        }

        // --- Rendering Functions ---
        function renderMultipleChoice(q,container){
            if(!q.options?.length) { container.textContent='Error: No options provided.'; return; }
            const optionsDiv=document.createElement('div');
            optionsDiv.className='options-container';
            q.options.forEach((optionText,i)=>{
                const id=`option-${i}`;
                const label=document.createElement('label');
                label.className='option-label';
                label.htmlFor=id;
                const input=document.createElement('input');
                input.type='radio';
                input.name='question-option';
                input.value=i;
                input.id=id;
                input.className='option-input';
                input.addEventListener('change',()=>{
                    const submitBtn=document.getElementById('submit-btn');
                    if(submitBtn) submitBtn.disabled=false; // Enable submit on selection
                });
                const text=document.createElement('span');
                text.className='option-text';
                text.textContent=optionText;
                label.append(input,text);
                optionsDiv.appendChild(label);
            });
            container.appendChild(optionsDiv);
        }

        function renderMatching(question, container) {
             if (!question.prompts?.length || !question.matches?.length || question.prompts.length !== question.matches.length) { container.textContent = 'Error: Matching data is invalid.'; return; }

             const strings = getStrings();
             quizState.matchingState.userPairs = {}; // Reset pairs for the new question
             quizState.matchingState.selectedPromptElement = null;
             quizState.matchingState.selectedMatchElement = null;

             // Instructions
             const instr = document.createElement('p');
             instr.className = 'matching-instructions';
             instr.textContent = strings.matchingInstruction || '';
             container.appendChild(instr);

             // Outer container for relative positioning of SVG
             const outer = document.createElement('div');
             outer.style.position = 'relative'; // Crucial for SVG positioning
             outer.id = `matching-outer-${quizState.currentQuestionIndex}`;
             container.appendChild(outer);

             // SVG for arrows
             matchingSvgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
             matchingSvgElement.id = 'matching-arrow-svg';
             matchingSvgElement.innerHTML = '<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="var(--accent-color)"/></marker></defs>';
             outer.appendChild(matchingSvgElement); // Add SVG first (z-index matters less if added first)

             // Container for the two columns
             const matchCont = document.createElement('div');
             matchCont.className = 'matching-container';
             matchCont.id = 'matching-cols'; // ID for observer

             // Prompt Column
             const promCol = document.createElement('div');
             promCol.className = 'matching-column';
             promCol.id = 'prompts-column';
             promCol.innerHTML = `<h4>${strings.matchingItemsHeader || 'Items'}</h4>`;

             // Match Column
             const matCol = document.createElement('div');
             matCol.className = 'matching-column';
             matCol.id = 'matches-column';
             matCol.innerHTML = `<h4>${strings.matchingMatchesHeader || 'Matches'}</h4>`;

             // Shuffle matches for display
             const shuffledMatches = question.matches
                .map((text, originalIndex) => ({ text, originalIndex })) // Keep track of original index
                .sort(() => 0.5 - Math.random());

             // Create prompt items
             question.prompts.forEach((promptText, promptIndex) => {
                 const item = document.createElement('div');
                 item.className = 'matching-item prompt-item';
                 item.textContent = promptText;
                 item.dataset.index = promptIndex; // Store original index
                 item.id = `prompt-${promptIndex}`;
                 item.onclick = handleMatchingClick;
                 // item.onkeydown = handleMatchingKeydown; // Add if keyboard nav is needed
                 promCol.appendChild(item);
             });

             // Create shuffled match items
             shuffledMatches.forEach(matchObject => {
                 const item = document.createElement('div');
                 item.className = 'matching-item match-item';
                 item.textContent = matchObject.text;
                 item.dataset.index = matchObject.originalIndex; // Store original index
                 item.id = `match-${matchObject.originalIndex}`;
                 item.onclick = handleMatchingClick;
                 // item.onkeydown = handleMatchingKeydown; // Add if keyboard nav is needed
                 matCol.appendChild(item);
             });

             matchCont.append(promCol, matCol);
             outer.appendChild(matchCont); // Add columns container to the outer div
        }

        function renderOrdering(q,container){
            if(!q.items?.length) { container.textContent='Error: Ordering data invalid.'; return; }
            const strings = getStrings();
            const numItems = q.items.length;

            // Instructions
            const instr = document.createElement('p');
            instr.className='ordering-instructions';
            const instructionText = strings.orderingInstruction || '';
            instr.textContent = numItems > 0 ? instructionText.replace('{num}', `1-${numItems}`) : instructionText.replace('{num}', 'N/A');
            container.appendChild(instr);

            // Container for items
            const orderingContainer=document.createElement('div');
            orderingContainer.className='ordering-container';
            orderingContainer.id='ordering-list'; // ID for targeting selects

            // Function to check if all selects have a value
            const checkCompletion=()=>{
                const allSelects=orderingContainer.querySelectorAll('.ordering-select');
                const allSelected = Array.from(allSelects).every(select => select.value !== "");
                const submitBtn=document.getElementById('submit-btn');
                if(submitBtn) submitBtn.disabled=!allSelected;
            };

            // Shuffle items for display
            const shuffledItems = q.items
                .map((text, originalIndex) => ({ text, originalIndex }))
                .sort(() => 0.5 - Math.random());

            // Create items with selects
            shuffledItems.forEach(({text: itemText, originalIndex}) => {
                const itemDiv=document.createElement('div');
                itemDiv.className='ordering-item';
                itemDiv.dataset.originalIndex=originalIndex; // Store original index if needed

                const selectElement=document.createElement('select');
                selectElement.className='ordering-select';
                selectElement.dataset.itemIndex=originalIndex; // Link select to the original item index

                // Default placeholder option
                const defaultOpt=document.createElement('option');
                defaultOpt.value="";
                defaultOpt.textContent="-";
                defaultOpt.selected=true;
                defaultOpt.disabled=true; // Make placeholder unselectable after choosing
                selectElement.appendChild(defaultOpt);

                // Populate order numbers
                for(let j=1;j<=numItems;j++){
                    const opt=document.createElement('option');
                    opt.value=j;
                    opt.textContent=j;
                    selectElement.appendChild(opt);
                }

                selectElement.addEventListener('change', checkCompletion); // Check completion on change

                const textSpan=document.createElement('span');
                textSpan.className='ordering-text';
                textSpan.textContent=itemText;

                itemDiv.append(selectElement,textSpan);
                orderingContainer.appendChild(itemDiv);
            });
            container.appendChild(orderingContainer);
        }

        // --- Interaction Handlers ---
        function handleMatchingClick(event) {
            const clickedItem = event.target.closest('.matching-item');
            if (!clickedItem || clickedItem.disabled) return; // Ignore if disabled (after submit)

            const isRTL = mainContainerElement && mainContainerElement.classList.contains('rtl-layout');
            const isPrompt = clickedItem.classList.contains('prompt-item');
            const isMatch = clickedItem.classList.contains('match-item');
            const isAlreadyMatched = clickedItem.classList.contains('matched');
            const clickedIndex = clickedItem.dataset.index;

            // --- Case 1: Clicked a Matched Item (to unmatch) ---
            if (isAlreadyMatched) {
                let promptIndexToClear = -1;
                let matchIndexToClear = -1;

                // Find the corresponding prompt/match index
                if (isPrompt) {
                    promptIndexToClear = clickedIndex;
                    matchIndexToClear = quizState.matchingState.userPairs[promptIndexToClear];
                } else { // Clicked on a matched 'match' item
                    matchIndexToClear = clickedIndex;
                    // Find the prompt index that maps to this match index
                    promptIndexToClear = Object.keys(quizState.matchingState.userPairs).find(
                        pIdx => quizState.matchingState.userPairs[pIdx] == matchIndexToClear // Use == for potential string/number comparison
                    );
                }

                // If we found the pair, unmatch them
                if (promptIndexToClear != -1 && matchIndexToClear !== undefined && promptIndexToClear !== undefined) {
                    const promptElement = document.getElementById(`prompt-${promptIndexToClear}`);
                    const matchElement = document.getElementById(`match-${matchIndexToClear}`);

                    if (promptElement) promptElement.classList.remove('matched', 'selected');
                    if (matchElement) matchElement.classList.remove('matched', 'selected');

                    delete quizState.matchingState.userPairs[promptIndexToClear]; // Remove from state
                    removeArrow(promptIndexToClear); // Remove visual arrow

                    // Reset selection state if needed
                    quizState.matchingState.selectedPromptElement = null;
                    quizState.matchingState.selectedMatchElement = null;

                     // Disable submit button as the match is now incomplete
                    const submitBtn = document.getElementById('submit-btn');
                    if (submitBtn) submitBtn.disabled = true;
                }
                return; // Stop further processing for unmatching
            }

            // --- Case 2: Clicked an Unmatched Item ---
            const currentSelectedPrompt = quizState.matchingState.selectedPromptElement;
            const currentSelectedMatch = quizState.matchingState.selectedMatchElement;

            if (isRTL) { // Right-to-Left Logic (Match -> Prompt)
                 if (isMatch) { // Clicked a match item
                     if (clickedItem === currentSelectedMatch) { // Clicked same match again: Deselect
                         clickedItem.classList.remove('selected');
                         quizState.matchingState.selectedMatchElement = null;
                     } else { // Clicked a new match item
                         if (currentSelectedMatch) currentSelectedMatch.classList.remove('selected'); // Deselect old
                         clickedItem.classList.add('selected'); // Select new
                         quizState.matchingState.selectedMatchElement = clickedItem;
                         // If a prompt was also selected, deselect it (only one side active)
                         if (currentSelectedPrompt) {
                             currentSelectedPrompt.classList.remove('selected');
                             quizState.matchingState.selectedPromptElement = null;
                         }
                     }
                 } else if (isPrompt && currentSelectedMatch) { // Clicked a prompt WHILE a match is selected: Create Pair
                     const matchIndex = currentSelectedMatch.dataset.index;
                     const promptIndex = clickedIndex;

                     quizState.matchingState.userPairs[promptIndex] = parseInt(matchIndex, 10); // Store pair

                     // Update visual state
                     currentSelectedMatch.classList.remove('selected');
                     currentSelectedMatch.classList.add('matched');
                     clickedItem.classList.add('matched'); // Mark prompt as matched too
                     drawArrow(clickedItem, currentSelectedMatch, promptIndex); // Draw arrow (prompt -> match) NOTE: Swapped args for RTL

                     // Reset selection
                     quizState.matchingState.selectedMatchElement = null;

                     // Check if all prompts are matched to enable submit
                     const totalPrompts = document.querySelectorAll('.prompt-item').length;
                     const matchedCount = Object.keys(quizState.matchingState.userPairs).length;
                     const submitBtn = document.getElementById('submit-btn');
                     if (submitBtn && totalPrompts > 0 && totalPrompts === matchedCount) {
                         submitBtn.disabled = false;
                     }
                 }

            } else { // Left-to-Right Logic (Prompt -> Match) - Default
                 if (isPrompt) { // Clicked a prompt item
                     if (clickedItem === currentSelectedPrompt) { // Clicked same prompt again: Deselect
                         clickedItem.classList.remove('selected');
                         quizState.matchingState.selectedPromptElement = null;
                     } else { // Clicked a new prompt item
                         if (currentSelectedPrompt) currentSelectedPrompt.classList.remove('selected'); // Deselect old
                         clickedItem.classList.add('selected'); // Select new
                         quizState.matchingState.selectedPromptElement = clickedItem;
                          // If a match was also selected, deselect it (only one side active)
                         if (currentSelectedMatch) {
                             currentSelectedMatch.classList.remove('selected');
                             quizState.matchingState.selectedMatchElement = null;
                         }
                     }
                 } else if (isMatch && currentSelectedPrompt) { // Clicked a match WHILE a prompt is selected: Create Pair
                     const promptIndex = currentSelectedPrompt.dataset.index;
                     const matchIndex = clickedIndex;

                     quizState.matchingState.userPairs[promptIndex] = parseInt(matchIndex, 10); // Store pair

                     // Update visual state
                     currentSelectedPrompt.classList.remove('selected');
                     currentSelectedPrompt.classList.add('matched');
                     clickedItem.classList.add('matched'); // Mark match as matched too
                     drawArrow(currentSelectedPrompt, clickedItem, promptIndex); // Draw arrow (prompt -> match)

                     // Reset selection
                     quizState.matchingState.selectedPromptElement = null;

                     // Check if all prompts are matched to enable submit
                     const totalPrompts = document.querySelectorAll('.prompt-item').length;
                     const matchedCount = Object.keys(quizState.matchingState.userPairs).length;
                     const submitBtn = document.getElementById('submit-btn');
                     if (submitBtn && totalPrompts > 0 && totalPrompts === matchedCount) {
                         submitBtn.disabled = false;
                     }
                 }
            }
        }


        function drawArrow(promptElement, matchElement, promptIndex) {
    const svgContainer = matchingSvgElement; // Use the global variable
    // Ensure mainContainerElement is accessible
    const mainContainerElement = document.getElementById('main-container'); // Replace with your actual main container ID or reference
    const outerDiv = document.getElementById(`matching-outer-${quizState.currentQuestionIndex}`);

    if (!svgContainer || !promptElement || !matchElement || !outerDiv || !mainContainerElement) {
        console.warn("drawArrow: Missing required elements.", {
            svg: !!svgContainer,
            prompt: promptElement?.id,
            match: matchElement?.id,
            outer: !!outerDiv,
            main: !!mainContainerElement,
            index: promptIndex
        });
        return;
    }

    try {
        const svgRect = svgContainer.getBoundingClientRect();
        const promptRect = promptElement.getBoundingClientRect();
        const matchRect = matchElement.getBoundingClientRect();
        const isRTL = mainContainerElement.classList.contains('rtl-layout');

        let startX, startY, endX, endY;

        // Calculate midpoints relative to the SVG container's top-left corner
        const promptMidY = promptRect.top + promptRect.height / 2 - svgRect.top;
        const matchMidY = matchRect.top + matchRect.height / 2 - svgRect.top;

        // --- CORRECTED COORDINATE LOGIC FOR LTR/RTL ---
        // x1,y1 is always near the prompt, x2,y2 is always near the match (where marker-end goes)
        if (isRTL) {
            // RTL: Prompt on Right, Match on Left. Arrow points Left (<--).
            // Start (x1) on the Prompt's LEFT edge (facing the center gap)
            startX = promptRect.left - svgRect.left;
            startY = promptMidY;
            // End (x2) on the Match's RIGHT edge (facing the center gap)
            endX = matchRect.right - svgRect.left;
            endY = matchMidY;
        } else { // LTR
            // LTR: Prompt on Left, Match on Right. Arrow points Right (-->).
            // Start (x1) on the Prompt's RIGHT edge (facing the center gap)
            startX = promptRect.right - svgRect.left;
            startY = promptMidY;
            // End (x2) on the Match's LEFT edge (facing the center gap)
            endX = matchRect.left - svgRect.left;
            endY = matchMidY;
        }
        // --- END CORRECTED COORDINATE LOGIC ---

        // Safety check for coordinates
        if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY) ||
            !isFinite(startX) || !isFinite(startY) || !isFinite(endX) || !isFinite(endY)) {
            console.error("drawArrow: Invalid coordinates calculated.", { startX, startY, endX, endY, promptIndex, isRTL });
            return;
        }

        // Find existing line or create a new one
        let line = svgContainer.querySelector(`#arrow-${promptIndex}`);
        const isNewLine = !line;
        if (isNewLine) {
            line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            line.id = `arrow-${promptIndex}`;
            line.style.transition = 'opacity 0.3s ease-in-out';
            line.style.opacity = '0'; // Start invisible for new lines
            svgContainer.appendChild(line);
        }

        // Set line attributes (position, style, marker)
        line.setAttribute('x1', startX);
        line.setAttribute('y1', startY);
        line.setAttribute('x2', endX);
        line.setAttribute('y2', endY);
        line.setAttribute('stroke', 'var(--accent-color, black)');
        line.setAttribute('stroke-width', '2');

        // --- ALWAYS Use marker-end ---
        // The coordinate calculation now correctly defines the line direction (L->R or R->L)
        // so orient="auto" on marker-end should work for both cases.
        line.removeAttribute('marker-start'); // Clean up just in case
        line.setAttribute('marker-end', 'url(#arrowhead)');

        // Fade in if it's a new line, otherwise ensure it's visible
        if (isNewLine) {
             requestAnimationFrame(() => {
                 // Double rAF sometimes helps ensure transition applies correctly
                 requestAnimationFrame(() => {
                    line.style.opacity = '1';
                 });
             });
        } else {
             line.style.opacity = '1'; // Ensure existing line is visible
        }

    } catch (e) {
        console.error("Error during drawArrow:", e, { promptIndex });
    }
}

// --- SVG Marker Definition Reminder ---
// Make sure you have this in your SVG <defs>
// Adjust refX so the TIP of the arrow aligns with the line end (x2, y2)
/*
<svg id="matching-svg-container-XYZ" ...>
  <defs>
    <marker
      id="arrowhead"
      viewBox="0 0 10 10"
      refX="8" <--- Adjust this value (often slightly less than markerWidth/viewBox width)
      refY="5"
      markerUnits="strokeWidth"
      markerWidth="4"
      markerHeight="4"
      orient="auto"> <--- Should now orient correctly based on line direction
      <path d="M 0 0 L 10 5 L 0 10 z" fill="var(--accent-color, black)"></path>
    </marker>
  </defs>
  <!-- Lines will be added here -->
</svg>
*/

        function removeArrow(pI){
            if(!matchingSvgElement)return;
            const l=matchingSvgElement.querySelector(`#arrow-${pI}`);
            if(l){
                l.style.opacity='0'; // Fade out
                setTimeout(()=>l.remove(),300); // Remove after fade out
            }
        }

        function updateAllArrowPositions(){
             // Only run if in matching question context
            if(!matchingSvgElement || !quizState || !quizState.questions[quizState.currentQuestionIndex] || quizState.questions[quizState.currentQuestionIndex].type !== 'matching') {
                 return;
            }
             const currentQuestionIndex = quizState.currentQuestionIndex; // Cache index
             const outerDiv = document.getElementById(`matching-outer-${currentQuestionIndex}`);
             if (!outerDiv) return; // Need the outer div for relative positioning

            const userPairs = quizState.matchingState.userPairs;
            for (const promptIndex in userPairs) {
                 if (userPairs.hasOwnProperty(promptIndex)) {
                     const matchIndex = userPairs[promptIndex];
                     const promptElement = document.getElementById(`prompt-${promptIndex}`);
                     const matchElement = document.getElementById(`match-${matchIndex}`);
                     if (promptElement && matchElement) {
                         drawArrow(promptElement, matchElement, promptIndex); // Redraw with current positions
                     } else {
                         // If elements are missing (shouldn't happen often), remove the arrow
                         removeArrow(promptIndex);
                     }
                 }
            }
        }

        function setupArrowObserver(){
            const targetNode = document.getElementById('matching-cols'); // Observe the columns container
            if (!targetNode || !matchingSvgElement) {
                 console.warn("Observer setup failed: Target 'matching-cols' or SVG missing.");
                 return;
            }

             // Disconnect previous observer if exists
            if (matchingArrowObserver) {
                matchingArrowObserver.disconnect();
            }

            // Configuration for the observer: observe layout changes
            const config = { attributes: true, childList: true, subtree: true, characterData: true }; // Watch everything for robustness

            // Callback function to execute when mutations are observed (debounced)
            const callback = debounce(updateAllArrowPositions, 50); // Debounce to avoid excessive calls

            // Create an observer instance linked to the callback function
            matchingArrowObserver = new MutationObserver(callback);

            // Start observing the target node for configured mutations
            matchingArrowObserver.observe(targetNode, config);

            // Also observe the main quiz container for potential class changes affecting layout
            const quizContainerTarget = document.getElementById('quiz-container');
            if(quizContainerTarget) {
                 matchingArrowObserver.observe(quizContainerTarget, { attributes: true, subtree: false }); // Observe class changes etc.
            }

            // Initial call to position arrows correctly after setup
             setTimeout(updateAllArrowPositions, 100); // Small delay ensures initial render is complete
        }


        // --- Answer Checking ---
        function checkAnswer(){
            if(!feedbackContainerElement||!quizButtonsContainerElement)return;

            // Disconnect observer to prevent updates during feedback display
            if(matchingArrowObserver){
                matchingArrowObserver.disconnect();
                matchingArrowObserver = null;
            }

            const currentQuestion = quizState.questions[quizState.currentQuestionIndex];
            let result = {isCorrect:false, feedback:'', userResponse:null, scoreIncrement:0};
            const strings = getStrings(); // Get current language strings

            try{
                switch(currentQuestion.type){
                    case "matching":
                        result = checkMatching(currentQuestion);
                        break;
                    case "ordering":
                        result = checkOrdering(currentQuestion);
                        break;
                    case "multiple_choice":
                    default:
                        result = checkMultipleChoice(currentQuestion);
                        break;
                }
            } catch(e){
                console.error("Error checking answer:", e);
                result = {isCorrect:false, feedback:`<div class="incorrect-feedback">${strings.defaultErrorMessage || 'Error checking answer.'}</div>`, userResponse:null, scoreIncrement:0};
            }

            // Store user's answer (or null if none selected)
            quizState.selectedAnswers[quizState.currentQuestionIndex]=result.userResponse;

            // Update score if correct
            if(result.scoreIncrement > 0) {
                quizState.correctAnswers+=result.scoreIncrement;
            }

            // Display feedback
            feedbackContainerElement.innerHTML=result.feedback; // This now includes the explanation
            feedbackContainerElement.classList.remove('hidden');

            // Disable inputs after answering
            disableInputs();

            // Show 'Next' or 'View Results' button, hide 'Submit'
            const submitBtn=quizButtonsContainerElement.querySelector('#submit-btn');
            const nextBtn=quizButtonsContainerElement.querySelector('#next-btn');

            if(submitBtn) submitBtn.classList.add('hidden');
            if(nextBtn) {
                // Determine text for the next button
                const nextBtnTextKey = (quizState.currentQuestionIndex === quizState.totalQuestions - 1 && quizState.totalQuestions > 0) ? 'viewResults' : 'next';
                const textSpan = nextBtn.querySelector('.btn-text');
                if (textSpan) textSpan.textContent = strings[nextBtnTextKey] || nextBtnTextKey; // Update text
                nextBtn.classList.remove('hidden'); // Show the button
            }
        }

        function checkMultipleChoice(q) {
            const selectedRadio = document.querySelector('input[name="question-option"]:checked');
            const strings = getStrings();

            if (!selectedRadio) {
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.selectAnswerPrompt || 'Please select an answer.'}</div>`, userResponse: null, scoreIncrement: 0 };
            }

            const selectedIndex = parseInt(selectedRadio.value, 10);
            const correctAnswerText = q.answer;
            const selectedAnswerText = q.options?.[selectedIndex];
            const isCorrect = selectedAnswerText === correctAnswerText;

            document.querySelectorAll('.option-label').forEach((label, i) => {
                const input = label.querySelector('input');
                if (q.options?.[i] === correctAnswerText) {
                    label.classList.add('correct-option');
                }
                if (input && input.checked && !isCorrect) {
                    label.classList.add('incorrect-option');
                }
            });

            // Generate primary feedback HTML
            let feedbackHTML = isCorrect
                ? `<div class="correct-feedback">${strings.correctFeedback || 'Correct! ✓'}</div>`
                : `<div class="incorrect-feedback">${strings.incorrectFeedback || 'Incorrect.'} <span>${strings.correctAnswerIs || 'Correct answer:'} ${correctAnswerText || 'N/A'}</span></div>`;

            // Add Explanation
            if (q.explanation) {
                const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"'; // Basic check for Arabic characters
                feedbackHTML += `<div class="feedback-explanation"${dirAttr}>${q.explanation}</div>`; // Append explanation HTML with directionality hint
            }

            return { isCorrect: isCorrect, feedback: feedbackHTML, userResponse: selectedIndex, scoreIncrement: isCorrect ? 1 : 0 };
        }

        function checkMatching(q) {
            const userPairs = quizState.matchingState.userPairs;
            const correctPairs = q.answer || {};
            const totalCorrectPairs = Object.keys(correctPairs).length;
            let correctlyMatchedCount = 0;
            const strings = getStrings();

            if (totalCorrectPairs === 0) { // Handle case where no matching is defined as correct
                return { isCorrect: true, feedback: `<div class="correct-feedback">${strings.matchingNoMatchNeeded || 'No matching needed.'}</div>`, userResponse: userPairs, scoreIncrement: 0 };
            }

            for (const promptIndex in correctPairs) {
                if (userPairs.hasOwnProperty(promptIndex) && userPairs[promptIndex] == correctPairs[promptIndex]) { // Use == safety for potential type difference
                    correctlyMatchedCount++;
                }
            }

            const isFullyCorrect = correctlyMatchedCount === totalCorrectPairs && Object.keys(userPairs).length === totalCorrectPairs;
            const isPartiallyCorrect = correctlyMatchedCount > 0 && !isFullyCorrect;

            // Generate primary feedback message
            let feedbackHTML = "";
            if (isFullyCorrect) {
                feedbackHTML = `<div class="correct-feedback">${strings.matchingAllCorrect || 'Correct! ✓ All matched.'}</div>`;
            } else if (isPartiallyCorrect) {
                feedbackHTML = `<div class="partial-feedback">${(strings.matchingPartialCorrect || 'Partial correct: {correct}/{total}.').replace('{correct}', correctlyMatchedCount).replace('{total}', totalCorrectPairs)}</div>`;
            } else {
                feedbackHTML = `<div class="incorrect-feedback">${(strings.matchingNoneCorrect || 'Incorrect: 0/{total} matched.').replace('{total}', totalCorrectPairs)}</div>`;
            }

             // Add Explanation
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                feedbackHTML += `<div class="feedback-explanation"${dirAttr}>${q.explanation}</div>`;
            }

            // Apply visual feedback to arrows and items
            for (const promptIndex in userPairs) {
                if (userPairs.hasOwnProperty(promptIndex)) {
                    const userMatchIndex = userPairs[promptIndex];
                    const correctMatchIndex = correctPairs[promptIndex];
                    const isPairCorrect = correctMatchIndex !== undefined && userMatchIndex == correctMatchIndex; // Use == safety

                    const line = matchingSvgElement?.querySelector(`#arrow-${promptIndex}`);
                    const promptEl = document.getElementById(`prompt-${promptIndex}`);
                    const userMatchEl = document.getElementById(`match-${userMatchIndex}`);

                    if (!line || !promptEl || !userMatchEl) continue; // Skip if elements are missing

                    if (isPairCorrect) {
                        line.style.stroke = 'var(--correct-border)';
                        const arrowhead = line.parentNode.querySelector('#arrowhead polygon'); // Find arrowhead within SVG
                        if (arrowhead) arrowhead.setAttribute('fill', 'var(--correct-border)');
                        promptEl.style.borderColor = 'var(--correct-border)';
                        userMatchEl.style.borderColor = 'var(--correct-border)';
                    } else {
                        line.style.stroke = 'var(--incorrect-border)';
                        const arrowhead = line.parentNode.querySelector('#arrowhead polygon');
                         if (arrowhead) arrowhead.setAttribute('fill', 'var(--incorrect-border)');
                        promptEl.style.borderColor = 'var(--incorrect-border)';
                        userMatchEl.style.borderColor = 'var(--incorrect-border)';
                        // Optional: Draw correct arrow if user was wrong
                        // if (correctMatchIndex !== undefined) { drawCorrectArrow(...) }
                    }
                }
            }
            // Optional: Draw arrows for correct pairs the user missed entirely

            // Score is 1 only if fully correct for matching
            return { isCorrect: isFullyCorrect, feedback: feedbackHTML, userResponse: userPairs, scoreIncrement: isFullyCorrect ? 1 : 0 };
        }


        function checkOrdering(q) {
            const originalItems = q.items || [];
            const correctAnswerOrder = q.answer || [];
            const numItems = originalItems.length;
            const strings = getStrings();

            if (numItems === 0 || !Array.isArray(correctAnswerOrder) || numItems !== correctAnswerOrder.length) {
                console.error("Invalid ordering question data:", q);
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.orderingInvalidData || 'Error: Invalid ordering setup.'}</div>`, userResponse: null, scoreIncrement: 0 };
            }

            const userOrderMap = {}; // Maps original item index -> user selected position (1-based)
            const selectedPositions = new Set();
            let allSelected = true;
            let hasDuplicates = false;

            const selectElements = document.querySelectorAll("#ordering-list .ordering-select");
            if (selectElements.length !== numItems) {
                console.error("Ordering Error: Select element count mismatch.");
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.orderingSelectionError || 'Error processing selections.'}</div>`, userResponse: null, scoreIncrement: 0 };
            }

            selectElements.forEach(select => {
                const itemIndex = parseInt(select.dataset.itemIndex, 10); // Original index of the item text
                const selectedValue = select.value;
                if (selectedValue === "") {
                    allSelected = false;
                } else {
                    const position = parseInt(selectedValue, 10);
                    if (isNaN(position) || position < 1 || position > numItems) {
                        allSelected = false; // Invalid selection
                        return; // Skip this select
                    }
                    userOrderMap[itemIndex] = position;
                    if (selectedPositions.has(position)) {
                        hasDuplicates = true;
                    }
                    selectedPositions.add(position);
                }
            });

            if (!allSelected) { return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.orderingSelectAll || 'Please select an order for all items.'}</div>`, userResponse: userOrderMap, scoreIncrement: 0 }; }
            if (hasDuplicates || selectedPositions.size !== numItems) {
                const numText = numItems > 1 ? (strings.orderingUseEachNumOncePlural || 'numbers 1-{n}').replace('{n}', numItems) : (strings.orderingUseEachNumOnceSingular || 'number 1');
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${(strings.orderingDuplicateUse || 'Please use each order {nums} exactly once.').replace('{nums}', numText)}</div>`, userResponse: userOrderMap, scoreIncrement: 0 };
            }

            // Construct the user's ordered array based on their selections
            const userOrderedItems = new Array(numItems).fill(null);
            let constructionOk = true;
            for (const itemIndexStr in userOrderMap) {
                if (userOrderMap.hasOwnProperty(itemIndexStr)) {
                    const itemIndex = parseInt(itemIndexStr, 10);
                    const itemText = originalItems[itemIndex]; // Get text from original array
                    const userPositionIndex = userOrderMap[itemIndex] - 1; // 0-based index

                    if (itemText === undefined || userPositionIndex < 0 || userPositionIndex >= numItems || userOrderedItems[userPositionIndex] !== null) {
                        constructionOk = false; break; // Error in construction
                    }
                    userOrderedItems[userPositionIndex] = itemText;
                }
            }
            if (!constructionOk || userOrderedItems.some(i => i === null)) {
                console.error("Ordering Error: Failed to construct user sequence.", userOrderMap, userOrderedItems);
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.orderingSequenceError || 'Error processing sequence.'}</div>`, userResponse: userOrderedItems, scoreIncrement: 0 };
            }

            // Compare the constructed user order with the correct order
            const isCorrect = JSON.stringify(userOrderedItems) === JSON.stringify(correctAnswerOrder);

            // Generate primary feedback HTML
            let feedbackHTML = isCorrect
                ? `<div class="correct-feedback">${strings.correctFeedback || 'Correct! ✓'}</div>`
                : `<div class="incorrect-feedback">${strings.incorrectFeedback || 'Incorrect.'} <span>${strings.correctAnswerIs || 'Correct order:'} ${correctAnswerOrder.join(" → ")}</span></div>`;

            // Add Explanation
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                feedbackHTML += `<div class="feedback-explanation"${dirAttr}>${q.explanation}</div>`;
            }

            // Apply visual feedback to selects
            selectElements.forEach(select => {
                const itemIndex = parseInt(select.dataset.itemIndex, 10);
                const itemText = originalItems[itemIndex];
                const userSelectedPosition = userOrderMap[itemIndex]; // 1-based
                const correctPosition = correctAnswerOrder.indexOf(itemText) + 1; // 1-based

                if (userSelectedPosition === correctPosition) {
                    select.style.borderColor = "var(--correct-border)";
                    select.style.backgroundColor = "var(--correct-bg)";
                } else {
                    select.style.borderColor = "var(--incorrect-border)";
                    select.style.backgroundColor = "var(--incorrect-bg)";
                }
                select.style.borderWidth = "2px"; // Make feedback visually clearer
            });

            // Return userOrderedItems array as the response for review
            return { isCorrect: isCorrect, feedback: feedbackHTML, userResponse: userOrderedItems, scoreIncrement: isCorrect ? 1 : 0 };
        }


        function disableInputs(){
            // Disable radio buttons and selects
            document.querySelectorAll('input[name="question-option"], .ordering-select')
                .forEach(input=>input.disabled=true);
            // Make radio labels non-clickable
            document.querySelectorAll('.option-label')
                .forEach(label=>label.style.cursor='default');
            // Make matching items non-clickable
            document.querySelectorAll('.matching-item')
                .forEach(item=>{
                    item.style.pointerEvents='none'; // Prevents click events
                    item.style.cursor='default';
                    // item.tabIndex = -1; // Remove from tab order if keyboard nav was added
                });
        }


        // --- Navigation and Results ---
        function nextQuestion(){
            quizState.currentQuestionIndex++;
            if(quizState.currentQuestionIndex<quizState.totalQuestions){
                displayQuestion(); // Display next question
            } else {
                quizState.endTime=new Date(); // Mark end time
                displayResults(); // Show results view
            }
        }

        function displayResults(){
            if(!quizContainerElement||!feedbackContainerElement||!quizButtonsContainerElement||!quizTitleElement)return;

            // Clear previous quiz content
            quizContainerElement.innerHTML='';
            feedbackContainerElement.classList.add('hidden');
            quizButtonsContainerElement.innerHTML='';

            const strings = getStrings();
            quizTitleElement.textContent = strings.viewResults || 'Quiz Results'; // Update title

            // Calculate time and score
            const timeTaken=quizState.endTime&&quizState.startTime?Math.round((quizState.endTime-quizState.startTime)/1000):0;
            const timeString=formatTime(timeTaken);
            const score = quizState.totalQuestions > 0 ? (quizState.correctAnswers / quizState.totalQuestions) * 100 : 0;
            const scoreRounded=score.toFixed(0);

            // Save stats if there were questions
            if(quizState.totalQuestions > 0){
                 // Pass the correct total questions count from the current quiz state
                 saveLessonStats(quizState.subject,quizState.semester,quizState.unit,quizState.lesson,quizState.correctAnswers,quizState.totalQuestions,timeTaken);
                 updateLessonBoxDisplays(); // Update the display on the topic list in the background
            }

            // Determine result message
            let resultMessageKey = 'quizResultPractice';
            if (quizState.totalQuestions === 0) resultMessageKey = 'quizResultNoQuestions';
            else if (score >= 90) resultMessageKey = 'quizResultExcellent';
            else if (score >= 70) resultMessageKey = 'quizResultGreat';
            else if (score >= 50) resultMessageKey = 'quizResultGood';
            const resultMessage = strings[resultMessageKey] || '';

            // Create results container
            const resultsDiv=document.createElement('div');
            resultsDiv.className='results-container';
            resultsDiv.innerHTML=`
                <h2 class="results-header">${resultMessage}</h2>
                <div class="results-score">
                    <div class="score-circle">
                        <span class="score-number">${scoreRounded}</span>
                        <span class="score-percent-sign">%</span>
                    </div>
                </div>
                <div class="results-details">
                    <p data-detail-key="subject"><span class="detail-icon">📚</span><strong>${strings.resultsSubjectLabel || 'Subject:'}</strong> <span class="detail-value">${quizState.subject||'N/A'}</span></p>
                    <p data-detail-key="semester"><span class="detail-icon">🗓️</span><strong>${strings.resultsSemesterLabel || 'Semester:'}</strong> <span class="detail-value">${quizState.semester||'N/A'}</span></p>
                    <p data-detail-key="unit"><span class="detail-icon">🔖</span><strong>${strings.resultsUnitLabel || 'Unit:'}</strong> <span class="detail-value">${quizState.unit||'N/A'}</span></p>
                    <p data-detail-key="lesson"><span class="detail-icon">📖</span><strong>${strings.resultsLessonLabel || 'Lesson:'}</strong> <span class="detail-value">${quizState.lesson||'N/A'}</span></p>
                    <p data-detail-key="correct"><span class="detail-icon">✅</span><strong>${strings.resultsCorrectLabel || 'Correct:'}</strong> <span class="detail-value">${quizState.correctAnswers}/${quizState.totalQuestions}</span></p>
                    <p data-detail-key="time"><span class="detail-icon">⏱️</span><strong>${strings.resultsTimeLabel || 'Time:'}</strong> <span class="detail-value">${timeString}</span></p>
                </div>
            `;
            quizContainerElement.appendChild(resultsDiv);

            // Create action buttons container
            const actionsDiv=document.createElement('div');
            actionsDiv.className='results-actions quiz-buttons'; // Use quiz-buttons for consistent styling

            // Redo Button
            const redoButton=document.createElement('button');
            redoButton.className='btn redo-btn';
            redoButton.id='redo-btn';
            redoButton.innerHTML=`🔄 <span class="btn-text">${strings.redoQuiz || 'Redo Quiz'}</span>`;
            redoButton.onclick=()=>{
                 // Restart the quiz with the original questions
                 startQuiz(quizState.subject,quizState.semester,quizState.unit,quizState.lesson,quizState.originalQuestions);
            };
            actionsDiv.appendChild(redoButton);

            // Review Button (only if there were questions)
            if(quizState.totalQuestions>0){
                const reviewButton=document.createElement('button');
                reviewButton.id='review-btn';
                reviewButton.className='btn review-btn';
                reviewButton.innerHTML=`🧐 <span class="btn-text">${strings.reviewAnswers || 'Review Answers'}</span>`;
                reviewButton.onclick=reviewAnswers;
                actionsDiv.appendChild(reviewButton);
            }

            // Back to Topics Button
            const backToTopicsButton=document.createElement('button');
            backToTopicsButton.className='btn back-to-topics-btn'; // Common class for styling
            backToTopicsButton.id='back-to-topics-btn-results'; // Specific ID
            backToTopicsButton.innerHTML=`<span>⬅️</span> <span class="btn-text">${strings.backToTopics || 'Back to Topics'}</span>`;
            backToTopicsButton.onclick=showTopicList;
            actionsDiv.appendChild(backToTopicsButton);

            quizButtonsContainerElement.appendChild(actionsDiv); // Add actions to the button container
        }


        // --- Answer Review ---
        function reviewAnswers(){
            if(!quizContainerElement||!feedbackContainerElement||!quizButtonsContainerElement||!quizTitleElement)return;

            // Clear results view
            quizContainerElement.innerHTML='';
            feedbackContainerElement.classList.add('hidden');
            quizButtonsContainerElement.innerHTML='';

            const strings = getStrings();
            quizTitleElement.textContent = `${strings.reviewTitlePrefix || 'Review'}: ${quizState.lesson || ''}`; // Update title

            const reviewDiv=document.createElement('div');
            reviewDiv.className='review-container';

            // Iterate through each question and its stored answer
            quizState.questions.forEach((q,i)=>{
                const questionDiv=document.createElement('div');
                const userAnswer=quizState.selectedAnswers[i]; // Get the stored answer/state

                // Determine status class and text
                let {correctnessClass: statusClass, statusText} = calculateReviewStatus(q, userAnswer);

                questionDiv.className=`question-review ${statusClass}`; // Apply class (correct, incorrect, partial)
                const questionTypeDisplay=(q.type||'multiple_choice').replace('_',' '); // Format type for display

                // Header with question number, type, and status
                questionDiv.innerHTML=`
                    <div class="review-question-header">
                        <span class="review-question-number">Q ${i+1} (${questionTypeDisplay})</span>
                        <span class="review-status">${statusText}</span>
                    </div>
                    <p class="review-question-text">${q.question||'?'}</p>
                    <div class="review-answer-content" id="review-answer-content-${i}"></div>
                `;
                reviewDiv.appendChild(questionDiv);

                // Get the content area and render the specific review details
                const contentArea=questionDiv.querySelector(`#review-answer-content-${i}`);
                if(contentArea){
                    try{
                        switch(q.type){
                            case"matching":
                                reviewMatchingReview(q,userAnswer,contentArea);
                                break;
                            case"ordering":
                                reviewOrderingReview(q,userAnswer,contentArea);
                                break;
                            case"multiple_choice":
                            default:
                                reviewMultipleChoiceReview(q,userAnswer,contentArea);
                                break;
                        }
                    } catch(e) {
                        console.error("Error rendering review answer for Q", i+1, e);
                        contentArea.innerHTML=`<p style="color:red">Error displaying review details.</p>`;
                    }
                } else {
                    console.warn(`Could not find content area for review question ${i}`);
                }
            });

            quizContainerElement.appendChild(reviewDiv); // Add all review questions to the container

            // Add action buttons for review view
            const actionsDiv=document.createElement('div');
            actionsDiv.className='review-actions quiz-buttons';

            // Back to Results Button
            const backToResultsButton=document.createElement('button');
            backToResultsButton.className='btn back-btn'; // Generic back button style
            backToResultsButton.id = 'back-btn'; // Specific ID
            backToResultsButton.innerHTML=`<span>←</span> <span class="btn-text">${strings.backToResults || 'Back to Results'}</span>`;
            backToResultsButton.onclick=displayResults; // Go back to the results summary
            actionsDiv.appendChild(backToResultsButton);

            // Back to Topics Button
            const backToTopicsButton=document.createElement('button');
            backToTopicsButton.className='btn back-to-topics-btn';
            backToTopicsButton.id = 'back-to-topics-btn-review'; // Specific ID
            backToTopicsButton.innerHTML=`<span>⬅️</span> <span class="btn-text">${strings.backToTopics || 'Back to Topics'}</span>`;
            backToTopicsButton.onclick=showTopicList; // Go directly back to topics
            actionsDiv.appendChild(backToTopicsButton);

            quizButtonsContainerElement.appendChild(actionsDiv);

            // Scroll to the top of the review container
            quizContainerElement.scrollIntoView({behavior:'smooth',block:'start'});
        }

        function calculateReviewStatus(q, userAnswer){
            let correctnessClass='incorrect'; // Default to incorrect
            let statusText = getStrings().reviewStatusIncorrect || '✗ Incorrect';
            let isCorrect = false;
            let isPartial = false;
            const strings = getStrings();

            try{
                switch(q.type){
                    case"matching":
                        const correctPairs = q.answer || {};
                        const totalCorrectPairs = Object.keys(correctPairs).length;
                        let correctlyMatchedCount = 0;
                        const userPairs = userAnswer || {}; // Ensure userAnswer is an object

                        if(totalCorrectPairs > 0 && typeof userPairs === 'object') {
                            for(const pI in correctPairs) {
                                // Use == for potential type difference (string index vs number value)
                                if(userPairs.hasOwnProperty(pI) && userPairs[pI] == correctPairs[pI]) {
                                    correctlyMatchedCount++;
                                }
                            }
                        }

                        // Determine status based on counts
                        isCorrect = totalCorrectPairs > 0 && correctlyMatchedCount === totalCorrectPairs && Object.keys(userPairs).length === totalCorrectPairs;
                        isPartial = totalCorrectPairs > 0 && correctlyMatchedCount > 0 && !isCorrect;

                        if (isCorrect) {
                            correctnessClass = "correct";
                            statusText = strings.reviewStatusCorrect || "✓ Correct";
                        } else if (isPartial) {
                            correctnessClass = "partial";
                            statusText = (strings.reviewStatusPartial || "~ Partial ({correct}/{total})")
                                .replace('{correct}', correctlyMatchedCount)
                                .replace('{total}', totalCorrectPairs);
                        } else if (userAnswer === null || (typeof userAnswer === 'object' && Object.keys(userAnswer).length === 0 && totalCorrectPairs > 0)) {
                             // If there were pairs to match, but none were attempted OR userAnswer is explicitly null
                            statusText = strings.reviewStatusUnanswered || 'Unanswered';
                            correctnessClass = 'incorrect'; // Unanswered is still treated as incorrect status
                        } // else remains 'incorrect'
                        break;

                    case"ordering":
                         // userAnswer for ordering is the user-constructed ordered array of items
                        isCorrect = userAnswer && Array.isArray(userAnswer) && q.answer && Array.isArray(q.answer) && JSON.stringify(userAnswer) === JSON.stringify(q.answer);

                        if (userAnswer === null || !Array.isArray(userAnswer)) {
                            statusText = strings.reviewStatusUnanswered || 'Unanswered';
                            correctnessClass = 'incorrect'; // Unanswered is treated as incorrect
                        } else if (isCorrect) {
                            correctnessClass = "correct";
                            statusText = strings.reviewStatusCorrect || "✓ Correct";
                        } // else remains 'incorrect'
                        break;

                    case"multiple_choice":
                    default:
                         // userAnswer for MC is the selected index (number or null)
                        isCorrect = userAnswer !== null && q.options && q.answer && q.options[userAnswer] === q.answer;

                        if (userAnswer === null) { // User didn't select anything
                            statusText = strings.reviewStatusUnanswered || 'Unanswered';
                            correctnessClass = 'incorrect'; // Unanswered is incorrect
                        } else if (isCorrect) {
                            correctnessClass = "correct";
                            statusText = strings.reviewStatusCorrect || "✓ Correct";
                        } // else remains 'incorrect'
                        break;
                }
            } catch(e) {
                console.error("Error calculating review status:", e);
                correctnessClass = 'incorrect';
                statusText = 'Error'; // Indicate an error occurred
            }
            return { correctnessClass, statusText };
        }

        function reviewMultipleChoiceReview(q, userAnswerIndex, container) { // uAI is User Answer Index
            const strings = getStrings();
            const div = document.createElement("div");
            div.className = "review-mc-answer";

            const userSelectedText = (userAnswerIndex !== null && q.options?.[userAnswerIndex] !== undefined)
                ? q.options[userAnswerIndex]
                : `(${strings.reviewStatusUnanswered || "No answer"})`; // Handle unanswered

            const isCorrect = (userAnswerIndex !== null && userSelectedText === q.answer);

            let userAnswerHTML = `<span class="user-answer-text`;
            if (userAnswerIndex === null) userAnswerHTML += `">`; // No specific style for unanswered text itself
            else if (isCorrect) userAnswerHTML += ` correct">`;
            else userAnswerHTML += ` incorrect">`; // Incorrect will have line-through via CSS
            userAnswerHTML += `${userSelectedText}</span>`;

            let htmlContent = `<p><strong>${strings.resultsYourAnswerLabel || 'Your Answer:'}</strong> ${userAnswerHTML}</p>`;

            // Show correct answer if user was incorrect OR unanswered
            if (!isCorrect) {
                htmlContent += `<p><strong>${strings.resultsCorrectAnswerLabel || 'Correct Answer:'}</strong> <span class="correct-answer-text">${q.answer || "N/A"}</span></p>`;
            }

            // Add Explanation
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                htmlContent += `<div class="feedback-explanation"${dirAttr}>${q.explanation}</div>`;
            }

            div.innerHTML = htmlContent;
            container.appendChild(div);
        }

        function reviewMatchingReview(q, userPairs, container) { // userPairs is the map {promptIndex: matchIndex}
            const strings = getStrings();
            const reviewDiv = document.createElement("div");
            reviewDiv.className = "review-matching-answer";

            const correctPairs = q.answer || {};
            const promptsList = q.prompts || [];
            const matchesList = q.matches || [];

            // Build the grid HTML
            let gridHtml = `<div class="review-matching-grid">`;
            let promptsColContent = `<div class="review-matching-column"><h4>${strings.matchingItemsHeader || 'Items'}</h4>`;
            let matchesColContent = `<div class="review-matching-column"><h4>${strings.matchingMatchesHeader || 'Matches'}</h4>`;

            promptsList.forEach((promptText, promptIndex) => {
                const userMatchIndex = (userPairs && userPairs[promptIndex] !== undefined) ? userPairs[promptIndex] : null;
                const correctMatchIndex = (correctPairs[promptIndex] !== undefined) ? correctPairs[promptIndex] : null; // Handle potential undefined correct answer
                const isPairCorrect = (userMatchIndex !== null && userMatchIndex == correctMatchIndex); // Use == safety

                const promptDivClass = isPairCorrect ? "review-matched-pair-correct" : "review-matched-pair-incorrect";
                promptsColContent += `<div class="${promptDivClass}">${promptIndex + 1}. ${promptText}</div>`;

                const correctMatchText = (correctMatchIndex !== null && matchesList[correctMatchIndex] !== undefined) ? matchesList[correctMatchIndex] : "(N/A)";
                const userMatchText = (userMatchIndex !== null && matchesList[userMatchIndex] !== undefined) ? matchesList[userMatchIndex] : `(${strings.reviewStatusUnanswered || 'Unanswered'})`;

                let matchDivContent = '';
                let matchDivClass = '';
                if (isPairCorrect) {
                    matchDivContent = correctMatchText;
                    matchDivClass = "review-matched-pair-correct";
                } else {
                    // Show user's wrong answer crossed out, then correct answer
                    matchDivContent = `<span class="incorrect">${userMatchText}</span> <span class="correct-answer-text">(${correctMatchText})</span>`;
                     matchDivClass = "review-matched-pair-incorrect";
                     // Special handling for unanswered
                    if (userMatchIndex === null) {
                        matchDivContent = `<span class="user-answer-text">(${strings.reviewStatusUnanswered || 'Unanswered'})</span> <span class="correct-answer-text">(${correctMatchText})</span>`;
                    }
                }
                 matchesColContent += `<div class="${matchDivClass}">${matchDivContent}</div>`;
            });

            promptsColContent += `</div>`; // Close prompt column
            matchesColContent += `</div>`; // Close match column
            gridHtml += promptsColContent + matchesColContent + `</div>`; // Close grid

            // Start building final HTML content
            let htmlContent = `<p><strong>${strings.matchingMatchesHeader || 'Matches'}:</strong></p>` + gridHtml;

            // Add Explanation
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                htmlContent += `<div class="feedback-explanation"${dirAttr} style="margin-top: 15px;">${q.explanation}</div>`;
            }

            reviewDiv.innerHTML = htmlContent;
            container.appendChild(reviewDiv);
        }


        function reviewOrderingReview(q, userOrderedItems, container) { // uOI is User Ordered Items array or null
            const strings = getStrings();
            const div = document.createElement("div");
            div.className = "review-ordering-answer";

            const correctOrder = q.answer || [];
            const originalItems = q.items || []; // Needed if user didn't answer

            // Header
            let htmlContent = `<p><strong>${(strings.orderingInstruction || 'Ordering:').split(':')[0]}:</strong></p>`;

            // Build the list HTML showing the CORRECT order
            let listHtml = `<div class="review-ordering-list">`;
            correctOrder.forEach((correctItemText, correctIndex) => {
                const itemDiv = document.createElement("div");
                itemDiv.className = "review-ordering-list-item";

                const correctPosition = correctIndex + 1;
                let userPosition = null;
                let isItemCorrect = false;

                if (userOrderedItems && Array.isArray(userOrderedItems)) {
                    const userIndex = userOrderedItems.indexOf(correctItemText);
                    if (userIndex !== -1) {
                         userPosition = userIndex + 1; // 1-based position user placed it at
                         isItemCorrect = (userIndex === correctIndex); // Is it in the correct slot?
                    }
                }
                 // If userOrderedItems is null or item not found, userPosition remains null

                let numberSpanHTML = '';
                if (isItemCorrect) { // Correct item in correct position
                    numberSpanHTML = `<span class="review-order-number review-order-correct">${correctPosition}.</span>`;
                    itemDiv.style.backgroundColor = 'var(--correct-bg)';
                } else if (userPosition !== null) { // Correct item in INCORRECT position
                    numberSpanHTML = `<span class="review-order-number review-order-incorrect" style="text-decoration: line-through;">${userPosition}.</span> <span class="review-order-number review-order-correct">(${correctPosition}.)</span>`;
                    itemDiv.style.backgroundColor = 'var(--incorrect-bg)';
                } else { // Item was missed or user didn't answer
                     numberSpanHTML = `<span class="review-order-number review-order-incorrect">(${strings.reviewStatusUnanswered || 'NP'})</span> <span class="review-order-number review-order-correct">(${correctPosition}.)</span>`;
                    itemDiv.style.backgroundColor = 'var(--partial-bg)'; // Maybe different style for completely missed?
                }

                itemDiv.innerHTML = `${numberSpanHTML} ${correctItemText}`;
                listHtml += itemDiv.outerHTML; // Add the styled item's HTML
            });
             listHtml += `</div>`; // Close list

            htmlContent += listHtml;

            // Add Explanation
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                htmlContent += `<div class="feedback-explanation"${dirAttr} style="margin-top: 15px;">${q.explanation}</div>`;
            }

            div.innerHTML = htmlContent;
            container.appendChild(div);
        }


        // --- Error Display ---
        function showError(subj, unit, lesson, customMessage = '') {
            if(!quizContainerElement||!feedbackContainerElement||!quizButtonsContainerElement||!quizTitleElement)return;

            showQuizView(); // Ensure the quiz view area is visible
            const strings = getStrings();

            // Set title to indicate an error
            quizTitleElement.textContent = strings.defaultErrorMessage.includes('load')
                ? strings.defaultErrorMessage
                : 'Error';

            // Clear previous content
            quizContainerElement.innerHTML='';
            feedbackContainerElement.classList.add('hidden');
            quizButtonsContainerElement.innerHTML='';

            // Prepare error message
            const defaultMsg = (strings.defaultErrorMessage || "Could not load questions for \"{lesson}\" in \"{unit}\".").replace('{lesson}', lesson || 'N/A').replace('{unit}', unit || 'N/A');
            const displayMsg = customMessage || defaultMsg;

            // Create error display elements
            const errorDiv=document.createElement('div');
            errorDiv.className='error-display';
            errorDiv.innerHTML=`<div class="error-message">${displayMsg}</div>`;

            // Add a "Back to Topics" button
            const backBtn=document.createElement('button');
            backBtn.className='btn back-to-topics-btn';
            backBtn.id='back-to-topics-btn-error'; // Specific ID
            backBtn.innerHTML=`<span>⬅️</span> <span class="btn-text">${strings.backToTopics || 'Back to Topics'}</span>`;
            backBtn.onclick=showTopicList;
            errorDiv.appendChild(backBtn);

            quizContainerElement.appendChild(errorDiv); // Add error display to container
        }


        // --- Get Questions Data ---
        function getQuestions(subj,sem,unitT,lessonT){
            if(!subj||!sem||!unitT||!lessonT){
                console.error("Missing getQuestions parameters:",{subj,sem,unitT,lessonT});
                return[]; // Return empty array on error
            }
            try{
                const sD=topicsData[subj]?.[sem]; // Semester Data
                if(!sD?.units){
                    // console.warn(`Units missing for subject/semester: ${subj} -> ${sem}`);
                    return[];
                }
                const u=sD.units.find(un=>un?.title===unitT); // Unit
                if(!u?.lessons){
                    //  console.warn(`Unit not found or has no lessons: "${unitT}" in ${subj} -> ${sem}.`);
                     return[];
                }
                const l=u.lessons.find(ls=>ls?.title===lessonT); // Lesson
                if(!l){
                    //  console.warn(`Lesson not found: "${lessonT}" in unit "${unitT}".`);
                     return[];
                }

                // Check if questions exist and is an array
                if(Array.isArray(l.questions) && l.questions.length>0){
                    // Ensure all questions have a type (default to multiple_choice if missing)
                    return l.questions.map(q=>({
                        ...(q.type ? {} : { type: 'multiple_choice' }), // Add default type if missing
                        ...q
                    }));
                } else {
                    //  console.log(`No questions found for lesson "${lessonT}".`);
                     return[]; // Return empty array if no questions defined
                }
            }catch(e){
                console.error("Error retrieving questions:",e);
                return[]; // Return empty array on unexpected errors
            }
        }

        // *** Get only the count of questions for a lesson ***
        function getLessonQuestionCount(subj, sem, unitT, lessonT) {
            if (!subj || !sem || !unitT || !lessonT) {
                // console.warn("Missing getLessonQuestionCount parameters:", { subj, sem, unitT, lessonT });
                return 0; // Return 0 on error or missing params
            }
            try {
                const sD = topicsData[subj]?.[sem]; // Semester Data
                if (!sD?.units) {
                    // console.warn(`Units missing for count: ${subj} -> ${sem}`);
                    return 0;
                }
                const u = sD.units.find(un => un?.title === unitT); // Unit
                if (!u?.lessons) {
                    // console.warn(`Unit not found or no lessons for count: "${unitT}"`);
                    return 0;
                }
                const l = u.lessons.find(ls => ls?.title === lessonT); // Lesson
                if (!l || !Array.isArray(l.questions)) {
                    // console.log(`Lesson or questions array not found for count: "${lessonT}"`);
                    return 0;
                }
                return l.questions.length; // Return the actual current length
            } catch (e) {
                console.error("Error retrieving question count:", e);
                return 0; // Return 0 on unexpected errors
            }
        }
        // --- END OF questions.js ---
    </script>

</body>
</html>
