<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Question Bank</title>
    <style>
        /* --- START OF styles.css --- */
        :root {
            /* Light Theme Variables */
            --body-bg: #f8fafc;            --container-bg: #ffffff;
            --text-color: #1e293b;         --text-muted: #64748b;
            --text-heading: #0f172a;       --border-color: #e2e8f0;
            --border-color-hover: #cbd5e1; --accent-color: #2563eb;
            --accent-color-dark: #1d4ed8;  --accent-color-light: #dbeafe;
            --button-bg: #ffffff;          --button-border: #e0e0e0;
            --button-text: #334155;        --button-hover-bg: #f1f5f9;
            --button-active-bg: #0f172a;   --button-active-text: #ffffff;
            --button-secondary-bg: #64748b;--button-secondary-hover-bg: #475569;
            --button-disabled-bg: #94a3b8; --input-bg: #ffffff;
            --input-border: #cbd5e1;       --feedback-bg: #f1f5f9;
            --feedback-border: #e2e8f0;    --correct-bg: #dcfce7;
            --correct-border: #16a34a;     --correct-text: #065f46;
            --incorrect-bg: #fee2e2;       --incorrect-border: #ef4444;
            --incorrect-text: #b91c1c;     --partial-bg: #fef9c3;
            --partial-border: #f59e0b;     --partial-text: #854d0e;
            --shadow-color: rgba(0,0,0,0.05); --matched-item-bg: #e5e7eb;
            --matched-item-border: #9ca3af; --modal-overlay-bg: rgba(15, 23, 42, 0.6);
            --modal-bg: #ffffff;           --lesson-stat-text: #475569;
            --lesson-perfect-bg: #e0fadf;  --lesson-perfect-border: #54c780;
            --lesson-perfect-text: #065f46;--lesson-imperfect-bg: #ffe9e9;
            --lesson-imperfect-border: #f79494; --lesson-imperfect-text: #b91c1c;
            --table-border: #e2e8f0;       --table-header-bg: #f1f5f9;
        }

        body.dark-theme {
            /* Dark Theme Overrides */
            --body-bg: #0f172a;           --container-bg: #1e293b;
            --text-color: #cbd5e1;        --text-muted: #94a3b8;
            --text-heading: #f1f5f9;      --border-color: #334155;
            --border-color-hover: #475569;--accent-color: #3b82f6;
            --accent-color-dark: #2563eb; --accent-color-light: #1e3a8a;
            --button-bg: #334155;         --button-border: #475569;
            --button-text: #e2e8f0;       --button-hover-bg: #475569;
            --button-active-bg: #f1f5f9;  --button-active-text: #0f172a;
            --button-secondary-bg: #475569;--button-secondary-hover-bg: #52525b;
            --button-disabled-bg: #334155;--input-bg: #0f172a;
            --input-border: #475569;      --feedback-bg: #1e293b;
            --feedback-border: #334155;   --correct-bg: #064e3b;
            --correct-border: #10b981;    --correct-text: #a7f3d0;
            --incorrect-bg: #7f1d1d;      --incorrect-border: #f87171;
            --incorrect-text: #fecaca;    --partial-bg: #713f12;
            --partial-border: #fbbf24;    --partial-text: #fef08a;
            --shadow-color: rgba(0,0,0,0.2); --matched-item-bg: #475569;
            --matched-item-border: #64748b; --modal-overlay-bg: rgba(0, 0, 0, 0.7);
            --modal-bg: #1e293b;          --lesson-stat-text: #94a3b8;
            --lesson-perfect-bg: #064e3b; --lesson-perfect-border: #10b981;
            --lesson-perfect-text: #a7f3d0;--lesson-imperfect-bg: #7f1d1d;
            --lesson-imperfect-border: #f87171; --lesson-imperfect-text: #fecaca;
            --table-border: #334155;       --table-header-bg: #0f172a;
        }


        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            margin: 0; padding: 0; background-color: var(--body-bg);
            color: var(--text-color); transition: background-color 0.3s ease, color 0.3s ease;
        }

        /* --- RTL Layout --- */
        .rtl-layout { direction: rtl; }
        .rtl-layout * { direction: rtl; } /* Inherit by default */
        .rtl-layout [dir="ltr"] * { direction: ltr; } /* Allow overriding for specific LTR content */

        .rtl-layout .header { text-align: right; }
        /* Added rule for header buttons */
        .rtl-layout .header .header-buttons { flex-direction: row-reverse; }
        .rtl-layout .nav-btn { flex-direction: row-reverse; }
        .rtl-layout .nav-btn span:first-child { margin-left: 0; margin-right: 6px; }
        .rtl-layout .section-content {
            text-align: right; border-left-width: 1px; border-left-color: var(--button-border);
            border-right-width: 4px; border-right-color: transparent;
        }
        .rtl-layout .section-content.lesson-complete-perfect { border-right-color: var(--lesson-perfect-border); border-left-color: var(--lesson-perfect-border); }
        .rtl-layout .section-content.lesson-complete-imperfect { border-right-color: var(--lesson-imperfect-border); border-left-color: var(--lesson-imperfect-border); }
        .rtl-layout .lesson-title-text { margin-right: 0; margin-left: 10px; }
        .rtl-layout .lesson-stats-display { margin-left: 10px; margin-right: auto; }
        .rtl-layout .lesson-q-count { margin-left: 0; margin-right: 10px; }
        .rtl-layout #quiz-header { text-align: right; }
        .rtl-layout #quiz-header #back-to-topics-btn { flex-direction: row-reverse; }
        #back-to-topics-btn > span:first-child, /* LTR Arrow */
        .rtl-layout #back-to-topics-btn > span:first-child { /* RTL Arrow */
            display: inline-block; margin: 0 4px;
        }
        .rtl-layout .question-progress { text-align: left; }
        .rtl-layout .question-text { text-align: right; }
        .rtl-layout .question-text strong { margin-right: 0; margin-left: 5px; }
        .rtl-layout .option-label { flex-direction: row-reverse; }
        .rtl-layout .option-input { margin-right: 0; margin-left: 15px; }
        .rtl-layout .matching-container { flex-direction: row-reverse; } /* Flip columns */
        .rtl-layout .matching-column h4 { text-align: right; }
        .rtl-layout .ordering-item { flex-direction: row-reverse; }
        .rtl-layout .ordering-select { margin-right: 0; margin-left: 15px; }
        .rtl-layout #feedback-container { text-align: right; }
        .rtl-layout .incorrect-feedback span { text-align: right; }
        /* RTL: Adjust Explanation Alignment */
        .rtl-layout .feedback-explanation { text-align: right; }
        .rtl-layout .feedback-explanation[dir="ltr"] { text-align: left; } /* Keep LTR explanations left-aligned */
        .rtl-layout #quiz-buttons-container { justify-content: flex-start; }
        .rtl-layout .results-actions .back-to-topics-btn { margin-left: 0; margin-right: auto; }
        .rtl-layout .review-actions .back-to-topics-btn { margin-left: 0; margin-right: auto; }
        .rtl-layout .results-details { text-align: right; }
        .rtl-layout .results-details p { flex-direction: row-reverse; }
        .rtl-layout .results-details p strong { min-width: auto; margin-right: 0; margin-left: 10px; }
        .rtl-layout .review-question-header { flex-direction: row-reverse; }
        .rtl-layout .review-question-text { text-align: right; }
        .rtl-layout .review-mc-answer p, .rtl-layout .review-matching-answer p, .rtl-layout .review-ordering-answer p { text-align: right; }
        .rtl-layout .review-mc-answer p strong, .rtl-layout .review-matching-answer p strong, .rtl-layout .review-ordering-answer p strong { margin-right: 0; margin-left: 5px; }
        .rtl-layout .review-matching-grid { flex-direction: row-reverse; }
        .rtl-layout .review-matching-column div { text-align: right; }
        .rtl-layout .review-ordering-list-item { flex-direction: row-reverse; }
        .rtl-layout .review-order-number { margin-right: 0; margin-left: 8px; }
        .rtl-layout #settings-modal *, .rtl-layout #stats-modal * { direction: rtl; } /* Apply to stats modal too */
        .rtl-layout .modal-header { flex-direction: row-reverse; }
        .rtl-layout .theme-options label { flex-direction: row-reverse; }
        .rtl-layout .theme-options input[type="radio"] { margin-right: 0; margin-left: 10px;}
        .rtl-layout .modal-footer { text-align: left; }
        .rtl-layout .question-review { border-left-width: 1px; border-left-color: var(--border-color); border-right-width: 5px; border-right-color: transparent; }
        .rtl-layout .question-review.correct { border-right-color: var(--correct-border); }
        .rtl-layout .question-review.incorrect { border-right-color: var(--incorrect-border); }
        .rtl-layout .question-review.partial { border-right-color: var(--partial-border); }
        /* Ensure icons in buttons display correctly */
        .rtl-layout .btn > span:first-child { margin-left: 0; margin-right: 6px; }
        /* RTL Table Styles */
        .rtl-layout #stats-table th, .rtl-layout #stats-table td { text-align: right; }
        .rtl-layout #stats-table td:first-child, .rtl-layout #stats-table th:first-child { padding-left: 10px; padding-right: 0; }


        /* Welcome View */
        #welcome-view { display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; text-align: center; background-color: var(--body-bg); color: var(--text-color); padding: 40px 20px; }
        #welcome-view h1 { font-size: 28px; color: var(--text-heading); margin-bottom: 15px; }
        #welcome-view p { font-size: 16px; color: var(--text-muted); max-width: 600px; line-height: 1.6; margin-bottom: 25px; }
        #welcome-view .info-section { margin-bottom: 20px; font-size: 14px; }
        #welcome-view .info-section strong { display: block; margin-bottom: 5px; color: var(--text-heading); }
        #welcome-view .get-started-btn { margin-top: 30px; }

        /* Main Container */
        .container { max-width: 1200px; margin: 20px auto; background-color: var(--container-bg); padding: 20px 30px; border-radius: 12px; box-shadow: 0 2px 10px var(--shadow-color); border: 1px solid var(--border-color); transition: background-color 0.3s ease, border-color 0.3s ease, opacity 0.5s ease; opacity: 1; }
        .container.initially-hidden { opacity: 0; pointer-events: none; }

        .header { display: flex; justify-content: space-between; align-items: center; text-align: left; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        .header h1 { font-size: 24px; margin: 0; color: var(--text-heading); flex-grow: 1; } /* Allow title to grow */
        .header .header-buttons { display: flex; gap: 10px; } /* Container for buttons */
        #settings-btn, #stats-btn { background: none; border: 1px solid var(--button-border); color: var(--text-muted); padding: 6px 10px; border-radius: 6px; cursor: pointer; font-size: 20px; line-height: 1; transition: all 0.2s ease; }
        #settings-btn:hover, #stats-btn:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); color: var(--text-color); }

        /* Nav Section */
        .nav-section { display: flex; flex-direction: column; gap: 15px; margin-bottom: 20px; transition: opacity 0.3s ease, max-height 0.3s ease, visibility 0.3s ease, margin 0.3s ease, padding 0.3s ease; overflow: hidden; max-height: 500px; opacity: 1; visibility: visible; }
        .nav-section.hidden { max-height: 0; opacity: 0; margin-bottom: 0; padding: 0; border: none; visibility: hidden; }
        .subjects { display: flex; flex-wrap: wrap; gap: 10px; }
        .secondary-nav { display: flex; gap: 10px; align-items: center; }
        .nav-btn { padding: 8px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; display: flex; align-items: center; gap: 6px; background-color: var(--button-bg); border: 1px solid var(--button-border); transition: all 0.2s ease; color: var(--button-text); }
        .nav-btn:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); }
        .nav-btn.active { background-color: var(--button-active-bg); color: var(--button-active-text); border-color: var(--button-active-bg); }

        /* --- CSS FIX: Corrected rule for active nav button icon color --- */
        body.dark-theme .nav-btn.active span {
            filter: none;
        }
        body:not(.dark-theme) .nav-btn.active span {
            filter: brightness(0) invert(1);
        }
        /* --- End CSS Fix --- */

        .semester-toggle { display: flex; gap: 5px; background-color: var(--feedback-bg); padding: 4px; border-radius: 6px; border: 1px solid var(--button-border); }
        .semester-btn { padding: 6px 12px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; background: none; color: var(--text-muted); transition: all 0.2s ease; }
        .semester-btn.active { background-color: var(--container-bg); color: var(--text-heading); box-shadow: 0 1px 3px var(--shadow-color); }

        /* Topic List */
        #content {}
        .semester-title-container { margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .unit-title { font-size: 20px; font-weight: 600; color: var(--text-heading); margin: 0; }
        .section { background-color: var(--container-bg); border-radius: 12px; padding: 20px 25px; box-shadow: 0 1px 3px var(--shadow-color); border: 1px solid var(--border-color); margin-bottom: 20px; }
        .semester-content > .section:last-of-type { margin-bottom: 0; }
        .section-title { font-size: 17px; font-weight: 600; margin-bottom: 15px; color: var(--text-heading); }
        .section-content { padding: 12px 15px; background-color: var(--button-bg); border-radius: 8px; border: 1px solid var(--button-border); margin-bottom: 10px; cursor: pointer; transition: all 0.2s ease; font-size: 15px; color: var(--button-text); display: flex; justify-content: space-between; align-items: center; text-align: left; position: relative; overflow: hidden; border-left-width: 4px; border-left-color: transparent; }
        .section-content:last-child { margin-bottom: 0; }
        .section-content:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); transform: translateY(-1px); }
        .section-content.lesson-complete-perfect { background-color: var(--lesson-perfect-bg); border-color: var(--lesson-perfect-border); border-left-color: var(--lesson-perfect-border); }
        .section-content.lesson-complete-perfect span, .section-content.lesson-complete-perfect .lesson-stats-display { color: var(--lesson-perfect-text); font-weight: 500; }
        .section-content.lesson-complete-imperfect { background-color: var(--lesson-imperfect-bg); border-color: var(--lesson-imperfect-border); border-left-color: var(--lesson-imperfect-border); }
        .section-content.lesson-complete-imperfect span, .section-content.lesson-complete-imperfect .lesson-stats-display { color: var(--lesson-imperfect-text); font-weight: 500; }
        .lesson-title-text { flex-grow: 1; margin-right: 10px; }
        .lesson-stats-display { font-size: 0.8em; color: var(--lesson-stat-text); font-weight: 500; white-space: nowrap; flex-shrink: 0; margin-left: auto; padding: 0 10px; }
        .lesson-q-count { font-size: 0.8em; color: var(--lesson-stat-text); font-weight: 400; white-space: nowrap; flex-shrink: 0; }
        .section-content.lesson-complete-perfect .lesson-q-count, .section-content.lesson-complete-imperfect .lesson-q-count { color: inherit; opacity: 0.8; }
        .semester-content { display: none; }
        .semester-content.active { display: block; }

        /* Quiz View */
        #quiz-view { padding: 20px 0; }
        #quiz-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 1px solid var(--border-color); }
        #quiz-title { font-size: 20px; font-weight: 600; color: var(--text-heading); }
        #quiz-container { margin-bottom: 20px; }
        .question-type-wrapper { padding: 25px; border: 1px solid var(--border-color); border-radius: 8px; background-color: var(--container-bg); margin-bottom: 20px; box-shadow: 0 1px 2px var(--shadow-color); }
        .question-progress { font-size: 14px; color: var(--text-muted); margin-bottom: 15px; text-align: right; }
        .question-text { font-size: 18px; margin-bottom: 25px; line-height: 1.6; color: var(--text-color); }
        .question-text strong { font-weight: 600; margin-right: 5px; }

        /* MC */
        .options-container { display: flex; flex-direction: column; gap: 12px; margin-bottom: 0; }
        .option-label { display: flex; align-items: center; padding: 12px 15px; border: 1px solid var(--border-color); border-radius: 6px; cursor: pointer; transition: all 0.2s ease; background-color: var(--input-bg); }
        .option-label:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); }
        .option-label input:checked + .option-text { font-weight: 500; color: var(--accent-color); }
        .option-label input:checked { accent-color: var(--accent-color); }
        .option-input { margin-right: 15px; flex-shrink: 0; }
        .option-text { flex-grow: 1; font-size: 16px; color: var(--text-color); }

        /* Matching */
        .matching-instructions { font-size: 15px; color: var(--text-muted); margin-bottom: 20px; }
        .matching-container { position: relative; display: flex; justify-content: space-between; gap: 5%; margin-bottom: 0; }
        .matching-column { flex-basis: 47%; display: flex; flex-direction: column; gap: 10px; }
        .matching-column h4 { margin: 0 0 10px 0; font-size: 15px; font-weight: 600; color: var(--text-muted); border-bottom: 1px solid var(--border-color); padding-bottom: 5px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .matching-item { padding: 10px 15px; border: 1px solid var(--input-border); background-color: var(--input-bg); border-radius: 6px; cursor: pointer; transition: all 0.2s ease; font-size: 15px; display: flex; align-items: center; min-height: 30px; color: var(--text-color); }
        .matching-item:hover { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); }
        .matching-item.selected { background-color: var(--accent-color-light); border-color: var(--accent-color); font-weight: 500; }
        .matching-item.matched { background-color: var(--matched-item-bg); border-color: var(--matched-item-border); cursor: pointer; opacity: 1.0; }
        .matching-item:focus-visible { outline: 2px solid var(--accent-color); outline-offset: 1px; } /* Basic focus style if needed */
        #matching-arrow-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; overflow: visible; z-index: 1; }
        #matching-arrow-svg line { stroke: var(--accent-color); stroke-width: 2; transition: stroke 0.3s ease, opacity 0.3s ease; marker-end: url(#arrowhead); } /* Added stroke transition */
        #matching-arrow-svg #arrowhead polygon { fill: var(--accent-color); transition: fill 0.3s ease; }

        /* Ordering */
        .ordering-instructions { font-size: 15px; color: var(--text-muted); margin-bottom: 20px; }
        .ordering-container { display: flex; flex-direction: column; gap: 15px; margin-bottom: 0; }
        .ordering-item { display: flex; align-items: center; padding: 10px 15px; border: 1px solid var(--border-color); background-color: var(--input-bg); border-radius: 6px; }
        .ordering-select { margin-right: 15px; padding: 5px 8px; border-radius: 4px; border: 1px solid var(--input-border); font-size: 14px; min-width: 60px; background-color: var(--input-bg); color: var(--text-color); }
        .ordering-text { flex-grow: 1; font-size: 16px; color: var(--text-color); }

        /* Feedback & Buttons */
        #feedback-container { padding: 15px; margin-top: 20px; border-radius: 6px; background-color: var(--feedback-bg); border: 1px solid var(--feedback-border); }
        #feedback-container.hidden { display: none; }
        .correct-feedback { color: var(--correct-text); font-weight: 600; font-size: 16px; }
        .incorrect-feedback { color: var(--incorrect-text); font-weight: 600; font-size: 16px; }
        .incorrect-feedback span { display: block; font-weight: 500; margin-top: 8px; font-size: 15px; color: var(--text-muted); line-height: 1.5; }
        .partial-feedback { color: var(--partial-text); font-weight: 600; font-size: 16px; }
        .correct-option { background-color: var(--correct-bg) !important; border-color: var(--correct-border) !important; }
        .correct-option .option-text { color: var(--correct-text) !important; }
        .incorrect-option { background-color: var(--incorrect-bg) !important; border-color: var(--incorrect-border) !important; }
        .incorrect-option .option-text { color: var(--incorrect-text) !important; }
        /* --- START: Added Explanation CSS --- */
        .feedback-explanation {
            margin-top: 12px; /* Space between feedback/answer and explanation */
            padding-top: 12px;
            border-top: 1px solid var(--feedback-border); /* Separator line */
            font-size: 0.9em; /* Slightly smaller font */
            color: var(--text-muted); /* Muted text color */
            line-height: 1.6; /* Improve readability */
            text-align: left; /* Ensure LTR text aligns left even in RTL layout */
        }
        /* Ensure explanation text direction is LTR if content is always LTR */
        .feedback-explanation[dir="ltr"] {
            direction: ltr;
            text-align: left;
        }
        .rtl-layout .feedback-explanation {
            text-align: right; /* Align right in RTL layout */
        }
        .rtl-layout .feedback-explanation[dir="ltr"] {
            text-align: left; /* Override if explanation content is LTR */
        }
        /* Review screen specific margin */
        .review-answer-content .feedback-explanation {
            margin-top: 15px;
        }
        /* --- END: Added Explanation CSS --- */


        /* Button container */
        #quiz-buttons-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; margin-top: 25px; border-top: 1px solid var(--border-color); padding-top: 20px; }
        .results-actions, .review-actions { justify-content: space-between; width: 100%; }
        .results-actions { flex-wrap: wrap; justify-content: center; gap: 15px; }
        .results-actions .back-to-topics-btn { margin-left: auto; }
        .review-actions .back-to-topics-btn { margin-left: auto; }
        @media (max-width: 550px) { .results-actions, .review-actions { justify-content: center; } .results-actions .back-to-topics-btn, .review-actions .back-to-topics-btn { margin-left: 0; } }

        /* Buttons */
        .btn { padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: 500; transition: all 0.2s ease; line-height: 1.5; background-color: var(--button-bg); color: var(--button-text); border: 1px solid var(--button-border); display: inline-flex; align-items: center; gap: 6px; }
        .btn:hover:not(:disabled) { background-color: var(--button-hover-bg); border-color: var(--border-color-hover); transform: translateY(-1px); }
        .submit-btn { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        .submit-btn:hover:not(:disabled) { background-color: var(--accent-color-dark); border-color: var(--accent-color-dark); }
        .submit-btn:disabled { background-color: var(--button-disabled-bg); border-color: var(--button-disabled-bg); color: var(--text-muted); cursor: not-allowed; transform: none; }
        .next-btn { background-color: var(--correct-border); color: var(--correct-text); border-color: var(--correct-border); } body.dark-theme .next-btn { color: white; } .next-btn:hover { filter: brightness(1.1); }
        .review-btn { background-color: var(--correct-border); color: var(--correct-text); border-color: var(--correct-border); } body.dark-theme .review-btn { color: white; } .review-btn:hover { filter: brightness(1.1); }
        .redo-btn { background-color: #f97316; color: white; border-color: #f97316; } .redo-btn:hover { background-color: #ea580c; border-color: #ea580c; }
        .close-btn, .back-to-topics-btn, .back-btn { background-color: var(--button-secondary-bg); color: white; border-color: var(--button-secondary-bg); } .close-btn:hover, .back-to-topics-btn:hover, .back-btn:hover { background-color: var(--button-secondary-hover-bg); border-color: var(--button-secondary-hover-bg); }
        .reset-data-btn { background-color: var(--incorrect-border); color: var(--incorrect-text); border-color: var(--incorrect-border); } body.dark-theme .reset-data-btn { color: white; } .reset-data-btn:hover { filter: brightness(1.1); }

        .hidden { display: none !important; }

        /* Error Message */
        .error-display { padding: 30px; text-align: center; background-color: var(--incorrect-bg); border: 1px solid var(--incorrect-border); border-radius: 8px; }
        .error-message { color: var(--incorrect-text); font-weight: 500; margin-bottom: 20px; }

        /* Results */
        .results-container { padding: 20px 0; text-align: center; }
        .results-header { font-size: 28px; font-weight: 600; margin-bottom: 30px; color: var(--text-heading); }
        .results-score { margin: 30px 0 40px 0; }
        .score-circle { width: 150px; height: 150px; border-radius: 50%; background-color: var(--feedback-bg); display: flex; flex-direction: column; align-items: center; justify-content: center; margin: 0 auto; border: 8px solid var(--accent-color); box-shadow: 0 0 20px color-mix(in srgb, var(--accent-color) 25%, transparent), inset 0 0 10px color-mix(in srgb, var(--accent-color) 15%, transparent); transition: border-color 0.3s ease; }
        .score-number { font-size: 44px; font-weight: bold; color: var(--text-heading); line-height: 1; }
        .score-percent-sign { font-size: 20px; font-weight: 500; color: var(--text-muted); margin-top: 4px; }
        .results-details { max-width: 500px; margin: 0 auto 35px auto; text-align: left; background-color: var(--feedback-bg); padding: 20px 30px; border-radius: 10px; border: 1px solid var(--feedback-border); box-shadow: 0 2px 5px var(--shadow-color); }
        .results-details p { margin: 12px 0; font-size: 16px; color: var(--text-color); display: flex; align-items: center; gap: 10px; }
        .results-details p strong { color: var(--text-heading); min-width: 80px; display: inline-block; font-weight: 600; }
        .results-details p .detail-value { color: var(--text-muted); font-weight: 500; }
        .results-details p .detail-icon { font-size: 18px; color: var(--accent-color); width: 20px; text-align: center; }

        /* Review Answers */
        .review-container { padding: 10px 0; }
        .question-review { padding: 20px; margin-bottom: 20px; border-radius: 8px; border: 1px solid var(--border-color); border-left-width: 5px; background-color: var(--container-bg); }
        .question-review.correct { border-left-color: var(--correct-border); }
        .question-review.incorrect { border-left-color: var(--incorrect-border); }
        .question-review.partial { border-left-color: var(--partial-border); }
        .review-question-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); }
        .review-question-number { font-weight: 600; color: var(--text-heading); font-size: 16px; }
        .review-status { font-weight: 600; font-size: 14px; padding: 3px 8px; border-radius: 4px; text-align: center; }
        .question-review.correct .review-status { color: var(--correct-text); background-color: var(--correct-bg); }
        .question-review.incorrect .review-status { color: var(--incorrect-text); background-color: var(--incorrect-bg); }
        .question-review.partial .review-status { color: var(--partial-text); background-color: var(--partial-bg); }
        .review-question-text { margin-bottom: 15px; font-size: 16px; color: var(--text-color); }
        .review-mc-answer, .review-matching-answer, .review-ordering-answer { background-color: var(--feedback-bg); padding: 15px; border-radius: 6px; border: 1px solid var(--feedback-border); margin-top: 15px; }
        .review-mc-answer p, .review-matching-answer p, .review-ordering-answer p { margin: 8px 0; font-size: 15px; color: var(--text-color); }
        .review-mc-answer p strong, .review-matching-answer p strong, .review-ordering-answer p strong { color: var(--text-heading); margin-right: 5px; display: inline-block; min-width: 110px; }
        .review-mc-answer .correct-answer-text, .review-matching-answer .correct-answer-text, .review-ordering-answer .correct-answer-text { color: var(--correct-text); font-weight: 500; }
        .review-mc-answer .user-answer-text.incorrect { color: var(--incorrect-text); text-decoration: line-through; }
        .review-mc-answer .user-answer-text.correct { color: var(--correct-text); font-weight: 500; }
        .review-matching-grid { display: flex; flex-wrap: wrap; gap: 15px; margin-top: 10px; }
        .review-matching-column { flex: 1; min-width: 200px;}
        .review-matching-column div { padding: 5px 8px; margin-bottom: 5px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--container-bg); }
        .review-matched-pair-correct { background-color: var(--correct-bg) !important; border-color: var(--correct-border) !important; color: var(--correct-text) !important; }
        .review-matched-pair-incorrect { background-color: var(--incorrect-bg) !important; border-color: var(--incorrect-border) !important; }
        /* NOTE: The following rules for '.review-matched-pair-incorrect span' are standard CSS and were correct */
        body.dark-theme .review-matched-pair-incorrect span { color: var(--incorrect-text) !important; opacity: 0.7; }
        body.dark-theme .review-matched-pair-incorrect span + span { color: var(--correct-text) !important; opacity: 1; }
        body:not(.dark-theme) .review-matched-pair-incorrect span { color: var(--incorrect-text) !important; opacity: 0.7; }
        body:not(.dark-theme) .review-matched-pair-incorrect span + span { color: var(--correct-text) !important; opacity: 1; }
        .review-ordering-list { margin-top: 10px; display: flex; flex-direction: column; gap: 5px; }
        .review-ordering-list-item { display: flex; align-items: center; padding: 6px 10px; border-radius: 4px; border: 1px solid var(--border-color); background-color: var(--container-bg); }
        .review-order-number { font-weight: 600; margin-right: 8px; }
        .review-order-correct { color: var(--correct-text); }
        .review-order-incorrect { color: var(--incorrect-text); text-decoration: line-through; opacity: 0.8; }

        /* --- Modal Base Styles (Shared by Settings and Stats) --- */
        #settings-modal, #stats-modal { position: fixed; inset: 0; background-color: var(--modal-overlay-bg); display: flex; justify-content: center; align-items: center; z-index: 100; opacity: 0; pointer-events: none; transition: opacity 0.3s ease; }
        #settings-modal.visible, #stats-modal.visible { opacity: 1; pointer-events: auto; }
        .modal-content { background-color: var(--modal-bg); padding: 25px 30px; border-radius: 12px; box-shadow: 0 5px 20px var(--shadow-color); width: 90%; max-width: 450px; border: 1px solid var(--border-color); position: relative; transform: scale(0.95); transition: transform 0.3s ease; max-height: 90vh; display: flex; flex-direction: column; }
        #stats-modal .modal-content { max-width: 700px; } /* Wider modal for stats table */
        #settings-modal.visible .modal-content, #stats-modal.visible .modal-content { transform: scale(1); }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid var(--border-color); flex-shrink: 0; }
        .modal-title { font-size: 20px; font-weight: 600; color: var(--text-heading); }
        .modal-close-btn { font-size: 24px; background: none; border: none; color: var(--text-muted); cursor: pointer; line-height: 1; padding: 0 5px; }
        .modal-body { margin-bottom: 20px; overflow-y: auto; flex-grow: 1;} /* Allow body to scroll */
        .modal-section { margin-bottom: 20px; }
        .modal-section h4 { font-size: 16px; font-weight: 500; color: var(--text-heading); margin: 0 0 12px 0; }
        .modal-footer { margin-top: auto; padding-top: 15px; border-top: 1px solid var(--border-color); text-align: right; flex-shrink: 0; }

        /* Settings Modal Specific */
        .theme-options label { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; cursor: pointer; font-size: 15px; color: var(--text-color); }
        .theme-options input[type="radio"] { accent-color: var(--accent-color); }

        /* Stats Modal Table */
        #stats-table { width: 100%; border-collapse: collapse; margin-top: 15px; table-layout: fixed; }
        #stats-table th, #stats-table td { border: 1px solid var(--table-border); padding: 8px 10px; text-align: center; font-size: 14px; white-space: nowrap; }
        #stats-table th { background-color: var(--table-header-bg); font-weight: 600; color: var(--text-heading); }
        #stats-table td:first-child, #stats-table th:first-child { text-align: left; font-weight: 500; padding-right: 10px; } /* Align first column text */
        #stats-table td { color: var(--text-muted); }
        #stats-table tr:last-child td { border-bottom: none; }
        #stats-table th:last-child, #stats-table td:last-child { font-weight: bold; color: var(--text-color); } /* Highlight Total column */


        /* --- END OF styles.css --- */
    </style>
</head>
<body>

    <!-- Welcome View -->
    <!-- TODO: Replace [Name], [Names] placeholders below -->
    <div id="welcome-view">
        <h1>Welcome!</h1> <p>Practice makes perfect.</p>
        <div class="info-section"><strong>By:</strong><span>[Name]</span></div>
        <div class="info-section"><strong>Testers:</strong><span>[Names]</span></div>
        <div class="info-section"><strong>Mentions:</strong><span>[Names]</span></div>
        <button class="btn submit-btn get-started-btn">Start</button>
    </div>

    <!-- Main Container -->
    <div class="container initially-hidden">
        <div class="header">
            <h1>Question Bank</h1>
            <div class="header-buttons"> <!-- Added wrapper for buttons -->
                <button id="stats-btn" title="View Statistics">📊</button> <!-- Changed icon -->
                <button id="settings-btn" title="Settings">⚙️</button>
            </div>
        </div>
        <div class="nav-section">
             <div class="subjects">
                <button class="nav-btn" data-subject="اللغة العربية"><span>📚</span> اللغة العربية</button>
                <button class="nav-btn active" data-subject="english"><span>🌎</span> English</button>
                <button class="nav-btn" data-subject="التاريخ"><span>📜</span> التاريخ</button>
                <button class="nav-btn" data-subject="دين"><span>📖</span> دين</button>
            </div>
            <div class="secondary-nav">
                 <div class="semester-toggle">
                     <button class="semester-btn active" data-semester="first" id="semester-btn-first">First Semester</button>
                     <button class="semester-btn" data-semester="second" id="semester-btn-second">Second Semester</button>
                 </div>
             </div>
        </div>
        <div id="content"></div>
        <div id="quiz-view" class="hidden">
            <div id="quiz-header">
                <h2 id="quiz-title">Quiz</h2>
                <button class="btn back-to-topics-btn" id="back-to-topics-btn" onclick="showTopicList()"><span>⬅️</span> <span class="btn-text">Back to Topics</span></button>
            </div>
            <div id="quiz-container"></div>
            <div id="feedback-container" class="feedback-container hidden"></div> <!-- Updated class name -->
            <div id="quiz-buttons-container" class="quiz-buttons"></div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="hidden">
        <div class="modal-content">
            <div class="modal-header"> <h3 class="modal-title">Settings</h3> <button class="modal-close-btn" id="settings-modal-close-header" onclick="toggleSettingsModal(false)">×</button> </div>
            <div class="modal-body">
                <div class="modal-section"> <h4>Theme</h4> <div class="theme-options"> <label><input type="radio" name="theme" value="light"> Light ☀️</label> <label><input type="radio" name="theme" value="dark"> Dark 🌙</label> </div> </div>
                <div class="modal-section"> <h4>Data</h4> <button class="btn reset-data-btn" id="reset-data-button">Reset Data</button> <p style="font-size:12px;color:var(--text-muted);margin-top:8px;">Clears theme, welcome status, and stats.</p> </div>
            </div>
            <div class="modal-footer"> <button class="btn close-btn" id="settings-modal-close-footer" onclick="toggleSettingsModal(false)">Close</button> </div>
        </div>
    </div>

    <!-- Statistics Modal -->
    <div id="stats-modal" class="hidden">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="stats-modal-title">Overall Statistics</h3>
                <button class="modal-close-btn" id="stats-modal-close-header" onclick="toggleStatsModal(false)">×</button>
            </div>
            <div class="modal-body">
                <table id="stats-table">
                    <thead>
                        <tr>
                            <th>المادة</th>
                            <th>التاريخ</th>
                            <th>دين</th>
                            <th>اللغة العربية</th>
                            <th>English</th>
                            <th>المجموع</th>
                        </tr>
                    </thead>
                    <tbody id="stats-table-body">
                        <!-- Rows will be populated by JS -->
                    </tbody>
                </table>
                 <p style="font-size:12px;color:var(--text-muted);margin-top:15px;">Stats based on best performance per lesson.</p>
            </div>
            <div class="modal-footer">
                <button class="btn close-btn" id="stats-modal-close-footer" onclick="toggleStatsModal(false)">Close</button>
            </div>
        </div>
    </div>


    <script>
        // --- START OF topics.js ---
        // Data includes explanation fields now
        const topicsData = {
    "english": {
        "first": {
            "title": "First Semester",
            "units": [
                {
                    "title": "Unit 1",
                    "lessons": [
                        {
                            "title": "Vocabulary & Grammar Basics",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "Device in 'curtain of night fell'?",
                                    "options": ["Simile", "Metaphor", "Alliteration", "Hyperbole","test"],
                                    "answer": "Metaphor",
                                    "explanation": "A metaphor directly compares two unlike things without using 'like' or 'as'. 'Curtain of night' compares the falling night to a curtain closing."
                                },
                                {
                                    "type": "multiple_choice",
                                    "question": "'Ambiguous' means:",
                                    "options": ["Clear", "Uncertain", "Definite", "Determined"],
                                    "answer": "Uncertain"
                                    // No explanation provided for this one - it's optional
                                },
                                {
                                    "type": "ordering",
                                    "question": "Order alphabetically:",
                                    "items": ["Banana", "Apple", "Cherry", "Date", "Fig"],
                                    "answer": ["Apple", "Banana", "Cherry", "Date", "Fig"],
                                    "explanation": "Items are sorted based on the standard English alphabet order (A, B, C, D, F)."
                                },
                                {
                                    "type": "matching",
                                    "question": "Match country and capital:",
                                    "prompts": ["France", "Japan", "Egypt", "Brazil", "Canada"],
                                    "matches": ["Cairo", "Tokyo", "Paris", "Brasília", "Ottawa"],
                                    "answer": {
                                        "0": 2,
                                        "1": 1,
                                        "2": 0,
                                        "3": 3,
                                        "4": 4
                                    },
                                    "explanation": "Paris is the capital of France, Tokyo of Japan, Cairo of Egypt, Brasília of Brazil, and Ottawa of Canada."
                                },
                                {
                                    "type": "ordering",
                                    "question": "Order tea steps:",
                                    "items": ["Add tea bag", "Boil water", "Pour water"],
                                    "answer": ["Boil water", "Add tea bag", "Pour water"],
                                    "explanation": "You must boil the water first. Then, add the tea bag to the cup before pouring the hot water over it."
                                },
                                {
                                    "type": "multiple_choice",
                                    "question": "'Concise' means:", // Changed question for variety
                                    "options": ["Lengthy", "Wordy", "Brief", "Complicated"],
                                    "answer": "Brief",
                                    "explanation": "'Concise' means expressing much in few words; it's the opposite of lengthy or wordy."
                                },
                                ]
                        },
                        {
                            "title": "Past & Present Tenses & Question Tags",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "Correct tense: 'She ___ to school every day.'", // Added frequency
                                    "options": ["go", "goes", "going", "went"],
                                    "answer": "goes",
                                     "explanation": "For third-person singular subjects (like 'She') in the present simple tense (used for routines like 'every day'), we add '-es' to verbs ending in 'o'."
                                },
                                {
                                    "type": "multiple_choice",
                                    "question": "Correct tag: 'You are studying, ___?'", // Corrected question
                                    "options": ["aren't you", "don't you", "isn't you", "won't you"],
                                    "answer": "aren't you",
                                    "explanation": "Question tags use the opposite form of the auxiliary verb ('are' becomes 'aren't') and the same subject pronoun ('you')."
                                }
                            ]
                        }
                    ]
                },
                {
                    "title": "Unit 2",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Future Forms", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 3",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Habits & Clauses", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 4",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Narration & Inversion", "questions": [] }
                    ]
                }
            ]
        },
        "second": {
            "title": "Second Semester",
            "units": [
                {
                    "title": "Unit 1",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Modal & Related & Articles", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 2",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Reported Speech & Reporting Verbs", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 3",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "The Passive", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 4",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Conditionals & Modals", "questions": [] }
                    ]
                },
                {
                    "title": "Unit 5",
                    "lessons": [
                        { "title": "Reading and Vocabulary", "questions": [] },
                        { "title": "Modals & Clauses", "questions": [] }
                    ]
                }
            ]
        }
    },

    "اللغة العربية": {
        "first": {
            "title": "الفصل الأول",
            "units": [
                {
                    "title": "الوحدة الأولى",
                    "lessons": [
                        {
                            "title": "من القيم الإنسانية في القرآن",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "ما معنى كلمة 'البر' في قوله تعالى 'لن تنالوا البر حتى تنفقوا مما تحبون'؟",
                                    "options": ["الخير", "الصدق", "العدل", "الوفاء"],
                                    "answer": "الخير",
                                    "explanation": "البر هو اسم جامع لكل أنواع الخير والطاعة."
                                },
                                {
                                    "type": "ordering",
                                    "question": "رتب مراحل الوحي حسب نزولها:",
                                    "items": ["اقرأ باسم ربك", "المدثر", "الفاتحة"],
                                    "answer": ["اقرأ باسم ربك", "المدثر", "الفاتحة"],
                                    "explanation": "أول ما نزل من القرآن هو صدر سورة العلق ('اقرأ')، ثم تلاها فترة انقطاع، ثم نزلت سورة المدثر، وتعتبر الفاتحة أول سورة كاملة نزلت."
                                },
                                {
                                    "type": "matching",
                                    "question": "صل بين المصطلح وتعريفه:",
                                    "prompts": ["التجويد", "التفسير", "الناسخ والمنسوخ"],
                                    "matches": ["علم كيفية النطق الصحيح للقرآن", "علم بيان معاني القرآن", "علم الآيات التي تغير حكمها"],
                                    "answer": { "0": 0, "1": 1, "2": 2 },
                                    "explanation": "التجويد يتعلق بالنطق، التفسير ببيان المعنى، والناسخ والمنسوخ بتغير الأحكام."
                                 }
                                }
                            ]
                        },
                        {
                            "title": "اسلوب الطلب وجوابه المجزوم والتشبيه المفرد",
                            "questions": []
                        }
                    ]
                },
                {
                    "title": "الوحدة الثانية",
                    "lessons": [
                        { "title": "عمانيات", "questions": [] },
                        { "title": "صور الفاعل والتشبيه التمثيلي", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثالثة",
                    "lessons": [
                        { "title": "الزهايمر-الخرف المبكر", "questions": [] },
                        { "title": "صور المبتدأ والخبر والجملة الخبرية والإنشائية", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الرابعة",
                    "lessons": [
                        { "title": "الإعلام ومشروع النهوض باللغة العربية", "questions": [] },
                        { "title": "المفعول معه والأمر", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الخامسة",
                    "lessons": [
                        { "title": "التعليم التقني بوابة المستقبل في عالم متغير", "questions": [] },
                        { "title": "انواع ما والإستفهام", "questions": [] }
                    ]
                }
            ]
        },
        "second": {
            "title": "الفصل الثاني",
            "units": [
                {
                    "title": "الوحدة الأولى",
                    "lessons": [
                        { "title": "في فتح القدس", "questions": [] },
                        { "title": "معاني حروف الجر والتشخيص", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثانية",
                    "lessons": [
                        { "title": "قصة-حفنة تمر", "questions": [] },
                        { "title": "اسم الفاعل واسم المفعول والطباق والمقابلة", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثالثة",
                    "lessons": [
                        { "title": "شاعرات من بلدي", "questions": [] },
                        { "title": "اسم الزمان واسم المكان وجمع التكسير (القلة والكثرة)", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الرابعة",
                    "lessons": [
                        { "title": "من مقامات بديع الزمان الهمذاني", "questions": [] },
                        { "title": "مصدر المرة ومصدر الهيئة والبحر المتدارك", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الخامسة",
                    "lessons": [
                        { "title": "الذكاء الاصطناعي-عالم جديد", "questions": [] },
                        { "title": "اسم الآلة", "questions": [] }
                    ]
                }
            ]
        }
    },

    "التاريخ": {
        "first": {
            "title": "الفصل الأول",
            "units": [
                {
                    "title": "الأردن في العصور القديمة",
                    "lessons": [
                        {
                            "title": "الأردن في العصور الحجرية",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "أي موقع أثري في الأردن يعود للعصر الحجري الحديث ويشتهر بالتماثيل العينية؟",
                                    "options": ["عين غزال", "جاوا", "بيضا", "أم قيس"],
                                    "answer": "عين غزال"
                                },
                                {
                                    "type": "ordering",
                                    "question": "رتب العصور الحجرية من الأقدم للأحدث:",
                                    "items": ["الحجري الحديث", "الحجري القديم", "الحجري الوسيط"],
                                    "answer": ["الحجري القديم", "الحجري الوسيط", "الحجري الحديث"]
                                }
                            ]
                        },
                        { "title": "الأردن في العصر الحديدي", "questions": [] },
                        { "title": "مملكة الأنباط", "questions": [] },
                        { "title": "مظاهر الحضارة اليونانية في الأردن", "questions": [] },
                        { "title": "مظاهر الحضارة الرومانية-البيزنطية في الأردن", "questions": [] }
                    ]
                },
                {
                    "title": "الأردن في صدر الإسلام",
                    "lessons": [
                        { "title": "الأردن في صدر الإسلام", "questions": [] },
                        { "title": "الأردن في العصر الأموي", "questions": [] },
                        { "title": "الأردن في العصر العباسي", "questions": [] },
                        { "title": "الأردن خلال حملات الفرنجة", "questions": [] },
                        { "title": "الأردن في العصر الأيوبي", "questions": [] },
                        { "title": "الأردن في العصر المملوكي", "questions": [] }
                    ]
                },
                {
                    "title": "الأردن في العصر الحديث",
                    "lessons": [
                        { "title": "الأوضاع السياسية والإدارية في الأردن في العهد العثماني", "questions": [] },
                        { "title": "الأوضاع الإجتماعية والإقتصادية الأردن في العهد العثماني", "questions": [] },
                        { "title": "الثورة العربية الكبرى", "questions": [] },
                        { "title": "الأردن في عهد المملكة العربية السورية والحكومات المحلية", "questions": [] }
                    ]
                }
            ]
        },
        "second": {
            "title": "الفصل الثاني",
            "units": [
                {
                    "title": "الحياة السياسية في الأردن",
                    "lessons": [
                        { "title": "تأسيس الإمارة الأردنية", "questions": [] },
                        { "title": "استقلال المملكة الأردنية الهاشمية", "questions": [] },
                        { "title": "تطور الحياة السياسية في الأردن بين عامي (1948-1957)", "questions": [] },
                        { "title": "تطور الحياة السياسية في الأردن بين عامي (1958-1999)", "questions": [] },
                        { "title": "الحياة السياسية في الأردن منذ 1999", "questions": [] },
                        { "title": "الأردن والعلاقات العربية والدولية", "questions": [] },
                        { "title": "القوات المسلحة الأردنية - الجيش العربي", "questions": [] },
                        { "title": "الأجهزة الأمنية الأردنية", "questions": [] }
                    ]
                },
                {
                    "title": "الحياة الاقتصادية في الأردن",
                    "lessons": [
                        { "title": "الحياة الاقتصادية في الأردن بين عامي (1921-1950)", "questions": [] },
                        { "title": "الحياة الاقتصادية في الأردن بين عامي (1951-1967)", "questions": [] },
                        { "title": "الحياة الاقتصادية في الأردن بين عامي (1968-1999)", "questions": [] },
                        { "title": "الحياة الاقتصادية في الأردن منذ عام 1999", "questions": [] }
                    ]
                },
                {
                    "title": "الحياة الاجتماعية في الأردن",
                    "lessons": [
                        { "title": "الحياة الاجتماعية في الأردن بين عامي (1921-1950)", "questions": [] },
                        { "title": "الحياة الاجتماعية في الأردن بين عامي (1951-1999)", "questions": [] },
                        { "title": "الحياة الاجتماعية في الأردن منذ عام 1999", "questions": [] }
                    ]
                },
                {
                    "title": "التعليم والثقافة في الأردن",
                    "lessons": [
                        { "title": "التعليم العام في الأردن بين عامي (1921-1950)", "questions": [] },
                        { "title": "التعليم العام في الأردن بين عامي (1951-1987)", "questions": [] },
                        { "title": "التعليم العام في الأردن بين عامي (1988-2024)", "questions": [] },
                        { "title": "التعليم العالي والبحث العلمي في الأردن منذ عام 1951", "questions": [] },
                        { "title": "الحياة الثقافية في الأردن في عهد الإمارة", "questions": [] },
                        { "title": "الحياة الثقافية في الأردن منذ عام 1946", "questions": [] }
                    ]
                },
                {
                    "title": "الأردن والقضية الفلسطينية",
                    "lessons": [
                        { "title": "موقف الأردن من القضية الفلسطينية بين عامي (1916-1951)", "questions": [] },
                        { "title": "موقف الأردن من القضية الفلسطينية منذ عام 1951", "questions": [] },
                        { "title": "الوصاية والإعمار الهاشمي للمقدسات الدينية في القدس", "questions": [] }
                    ]
                }
            ]
        }
    },

    "دين": {
        "first": {
            "title": "الفصل الأول",
            "units": [
                {
                    "title": "الوحدة الأولى",
                    "lessons": [
                        {
                            "title": "سورة آل عمران (102-105)",
                            "questions": [
                                {
                                    "type": "multiple_choice",
                                    "question": "ما هو الأمر الذي نهى الله عنه في قوله تعالى 'ولا تفرقوا'؟",
                                    "options": ["التعصب", "الخلاف المذموم المؤدي للعداوة", "الاختلاف الفقهي", "ترك الصلاة"],
                                    "answer": "الخلاف المذموم المؤدي للعداوة"
                                },
                                {
                                    "type": "multiple_choice",
                                    "question": "ما المقصود بـ 'حبل الله' في الآية؟",
                                    "options": ["القرآن والسنة", "الصلاة", "الزكاة", "الحج"],
                                    "answer": "القرآن والسنة"
                                }
                            ]
                        },
                        { "title": "حديث اتقاء الشبهات", "questions": [] },
                        { "title": "من صور الضلال", "questions": [] },
                        { "title": "كرامة الإنسان في الشريعة", "questions": [] },
                        { "title": "الزواج-مشروعيته ومقدماته", "questions": [] },
                        { "title": "الجهاد في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثانية",
                    "lessons": [
                        { "title": "جهود علماء المسلمين في خدمة القرآن", "questions": [] },
                        { "title": "العزيمة والرخصة", "questions": [] },
                        { "title": "معركة مؤتة (8 هجري)", "questions": [] },
                        { "title": "المحرمات من النساء", "questions": [] },
                        { "title": "التعايش الإنساني", "questions": [] },
                        { "title": "الحقوق الإجتماعية للمرأة في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثالثة",
                    "lessons": [
                        { "title": "سورة آل عمران (169-174)", "questions": [] },
                        { "title": "حديث - رضا الله تعالى", "questions": [] },
                        { "title": "فتح مكة (8 هجري)", "questions": [] },
                        { "title": "من خصائص الشريعة - الإيجابية", "questions": [] },
                        { "title": "شروط صحة عقد الزواج", "questions": [] },
                        { "title": "الحقوق المالية للمرأة في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الرابعة",
                    "lessons": [
                        { "title": "سورة الروم (21-24)", "questions": [] },
                        { "title": "مكانة السنة النبوية في التشريع", "questions": [] },
                        { "title": "مراعاة الأعراف في الشريعة", "questions": [] },
                        { "title": "حقوق الزوجين", "questions": [] },
                        { "title": "تنظيم النسل وتحديده", "questions": [] },
                        { "title": "الأمن الغذائي في الإسلام", "questions": [] },
                        { "title": "الإسلام والوحدة الوطنية", "questions": [] }
                    ]
                }
            ]
        },
        "second": {
            "title": "الفصل الثاني",
            "units": [
                {
                    "title": "الوحدة الأولى",
                    "lessons": [
                        { "title": "سورة البقرة (284-286)", "questions": [] },
                        { "title": "دلائل وجود الله تعالى", "questions": [] },
                        { "title": "إعجاز القرآن الكريم", "questions": [] },
                        { "title": "الأمر بالمعروف والنهي عن المنكر", "questions": [] },
                        { "title": "اليوم الآخر - احداثه وآثار الإيمان به", "questions": [] },
                        { "title": "الإجتهاد في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثانية",
                    "lessons": [
                        { "title": "سورة الأعراف (31-34)", "questions": [] },
                        { "title": "مراعاة المصالح في الشريعة", "questions": [] },
                        { "title": "جهود علماء المسلمين في الحفاظ على السنة النبوية", "questions": [] },
                        { "title": "حديث - منهج الإسلام في الحياة", "questions": [] },
                        { "title": "رسائل النبي الى الملوك والزعماء في عصره", "questions": [] },
                        { "title": "يوم تبوك (9 هجري)", "questions": [] },
                        { "title": "الحقوق السياسية للمرأة في الإسلام", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الثالثة",
                    "lessons": [
                        { "title": "سورة الفرقان (63-77)", "questions": [] },
                        { "title": "الطلاق", "questions": [] },
                        { "title": "العدة", "questions": [] },
                        { "title": "الوصية في الشريعة", "questions": [] },
                        { "title": "الميراث في الشريعة", "questions": [] },
                        { "title": "من خصائص الشريعة - الوسطية", "questions": [] },
                        { "title": "مجالات الوقف ودورها في التنمية", "questions": [] }
                    ]
                },
                {
                    "title": "الوحدة الرابعة",
                    "lessons": [
                        { "title": "حديث - مفهوم الإفلاس بين الدنيا والآخرة", "questions": [] },
                        { "title": "مقاصد الشريعة", "questions": [] },
                        { "title": "منهج الإسلام في مكافحة الجريمة", "questions": [] },
                        { "title": "من وصايا النبي في حجة الوداع", "questions": [] },
                        { "title": "المسؤولية المجتمعية في الإسلام", "questions": [] },
                        { "title": "حقوق الإنسان بين الإسلام والإعلان العالمي لحقوق الإنسان", "questions": [] }
                    ]
                }
            ]
        }
    }
};

        function generateSemesterContent(subject, semester) {
            const sanitizedSubject = subject.replace(/\s+/g, '-'); const id = `${sanitizedSubject}-${semester}`;
            if (!topicsData[subject]?.[semester]) return `<div id="${id}" class="semester-content"><div class="section"><p>Unavailable.</p></div></div>`;
            const semesterData = topicsData[subject][semester]; let html = `<div id="${id}" class="semester-content">`;
            html += `<div class="semester-title-container"><div class="unit-title">${semesterData.title}</div></div>`;
            if (!semesterData.units?.length) { html += `<div class="section"><p>No units.</p></div>`; }
            else { semesterData.units.forEach(unit => { if (unit?.title) { html += `<div class="section"><div class="section-title">${unit.title}</div>`; if (unit.lessons?.length) { unit.lessons.forEach(lesson => { if (lesson?.title) { const qCount = lesson.questions?.length || 0; const countText = qCount === 1 ? "1 Q" : `${qCount} Qs`; html += `<div class="section-content" data-subject="${subject}" data-semester="${semester}" data-unit="${unit.title}" data-lesson="${lesson.title}"> <span class="lesson-title-text">${lesson.title}</span> <span class="lesson-stats-display"></span> <span class="lesson-q-count">(${countText})</span> </div>`; } }); } else { html += `<p style="font-size:14px;color:var(--text-muted);">(No lessons)</p>`; } html += `</div>`; } }); } html += `</div>`; return html;
        }
        function generateAllContent() { let c = ''; const d = document.getElementById('content'); if (!d) return; Object.keys(topicsData).forEach(s => { Object.keys(topicsData[s]).forEach(sem => { c += generateSemesterContent(s, sem); }); }); d.innerHTML = c; }
        generateAllContent();
        // --- END OF topics.js ---
    </script>

    <script>
        // --- START OF questions.js ---
        let quizState = { currentQuestionIndex: 0, correctAnswers: 0, totalQuestions: 0, startTime: null, endTime: null, selectedAnswers: [], questions: [], originalQuestions: [], subject: '', unit: '', lesson: '', semester: '', matchingState: { selectedPromptElement: null, selectedMatchElement: null, userPairs: {} } };
        let allLessonStats = {};
        let subjectTotalQuestions = {}; // <--- Global variable to store pre-calculated totals

        const LS_THEME_KEY = 'quizAppTheme';
        const LS_VISITED_KEY = 'quizAppVisited';
        const LS_STATS_KEY = 'quizAppLessonStats';
        const RTL_SUBJECTS = ["اللغة العربية", "دين", "التاريخ"]; // <-- Define RTL subjects
        // Define the exact order of subjects for the stats table
        const STATS_SUBJECT_ORDER = ["التاريخ", "دين", "اللغة العربية", "english"];

        // --- UI String Translations (Expanded) ---
        const uiStrings = {
            en: {
                firstSemester: "First Semester", secondSemester: "Second Semester",
                backToTopics: "Back to Topics", submit: "Submit", next: "Next Question",
                viewResults: "View Results",
                resultsSubjectLabel: "Subject:", resultsSemesterLabel: "Semester:",
                resultsUnitLabel: "Unit:", resultsLessonLabel: "Lesson:", resultsCorrectLabel: "Correct:",
                resultsTimeLabel: "Time:", resultsYourAnswerLabel: "Your Answer:", resultsCorrectAnswerLabel: "Correct Answer:",
                redoQuiz: "Redo Quiz", reviewAnswers: "Review Answers",
                backToResults: "Back to Results",
                settingsTitle: "Settings", settingsThemeHeading: "Theme",
                settingsLightMode: "Light Mode", settingsDarkMode: "Dark Mode", settingsDataHeading: "Data Management",
                settingsResetBtn: "Reset Saved Data", settingsResetInfo: "Clears theme, welcome status, and all saved lesson statistics.",
                settingsCloseBtn: "Close",
                statsTitle: "Overall Statistics", statsAnswersLabel: "Answers", statsTimeLabel: "Time", statsTotalLabel: "Total",
                matchingInstruction: "Click an item on the left, then its corresponding item on the right. Click a matched item again to deselect the pair.",
                orderingInstruction: "Select the correct order number ({num}) for each item.",
                matchingItemsHeader: "Items", matchingMatchesHeader: "Matches",
                defaultErrorMessage: "Could not load questions for this lesson.",
                leaveQuizConfirm: "Leave the current quiz? Progress will be lost.",
                resetDataConfirm: "Reset all saved data (theme, stats)? This cannot be undone.",
                resetDataAlert: "Data has been reset. Reloading the page.",
                reviewStatusCorrect: "✓ Correct", reviewStatusIncorrect: "✗ Incorrect",
                reviewStatusPartial: "~ Partial ({correct}/{total})", reviewStatusUnanswered: "Unanswered",
                quizResultExcellent: "Excellent! 🎉", quizResultGreat: "Great Job! 👍",
                quizResultGood: "Good Effort! 💪", quizResultPractice: "Keep Practicing! 📚",
                quizResultNoQuestions: "No questions in this quiz.",
                quizTitlePrefix: "Quiz", reviewTitlePrefix: "Review",
                selectAnswerPrompt: "Please select an answer.", // Added for MC check
                correctFeedback: "Correct! ✓", // Added for default correct
                incorrectFeedback: "Incorrect.", // Added for default incorrect
                correctAnswerIs: "Correct answer:", // Added for default incorrect feedback
                matchingNoMatchNeeded: "No matching needed.", // Added for matching check
                matchingAllCorrect: "Correct! ✓ All matched.", // Added for matching check
                matchingPartialCorrect: "Partial correct: {correct}/{total}.", // Added for matching check
                matchingNoneCorrect: "Incorrect: 0/{total} matched.", // Added for matching check
                orderingInvalidData: "Error: Invalid ordering setup.", // Added for ordering check
                orderingSelectionError: "Error processing selections.", // Added for ordering check
                orderingSelectAll: "Please select an order for all items.", // Added for ordering check
                orderingUseEachNumOncePlural: "numbers 1-{n}", // Added for ordering check
                orderingUseEachNumOnceSingular: "number 1", // Added for ordering check
                orderingDuplicateUse: "Please use each order {nums} exactly once.", // Added for ordering check
                orderingSequenceError: "Error processing sequence.", // Added for ordering check
            },
            ar: {
                 firstSemester: "الفصل الأول", secondSemester: "الفصل الثاني",
                 backToTopics: "العودة للمواضيع", submit: "إرسال", next: "السؤال التالي",
                 viewResults: "عرض النتائج",
                 resultsSubjectLabel: "المادة:", resultsSemesterLabel: "الفصل:",
                 resultsUnitLabel: "الوحدة:", resultsLessonLabel: "الدرس:", resultsCorrectLabel: "الصحيحة:",
                 resultsTimeLabel: "الوقت:", resultsYourAnswerLabel: "إجابتك:", resultsCorrectAnswerLabel: "الإجابة الصحيحة:",
                 redoQuiz: "إعادة الاختبار", reviewAnswers: "مراجعة الإجابات",
                 backToResults: "العودة للنتائج",
                 settingsTitle: "الإعدادات", settingsThemeHeading: "السمة",
                 settingsLightMode: "وضع فاتح", settingsDarkMode: "وضع داكن", settingsDataHeading: "إدارة البيانات",
                 settingsResetBtn: "إعادة تعيين البيانات", settingsResetInfo: "يمسح تفضيلات السمة وحالة شاشة الترحيب وجميع إحصائيات الدروس المحفوظة.",
                 settingsCloseBtn: "إغلاق",
                 statsTitle: "الإحصائيات العامة", statsAnswersLabel: "الاجابات", statsTimeLabel: "الوقت", statsTotalLabel: "المجموع",
                 matchingInstruction: "انقر على عنصر في القائمة الأولى، ثم على العنصر المقابل له في القائمة الثانية. انقر على زوج متطابق مرة أخرى لإلغاء التحديد.",
                 orderingInstruction: "حدد رقم الترتيب الصحيح ({num}) لكل عنصر.",
                 matchingItemsHeader: "العناصر", matchingMatchesHeader: "المطابقات",
                 defaultErrorMessage: "تعذر تحميل أسئلة هذا الدرس.",
                 leaveQuizConfirm: "هل تريد مغادرة الاختبار الحالي؟ سيتم فقدان التقدم.",
                 resetDataConfirm: "هل أنت متأكد من إعادة تعيين جميع البيانات المحفوظة (السمة، الإحصائيات)؟ لا يمكن التراجع عن هذا الإجراء.",
                 resetDataAlert: "تمت إعادة تعيين البيانات. جارٍ إعادة تحميل الصفحة.",
                 reviewStatusCorrect: "✓ صحيح", reviewStatusIncorrect: "✗ خطأ",
                 reviewStatusPartial: "~ جزئي ({correct}/{total})", reviewStatusUnanswered: "لم تتم الإجابة",
                 quizResultExcellent: "ممتاز! 🎉", quizResultGreat: "عمل رائع! 👍",
                 quizResultGood: "مجهود جيد! 💪", quizResultPractice: "استمر في الممارسة! 📚",
                 quizResultNoQuestions: "لا توجد أسئلة في هذا الاختبار.",
                 quizTitlePrefix: "اختبار", reviewTitlePrefix: "مراجعة",
                 selectAnswerPrompt: "الرجاء اختيار إجابة.", // Added AR
                 correctFeedback: "صحيح! ✓", // Added AR
                 incorrectFeedback: "خطأ.", // Added AR
                 correctAnswerIs: "الإجابة الصحيحة:", // Added AR
                 matchingNoMatchNeeded: "لا يوجد تطابق مطلوب.", // Added AR
                 matchingAllCorrect: "صحيح! ✓ تمت مطابقة الكل.", // Added AR
                 matchingPartialCorrect: "صحيح جزئياً: {correct}/{total}.", // Added AR
                 matchingNoneCorrect: "خطأ: 0/{total} مطابقة.", // Added AR
                 orderingInvalidData: "خطأ: إعداد الترتيب غير صالح.", // Added AR
                 orderingSelectionError: "خطأ في معالجة الاختيارات.", // Added AR
                 orderingSelectAll: "الرجاء تحديد ترتيب لجميع العناصر.", // Added AR
                 orderingUseEachNumOncePlural: "الأرقام من 1 إلى {n}", // Added AR
                 orderingUseEachNumOnceSingular: "الرقم 1", // Added AR
                 orderingDuplicateUse: "الرجاء استخدام كل ترتيب {nums} مرة واحدة بالضبط.", // Added AR
                 orderingSequenceError: "خطأ في معالجة التسلسل.", // Added AR
            }
        };

        let contentElement, quizViewElement, quizTitleElement, quizContainerElement, feedbackContainerElement, quizButtonsContainerElement, matchingSvgElement, navSectionElement, welcomeViewElement, mainContainerElement;
        let settingsModalElement, settingsButtonElement, statsModalElement, statsButtonElement;
        let matchingArrowObserver = null; let resizeTimeout = null;

        // --- Utility Functions ---
        function shuffleArray(array) { const newArray=[...array]; for(let i=newArray.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[newArray[i],newArray[j]]=[newArray[j],newArray[i]];} return newArray; }
        function debounce(func,wait){ let timeout; return function(...args){const later=()=>{clearTimeout(timeout);func(...args);};clearTimeout(timeout);timeout=setTimeout(later,wait);}; }
        function formatTime(s){if(s===null||s<=0||isNaN(s))return'0s';const m=Math.floor(s/60),c=Math.floor(s%60);return m>0?`${m}m ${c}s`:`${c}s`;}
        function getLessonStorageKey(s,sem,u,l){const c=str=>(str || '').replace(/\s+/g,'_').replace(/-/g,'__');return`${c(s)}-${c(sem)}-${c(u)}-${c(l)}`;}
        function getCurrentLang() { return document.documentElement.lang || 'en'; }
        function getStrings() { return uiStrings[getCurrentLang()] || uiStrings.en; }

        // --- Lesson Stats Management ---
        function loadLessonStats(){try{const s=localStorage.getItem(LS_STATS_KEY);allLessonStats=s?JSON.parse(s):{};}catch(e){console.error("Failed to load lesson stats:",e);allLessonStats={};}}
        function saveLessonStats(subj,sem,unit,lesson,score,total,time){const k=getLessonStorageKey(subj,sem,unit,lesson);const e=allLessonStats[k];let u=!1;if(!e||!e.totalQuestions){allLessonStats[k]={bestScore:score,totalQuestions:total,bestTime:time};u=!0;}else{if(score>e.bestScore){e.bestScore=score;e.bestTime=time;e.totalQuestions=total;u=!0;}else if(score===e.bestScore&&time<e.bestTime){e.bestTime=time;u=!0;}if(total!==e.totalQuestions){e.totalQuestions=total;u=!0;}}if(u)try{localStorage.setItem(LS_STATS_KEY,JSON.stringify(allLessonStats));}catch(e){console.error("Failed to save lesson stats:",e);}}
        function updateLessonBoxDisplays(){const a=document.querySelector('.semester-content.active');if(!a)return;const l=a.querySelectorAll('.section-content');l.forEach(b=>{const s=b.dataset.subject,sem=b.dataset.semester,u=b.dataset.unit,les=b.dataset.lesson,dS=b.querySelector('.lesson-stats-display'),qC=b.querySelector('.lesson-q-count');if(!s||!sem||!u||!les||!dS)return;const k=getLessonStorageKey(s,sem,u,les),st=allLessonStats[k];b.classList.remove('lesson-complete-perfect','lesson-complete-imperfect');dS.textContent='';if(qC)qC.style.display='';if(st&&st.totalQuestions>0){const sT=`🏆 ${st.bestScore}/${st.totalQuestions}`,tT=`⏱️ ${formatTime(st.bestTime)}`;dS.textContent=`${sT} | ${tT}`;if(st.bestScore===st.totalQuestions)b.classList.add('lesson-complete-perfect');else b.classList.add('lesson-complete-imperfect');}else{if(qC)qC.style.display='';}});}

        // --- UI Language Update ---
        function updateUiLanguage(lang = 'en') {
            const strings = uiStrings[lang] || uiStrings.en; // Use provided lang or fallback
            const isRTL = lang === 'ar';
            document.documentElement.lang = lang; // Set page language

            // Helper to set text, handling potential inner spans for buttons
            const setText = (elementId, textKey, options = {}) => {
                const element = document.getElementById(elementId);
                let text = strings[textKey] || uiStrings.en[textKey] || ''; // Fallback text
                 if (options.num !== undefined) { text = text.replace('{num}', `1-${options.num}`); } // Placeholder

                if (element) {
                    const textSpan = element.querySelector('.btn-text');
                    if (textSpan) {
                        textSpan.textContent = text;
                    } else {
                        element.textContent = text; // Set text directly if no span
                    }
                } else if (options.selector) { // Allow using selectors for non-ID elements
                     const elements = document.querySelectorAll(options.selector);
                     elements.forEach(el => { el.textContent = text; });
                }
            };
            // Helper for results details labels
             const setDetailLabel = (key, textKey) => {
                 const text = strings[textKey] || uiStrings.en[textKey] || '';
                 const pElement = document.querySelector(`.results-details p[data-detail-key="${key}"] strong`);
                 if (pElement) pElement.textContent = text;
             };

            // --- Update Static & Dynamic Elements ---
            setText('semester-btn-first', 'firstSemester');
            setText('semester-btn-second', 'secondSemester');
            setText('settings-modal-close-footer', 'settingsCloseBtn'); // Use ID if unique - Footer button
            setText('reset-data-button', 'settingsResetBtn');
            setText('stats-modal-close-footer', 'settingsCloseBtn'); // Use ID for stats modal close
             setText('stats-modal-title', 'statsTitle'); // Update Stats Modal Title

            // Buttons that might exist depending on view
            setText('back-to-topics-btn', 'backToTopics'); // In quiz header
            setText('submit-btn', 'submit'); // In quiz footer (initially)

            // Smart update for Next/View Results button
            const nextBtn = document.getElementById('next-btn');
            if (nextBtn) {
                 const nextBtnTextKey = (quizState.currentQuestionIndex === quizState.totalQuestions - 1 && quizState.totalQuestions > 0) ? 'viewResults' : 'next';
                 setText('next-btn', nextBtnTextKey);
            }

            // Buttons in results/review/error views (use IDs if unique)
            setText('redo-btn', 'redoQuiz');
            setText('review-btn', 'reviewAnswers');
            setText('back-to-topics-btn-results', 'backToTopics'); // Results view back button
            setText('back-btn', 'backToResults'); // Review view back button
            setText('back-to-topics-btn-review', 'backToTopics'); // Review view back button
            setText('back-to-topics-btn-error', 'backToTopics'); // Error view back button


            // Quiz Title (handle different states)
            if (quizTitleElement) {
                if (quizContainerElement && quizContainerElement.querySelector('.results-container')) {
                    quizTitleElement.textContent = strings.viewResults || 'Quiz Results';
                } else if (quizContainerElement && quizContainerElement.querySelector('.review-container')) {
                    quizTitleElement.textContent = `${strings.reviewTitlePrefix || 'Review'}: ${quizState.lesson || ''}`;
                } else if (quizContainerElement && quizContainerElement.querySelector('.error-display')) {
                     quizTitleElement.textContent = strings.defaultErrorMessage.includes('load') ? strings.defaultErrorMessage : 'Error';
                } else if (quizState.lesson) {
                    quizTitleElement.textContent = `${strings.quizTitlePrefix || 'Quiz'}: ${quizState.lesson}`;
                } else {
                    // Default or placeholder if no state matches
                     quizTitleElement.textContent = strings.quizTitlePrefix || 'Quiz';
                }
            }

            // Modal text
            const settingsM = document.getElementById('settings-modal');
            if(settingsM) {
                setText('settings-modal .modal-title', 'settingsTitle', { selector: '#settings-modal .modal-title' });
                setText('settings-modal .modal-section:nth-of-type(1) h4', 'settingsThemeHeading', { selector: '#settings-modal .modal-section:nth-of-type(1) h4' });
                const lightLabel = settingsM.querySelector('input[value="light"]')?.parentElement; if(lightLabel) lightLabel.childNodes[lightLabel.childNodes.length-1].nodeValue = ` ${strings.settingsLightMode || 'Light Mode'} ☀️`;
                const darkLabel = settingsM.querySelector('input[value="dark"]')?.parentElement; if(darkLabel) darkLabel.childNodes[darkLabel.childNodes.length-1].nodeValue = ` ${strings.settingsDarkMode || 'Dark Mode'} 🌙`;
                setText('settings-modal .modal-section:nth-of-type(2) h4', 'settingsDataHeading', { selector: '#settings-modal .modal-section:nth-of-type(2) h4' });
                setText('settings-modal .modal-section:nth-of-type(2) p', 'settingsResetInfo', { selector: '#settings-modal .modal-section:nth-of-type(2) p' });
            }

             // Results Details Labels (Ensure these are called *after* results view is rendered if dynamic)
             setDetailLabel('subject', 'resultsSubjectLabel');
             setDetailLabel('semester', 'resultsSemesterLabel');
             setDetailLabel('unit', 'resultsUnitLabel');
             setDetailLabel('lesson', 'resultsLessonLabel');
             setDetailLabel('correct', 'resultsCorrectLabel');
             setDetailLabel('time', 'resultsTimeLabel');

             // Instructions (if quiz view is active and elements exist)
             const matchingInstructions = document.querySelector('.matching-instructions');
             if(matchingInstructions) matchingInstructions.textContent = strings.matchingInstruction || '';

             const orderingInstructions = document.querySelector('.ordering-instructions');
             if(orderingInstructions) {
                 const numItems = quizState?.questions[quizState.currentQuestionIndex]?.items?.length || 0;
                 const instructionText = strings.orderingInstruction || '';
                 orderingInstructions.textContent = numItems > 0 ? instructionText.replace('{num}', `1-${numItems}`) : instructionText.replace('{num}', 'N/A');
             }

             // Matching Headers (if quiz view is active and elements exist)
             const itemsHeader = document.querySelector('#prompts-column h4');
             if (itemsHeader) itemsHeader.textContent = strings.matchingItemsHeader || 'Items';
             const matchesHeader = document.querySelector('#matches-column h4');
             if (matchesHeader) matchesHeader.textContent = strings.matchingMatchesHeader || 'Matches';

             // Result Header Message (Ensure this is called *after* results view is rendered)
             const resultHeader = document.querySelector('.results-header');
             if (resultHeader) {
                 const score = quizState.totalQuestions > 0 ? (quizState.correctAnswers / quizState.totalQuestions) * 100 : 0;
                 let msgKey = 'quizResultPractice';
                 if (quizState.totalQuestions === 0) msgKey = 'quizResultNoQuestions';
                 else if (score >= 90) msgKey = 'quizResultExcellent';
                 else if (score >= 70) msgKey = 'quizResultGreat';
                 else if (score >= 50) msgKey = 'quizResultGood';
                 resultHeader.textContent = strings[msgKey] || '';
             }
        }


        // --- RTL and Theme Management ---
        function setRtlLayout(enable) {
            if (mainContainerElement) {
                const lang = enable ? 'ar' : 'en';
                mainContainerElement.classList.toggle('rtl-layout', enable);
                if (document.documentElement.lang !== lang) {
                    updateUiLanguage(lang);
                }
            }
        }
        function applyTheme(t){document.body.classList.toggle('dark-theme',t==='dark');const r=settingsModalElement?.querySelectorAll('input[name="theme"]');if(r)r.forEach(rd=>rd.checked=rd.value===t);}
        function handleThemeChange(e){const n=e.target.value;applyTheme(n);localStorage.setItem(LS_THEME_KEY,n);}
        function loadAndApplyTheme(){const s=localStorage.getItem(LS_THEME_KEY);const c=s||'dark';applyTheme(c);if(!s)localStorage.setItem(LS_THEME_KEY,'dark');}
        function toggleSettingsModal(s){if(!settingsModalElement)return;if(s){const c=localStorage.getItem(LS_THEME_KEY)||'dark';const r=settingsModalElement.querySelectorAll('input[name="theme"]');r.forEach(rd=>rd.checked=rd.value===c);settingsModalElement.classList.remove('hidden');setTimeout(()=>settingsModalElement.classList.add('visible'),10);}else{settingsModalElement.classList.remove('visible');setTimeout(()=>settingsModalElement.classList.add('hidden'),300);}}

        // --- Function to calculate total questions per subject from topicsData ---
        function calculateSubjectTotals() {
            // console.log("Calculating total questions per subject..."); // Debug log
            subjectTotalQuestions = {}; // Reset before calculating
            for (const subject in topicsData) {
                if (topicsData.hasOwnProperty(subject)) {
                    let totalQs = 0;
                    // Iterate through both semesters for the subject
                    for (const semester in topicsData[subject]) {
                        if (topicsData[subject].hasOwnProperty(semester) && topicsData[subject][semester].units) {
                            topicsData[subject][semester].units.forEach(unit => {
                                if (unit.lessons) {
                                    unit.lessons.forEach(lesson => {
                                        // Safely add the count of questions, default to 0 if undefined/null
                                        totalQs += lesson.questions?.length || 0;
                                    });
                                }
                            });
                        }
                    }
                    subjectTotalQuestions[subject] = totalQs; // Store the total for this subject
                }
            }
            // console.log("Pre-calculated Subject Totals:", subjectTotalQuestions); // Debug log
        }

        // --- Stats Modal ---
        function toggleStatsModal(show) {
            if (!statsModalElement) return;
            if (show) {
                populateStatsModal(); // Calculate and fill data
                statsModalElement.classList.remove('hidden');
                setTimeout(() => statsModalElement.classList.add('visible'), 10);
            } else {
                statsModalElement.classList.remove('visible');
                setTimeout(() => statsModalElement.classList.add('hidden'), 300);
            }
        }

        // --- MODIFIED: calculateOverallStats ---
        function calculateOverallStats() {
            const subjectStats = {};
            // Initialize stats object using the pre-calculated totals
            STATS_SUBJECT_ORDER.forEach(subj => {
                subjectStats[subj] = {
                    answered: 0, // Start answered count at 0
                    total: subjectTotalQuestions[subj] || 0, // Get total from pre-calculated map
                    time: 0
                };
            });

            let overallAnswered = 0;
            let overallTime = 0;
            // overallTotal will be calculated at the end by summing subject totals

            // Iterate through COMPLETED lesson stats to get ANSWERED counts and TIME
            for (const key in allLessonStats) {
                if (allLessonStats.hasOwnProperty(key)) {
                    const parts = key.split('-');
                    // Decode subject name properly
                    const subject = parts[0].replace(/__/g, '-').replace(/_/g, ' ');
                    const stat = allLessonStats[key];

                    // Ensure the subject exists in our stats object and the completed lesson wasn't empty
                    if (subjectStats[subject] !== undefined && stat.totalQuestions > 0) {
                        // Add the best score achieved for completed lessons
                        subjectStats[subject].answered += stat.bestScore;
                        // Add the best time for completed lessons
                        subjectStats[subject].time += stat.bestTime;

                        // Accumulate overall answered and time
                        overallAnswered += stat.bestScore;
                        overallTime += stat.bestTime;

                        // !!! DO NOT update subjectStats[subject].total here !!!
                        // It's already set from subjectTotalQuestions
                    } else if (subjectStats[subject] === undefined) {
                        // This case should ideally not happen if STATS_SUBJECT_ORDER is correct
                        console.warn(`Subject "${subject}" found in stats but not in STATS_SUBJECT_ORDER or subjectTotalQuestions.`);
                    }
                }
            }

            // Calculate the overall total by summing the pre-calculated totals for the displayed subjects
            let overallTotal = 0;
            STATS_SUBJECT_ORDER.forEach(subj => {
                overallTotal += subjectTotalQuestions[subj] || 0;
            });

            // console.log("Calculated Stats:", { subjectStats, overallAnswered, overallTotal, overallTime }); // Debug log
            return { subjectStats, overallAnswered, overallTotal, overallTime };
        }


        // --- populateStatsModal (Uses the output of calculateOverallStats) ---
        function populateStatsModal() {
            const { subjectStats, overallAnswered, overallTotal, overallTime } = calculateOverallStats();
            const tbody = document.getElementById('stats-table-body');
            const strings = getStrings();
            if (!tbody) return;

            tbody.innerHTML = ''; // Clear previous rows

            // Answers Row
            const answersRow = tbody.insertRow();
            const answersLabelCell = answersRow.insertCell();
            answersLabelCell.textContent = strings.statsAnswersLabel || 'Answers';

            STATS_SUBJECT_ORDER.forEach(subj => {
                const cell = answersRow.insertCell();
                const stats = subjectStats[subj];
                // Display answered/total using the pre-calculated total
                cell.textContent = stats ? `${stats.answered}/${stats.total}` : '0/0';
            });
            const totalAnswersCell = answersRow.insertCell();
            totalAnswersCell.textContent = `${overallAnswered}/${overallTotal}`; // Use calculated overall total

            // Time Row
            const timeRow = tbody.insertRow();
            const timeLabelCell = timeRow.insertCell();
            timeLabelCell.textContent = strings.statsTimeLabel || 'Time';

            STATS_SUBJECT_ORDER.forEach(subj => {
                const cell = timeRow.insertCell();
                const stats = subjectStats[subj];
                cell.textContent = stats ? formatTime(stats.time) : '0s';
            });
            const totalTimeCell = timeRow.insertCell();
            totalTimeCell.textContent = formatTime(overallTime);
        }


        function resetSavedData(){
            const strings = getStrings();
            const confirmMsg = strings.resetDataConfirm || 'Confirm Reset?';
            if (confirm(confirmMsg)) {
                localStorage.removeItem(LS_THEME_KEY);
                localStorage.removeItem(LS_VISITED_KEY);
                localStorage.removeItem(LS_STATS_KEY);
                allLessonStats = {};
                alert(strings.resetDataAlert || 'Data reset. Reloading.');
                location.reload();
            }
        }

        // --- Welcome Screen Logic ---
        function handleWelcome(){if(!welcomeViewElement||!mainContainerElement)return;const h=localStorage.getItem(LS_VISITED_KEY);if(h){welcomeViewElement.classList.add('hidden');mainContainerElement.classList.remove('initially-hidden');setTimeout(()=>{mainContainerElement.style.opacity=1;},50);}else{welcomeViewElement.classList.remove('hidden');mainContainerElement.classList.add('initially-hidden');mainContainerElement.style.opacity=0;const b=welcomeViewElement.querySelector('.get-started-btn');if(b)b.addEventListener('click',()=>{localStorage.setItem(LS_VISITED_KEY,'true');welcomeViewElement.classList.add('hidden');mainContainerElement.classList.remove('initially-hidden');setTimeout(()=>{mainContainerElement.style.opacity=1;},50);},{once:true});}}

        // --- DOM Ready Listener ---
        document.addEventListener('DOMContentLoaded',()=>{
            // Get DOM elements
            welcomeViewElement=document.getElementById('welcome-view');
            mainContainerElement=document.querySelector('.container');
            contentElement=document.getElementById('content');
            quizViewElement=document.getElementById('quiz-view');
            quizTitleElement=document.getElementById('quiz-title');
            quizContainerElement=document.getElementById('quiz-container');
            feedbackContainerElement=document.getElementById('feedback-container');
            quizButtonsContainerElement=document.getElementById('quiz-buttons-container');
            navSectionElement=document.querySelector('.nav-section');
            settingsButtonElement=document.getElementById('settings-btn');
            settingsModalElement=document.getElementById('settings-modal');
            statsButtonElement = document.getElementById('stats-btn');
            statsModalElement = document.getElementById('stats-modal');

            // Initial Setup
            calculateSubjectTotals(); // Calculate totals from topicsData
            loadAndApplyTheme();
            loadLessonStats();
            handleWelcome();
            const initialSubjectBtn = document.querySelector('.nav-btn.active');
            const initialSubject = initialSubjectBtn?.dataset.subject || 'english';
            const initialLang = RTL_SUBJECTS.includes(initialSubject) ? 'ar' : 'en';
            setRtlLayout(RTL_SUBJECTS.includes(initialSubject)); // Set initial RTL based on active button
            updateUiLanguage(initialLang); // Set initial language based on active button

            // Event Listeners
            if(settingsButtonElement) settingsButtonElement.addEventListener('click',()=>toggleSettingsModal(true));
            if(statsButtonElement) statsButtonElement.addEventListener('click', () => toggleStatsModal(true));
            if(settingsModalElement){
                const themeRadios=settingsModalElement.querySelectorAll('input[name="theme"]');
                themeRadios.forEach(rd=>rd.addEventListener('change',handleThemeChange));
                const resetBtn=document.getElementById('reset-data-button');
                if(resetBtn) resetBtn.addEventListener('click',resetSavedData);
                settingsModalElement.addEventListener('click',(e)=>{if(e.target===settingsModalElement)toggleSettingsModal(false);});
                 // Close button inside modal
                const closeHeaderBtn = document.getElementById('settings-modal-close-header');
                if (closeHeaderBtn) closeHeaderBtn.addEventListener('click', () => toggleSettingsModal(false));
            }
            if (statsModalElement) {
                statsModalElement.addEventListener('click', (e) => { if (e.target === statsModalElement) toggleStatsModal(false); });
                 // Close button inside modal
                const closeHeaderBtn = document.getElementById('stats-modal-close-header');
                if (closeHeaderBtn) closeHeaderBtn.addEventListener('click', () => toggleStatsModal(false));
            }


            // Subject/Semester Buttons
            document.querySelectorAll('.nav-btn[data-subject]').forEach(b=>{b.addEventListener('click',function(){
                const strings = getStrings();
                const confirmMsg = strings.leaveQuizConfirm || "Leave quiz?";
                if (!quizViewElement.classList.contains('hidden') && !confirm(confirmMsg)) return;
                showTopicList(); // Go back to topic view
                document.querySelectorAll('.nav-btn[data-subject]').forEach(btn=>btn.classList.remove('active'));
                this.classList.add('active');
                updateContent(); // Update content based on new selection
            });});
            document.querySelectorAll('.semester-btn').forEach(b=>{b.addEventListener('click',function(){
                const strings = getStrings();
                const confirmMsg = strings.leaveQuizConfirm || "Leave quiz?";
                if (!quizViewElement.classList.contains('hidden') && !confirm(confirmMsg)) return;
                showTopicList(); // Go back to topic view
                document.querySelectorAll('.semester-btn').forEach(btn=>btn.classList.remove('active'));
                this.classList.add('active');
                updateContent(); // Update content based on new selection
            });});

            // Lesson Click
            if(contentElement) contentElement.addEventListener('click',(e)=>{const l=e.target.closest('.section-content');if(l){
                const strings = getStrings();
                const confirmMsg = strings.leaveQuizConfirm || "Leave quiz?";
                // Only confirm if actually in quiz view
                if (!quizViewElement.classList.contains('hidden') && !confirm(confirmMsg)) return;
                // If confirmed or not in quiz view, proceed
                if (!quizViewElement.classList.contains('hidden')) {
                    // No need to call showTopicList here, handleSectionClick will manage views
                     // *** Explicitly call cleanup when starting a new quiz from quiz view ***
                     cleanupQuizView();
                }
                const s=l.dataset.subject,sem=l.dataset.semester,u=l.dataset.unit,les=l.dataset.lesson;
                handleSectionClick(s,sem,u,les);
            }});

            window.addEventListener('resize',debounce(updateAllArrowPositions,250));

            // Only update content if the user has passed the welcome screen
            if(localStorage.getItem(LS_VISITED_KEY)) {
                 updateContent();
            }
        });

        // --- View Management ---
        function showTopicList(){
            if(!mainContainerElement || !contentElement || !quizViewElement || !navSectionElement) return;
            const currentSubject = document.querySelector('.nav-btn.active')?.dataset.subject || 'english';
            const isRTL = RTL_SUBJECTS.includes(currentSubject);

            mainContainerElement.classList.remove('hidden');
            contentElement.classList.remove('hidden');
            quizViewElement.classList.add('hidden');
            navSectionElement.classList.remove('hidden');

            setRtlLayout(isRTL); // Ensure layout matches current subject
            updateContent(); // Refresh content and stats display

            // Cleanup quiz-specific things
            cleanupQuizView(); // <-- Use the cleanup function

            // Optional: Scroll to top of container
            mainContainerElement.scrollIntoView({behavior:'smooth',block:'start'});
        }
        function showQuizView(){
             if(mainContainerElement&&contentElement&&quizViewElement&&navSectionElement){
                 mainContainerElement.classList.remove('hidden');
                 contentElement.classList.add('hidden');
                 quizViewElement.classList.remove('hidden');
                 navSectionElement.classList.add('hidden');
                 // Scroll to the top of the quiz view
                 quizViewElement.scrollIntoView({behavior:'smooth',block:'start'});
            }
        }
        // *** Added Cleanup Function ***
        function cleanupQuizView() {
            // Disconnect MutationObserver if it exists
            if (matchingArrowObserver) {
                matchingArrowObserver.disconnect();
                matchingArrowObserver = null;
            }
            // Remove SVG element if it exists
            if (matchingSvgElement && matchingSvgElement.parentNode) {
                matchingSvgElement.remove();
                matchingSvgElement = null;
            }
            // Destroy SortableJS instances (if using Drag-and-Drop alternative)
            quizState.matchingState?.sortableInstances?.forEach(instance => instance.destroy());

            // Reset quiz state (important parts)
            quizState = {
                currentQuestionIndex: 0, correctAnswers: 0, totalQuestions: 0,
                startTime: null, endTime: null, selectedAnswers: [], questions: [],
                originalQuestions: [], subject: '', unit: '', lesson: '', semester: '',
                matchingState: { selectedPromptElement: null, selectedMatchElement: null, userPairs: {}, sortableInstances: [] } // Reset matching state including sortable instances
            };
             // Clear dynamic containers just in case
             if (quizContainerElement) quizContainerElement.innerHTML = '';
             if (feedbackContainerElement) {
                 feedbackContainerElement.innerHTML = '';
                 feedbackContainerElement.classList.add('hidden');
             }
             if (quizButtonsContainerElement) quizButtonsContainerElement.innerHTML = '';
        }

        // --- Core Functions ---
        function updateContent() {
            const aSBtn = document.querySelector('.nav-btn[data-subject].active');
            const aSemBtn = document.querySelector('.semester-btn.active');
            if (!aSBtn || !aSemBtn || !contentElement) return;
            const actSub = aSBtn.dataset.subject;
            const actSem = aSemBtn.dataset.semester;
            const sanSub = actSub.replace(/\s+/g, '-');
            const isRTL = RTL_SUBJECTS.includes(actSub);
            const lang = isRTL ? 'ar' : 'en';

            setRtlLayout(isRTL); // Set RTL layout first
            if(document.documentElement.lang !== lang) {
                updateUiLanguage(lang); // Update language if needed based on subject
            }

            // Hide all semester contents first
            contentElement.querySelectorAll('.semester-content').forEach(c => c.classList.remove('active'));

            // Find and show the active semester content
            const cId = `${sanSub}-${actSem}`;
            const sCE = contentElement.querySelector(`#${cId}`);
            if (sCE) {
                sCE.classList.add('active');
                updateLessonBoxDisplays(); // Update the stats display for the visible lessons
            } else {
                console.warn(`Semester content ID "#${cId}" not found.`);
                // Optionally display a message in the content area
                contentElement.innerHTML = `<p>Content for ${actSub} - ${actSem} not found.</p>`;
            }
        }

        function handleSectionClick(subj,sem,unit,lesson){
            if(!subj||!sem||!unit||!lesson) {
                const strings = getStrings();
                alert(strings.defaultErrorMessage || "Error identifying topic.");
                return;
            }
            try{
                const oQ=getQuestions(subj,sem,unit,lesson);
                showQuizView(); // Show the quiz view area *before* trying to populate it
                if(oQ?.length) {
                    startQuiz(subj,sem,unit,lesson,oQ);
                } else {
                    showError(subj,unit,lesson); // Show specific error if no questions found
                }
            } catch(e){
                console.error("Error handling section click:",e);
                showError(subj,unit,lesson, (getStrings().defaultErrorMessage || "Error loading quiz.")); // Show generic error
            }
        }

        function startQuiz(subj,sem,unit,lesson,oQ){
            const sQ = shuffleArray(oQ);
            // Reset state (partially done by cleanupQuizView, but ensure full reset here)
             quizState = {
                currentQuestionIndex: 0, correctAnswers: 0, totalQuestions: sQ.length,
                startTime: new Date(), endTime: null, selectedAnswers: new Array(sQ.length).fill(null),
                questions: sQ, originalQuestions: oQ,
                subject: subj, unit: unit, lesson: lesson, semester: sem,
                matchingState: { selectedPromptElement: null, selectedMatchElement: null, userPairs: {}, sortableInstances: [] } // Reset matching state
            };

            const isRTL = RTL_SUBJECTS.includes(subj);
            setRtlLayout(isRTL); // Set layout for the quiz

            if(quizTitleElement) {
                const strings = getStrings();
                quizTitleElement.textContent = `${strings.quizTitlePrefix || 'Quiz'}: ${lesson}`;
            }

            displayQuestion(); // Display the first question
        }

        function displayQuestion(){
            if(!quizContainerElement||!feedbackContainerElement||!quizButtonsContainerElement)return;

            const cQ=quizState.questions[quizState.currentQuestionIndex];
            if(!cQ){ // Should not happen if totalQuestions > 0, but good safeguard
                console.warn("DisplayQuestion called but no current question found. Index:", quizState.currentQuestionIndex);
                displayResults(); // Go to results if out of bounds
                return;
            }

            // Clear previous content & cleanup specific things
            quizContainerElement.innerHTML='';
            feedbackContainerElement.innerHTML='';
            feedbackContainerElement.classList.add('hidden');
            quizButtonsContainerElement.innerHTML='';
             // Cleanup potential leftovers from previous question types
            if(matchingArrowObserver){matchingArrowObserver.disconnect();matchingArrowObserver=null;}
            if(matchingSvgElement&&matchingSvgElement.parentNode){matchingSvgElement.remove();matchingSvgElement=null;}
             quizState.matchingState?.sortableInstances?.forEach(instance => instance.destroy());
             quizState.matchingState = { selectedPromptElement: null, selectedMatchElement: null, userPairs: {}, sortableInstances: [] }; // Ensure clean state


            // Create question wrapper
            const qW=document.createElement('div');
            qW.className='question-display-wrapper';

            // Progress text
            const pT=document.createElement('div');
            pT.className='question-progress';
            pT.textContent=`Q ${quizState.currentQuestionIndex+1}/${quizState.totalQuestions}`;
            qW.appendChild(pT);

            // Question text
            const qT=document.createElement('p');
            qT.className='question-text';
            qT.innerHTML=`<strong>Q:</strong> ${cQ.question||'?'}`; // Use innerHTML for potential formatting
            qW.appendChild(qT);

            // Wrapper for the specific question type content
            const tW=document.createElement('div');
            tW.className='question-type-wrapper';

            // Render based on type
            try{
                switch(cQ.type){
                    case "matching":
                        renderMatching(cQ,tW);
                        // Use requestAnimationFrame to ensure elements are in DOM before observing/drawing
                        requestAnimationFrame(setupArrowObserver);
                        break;
                    case "ordering":
                        renderOrdering(cQ,tW);
                        break;
                    case "multiple_choice":
                    default: // Default to multiple choice
                        renderMultipleChoice(cQ,tW);
                        break;
                }
            } catch(e) {
                console.error("Render error for question type", cQ.type, e);
                tW.innerHTML=`<p style="color:red;">Error displaying this question.</p>`;
            }

            qW.appendChild(tW);
            quizContainerElement.appendChild(qW);

            // Add buttons
            const sB=document.createElement('button');
            sB.className='btn submit-btn';
            sB.id='submit-btn';
            sB.innerHTML=`<span class="btn-text"></span>`; // Text set by updateUiLanguage
            sB.onclick=checkAnswer;

            const nB=document.createElement('button');
            nB.className='btn next-btn hidden'; // Start hidden
            nB.id='next-btn';
            nB.innerHTML=`<span class="btn-text"></span>`; // Text set by updateUiLanguage
            nB.onclick=nextQuestion;

            quizButtonsContainerElement.append(sB,nB);

            // Disable submit button initially for types requiring selection
            sB.disabled = true;
            if(cQ.type === 'multiple_choice' || cQ.type === 'ordering' || cQ.type === 'matching') {
                 // Keep disabled, will be enabled by interaction handlers
            } else {
                 sB.disabled = false; // Enable for unknown/simple types
            }

            updateUiLanguage(getCurrentLang()); // Ensure button text is set correctly
        }

        // --- Rendering Functions ---
        function renderMultipleChoice(q,c){
            if(!q.options?.length) { c.textContent='Error: No options provided.'; return; }
            const oD=document.createElement('div');
            oD.className='options-container';
            q.options.forEach((o,i)=>{
                const id=`option-${i}`;
                const l=document.createElement('label');
                l.className='option-label';
                l.htmlFor=id;
                const inp=document.createElement('input');
                inp.type='radio';
                inp.name='question-option';
                inp.value=i;
                inp.id=id;
                inp.className='option-input';
                inp.addEventListener('change',()=>{
                    const s=document.getElementById('submit-btn');
                    if(s) s.disabled=false; // Enable submit on selection
                });
                const t=document.createElement('span');
                t.className='option-text';
                t.textContent=o;
                l.append(inp,t);
                oD.appendChild(l);
            });
            c.appendChild(oD);
        }

        function renderMatching(question, container) {
             if (!question.prompts?.length || !question.matches?.length || question.prompts.length !== question.matches.length) { container.textContent = 'Error: Matching data is invalid.'; return; }

             const strings = getStrings();
             quizState.matchingState.userPairs = {}; // Reset pairs for the new question
             quizState.matchingState.selectedPromptElement = null;
             quizState.matchingState.selectedMatchElement = null;

             // Instructions
             const instr = document.createElement('p');
             instr.className = 'matching-instructions';
             instr.textContent = strings.matchingInstruction || '';
             container.appendChild(instr);

             // Outer container for relative positioning of SVG
             const outer = document.createElement('div');
             outer.style.position = 'relative'; // Crucial for SVG positioning
             outer.id = `matching-outer-${quizState.currentQuestionIndex}`;
             container.appendChild(outer);

             // SVG for arrows
             matchingSvgElement = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
             matchingSvgElement.id = 'matching-arrow-svg';
             matchingSvgElement.innerHTML = '<defs><marker id="arrowhead" markerWidth="10" markerHeight="7" refX="0" refY="3.5" orient="auto"><polygon points="0 0, 10 3.5, 0 7" fill="var(--accent-color)"/></marker></defs>';
             outer.appendChild(matchingSvgElement); // Add SVG first (z-index matters less if added first)

             // Container for the two columns
             const matchCont = document.createElement('div');
             matchCont.className = 'matching-container';
             matchCont.id = 'matching-cols'; // ID for observer

             // Prompt Column
             const promCol = document.createElement('div');
             promCol.className = 'matching-column';
             promCol.id = 'prompts-column';
             promCol.innerHTML = `<h4>${strings.matchingItemsHeader || 'Items'}</h4>`;

             // Match Column
             const matCol = document.createElement('div');
             matCol.className = 'matching-column';
             matCol.id = 'matches-column';
             matCol.innerHTML = `<h4>${strings.matchingMatchesHeader || 'Matches'}</h4>`;

             // Shuffle matches for display
             const shuffledMatches = question.matches
                .map((text, originalIndex) => ({ text, originalIndex })) // Keep track of original index
                .sort(() => 0.5 - Math.random());

             // Create prompt items
             question.prompts.forEach((promptText, promptIndex) => {
                 const item = document.createElement('div');
                 item.className = 'matching-item prompt-item';
                 item.textContent = promptText;
                 item.dataset.index = promptIndex; // Store original index
                 item.id = `prompt-${promptIndex}`;
                 item.onclick = handleMatchingClick;
                 // item.onkeydown = handleMatchingKeydown; // Add if keyboard nav is needed
                 promCol.appendChild(item);
             });

             // Create shuffled match items
             shuffledMatches.forEach(matchObject => {
                 const item = document.createElement('div');
                 item.className = 'matching-item match-item';
                 item.textContent = matchObject.text;
                 item.dataset.index = matchObject.originalIndex; // Store original index
                 item.id = `match-${matchObject.originalIndex}`;
                 item.onclick = handleMatchingClick;
                 // item.onkeydown = handleMatchingKeydown; // Add if keyboard nav is needed
                 matCol.appendChild(item);
             });

             matchCont.append(promCol, matCol);
             outer.appendChild(matchCont); // Add columns container to the outer div
        }

        function renderOrdering(q,c){
            if(!q.items?.length) { c.textContent='Error: Ordering data invalid.'; return; }
            const strings = getStrings();
            const numItems = q.items.length;

            // Instructions
            const instr = document.createElement('p');
            instr.className='ordering-instructions';
            const instructionText = strings.orderingInstruction || '';
            instr.textContent = numItems > 0 ? instructionText.replace('{num}', `1-${numItems}`) : instructionText.replace('{num}', 'N/A');
            c.appendChild(instr);

            // Container for items
            const oC=document.createElement('div');
            oC.className='ordering-container';
            oC.id='ordering-list'; // ID for targeting selects

            // Function to check if all selects have a value
            const checkCompletion=()=>{
                const allSelects=oC.querySelectorAll('.ordering-select');
                const allSelected = Array.from(allSelects).every(select => select.value !== "");
                const submitBtn=document.getElementById('submit-btn');
                if(submitBtn) submitBtn.disabled=!allSelected;
            };

            // Shuffle items for display
            const shuffledItems = q.items
                .map((text, originalIndex) => ({ text, originalIndex }))
                .sort(() => 0.5 - Math.random());

            // Create items with selects
            shuffledItems.forEach(({text: itemText, originalIndex}) => {
                const d=document.createElement('div');
                d.className='ordering-item';
                d.dataset.originalIndex=originalIndex; // Store original index if needed

                const s=document.createElement('select');
                s.className='ordering-select';
                s.dataset.itemIndex=originalIndex; // Link select to the original item index

                // Default placeholder option
                const defaultOpt=document.createElement('option');
                defaultOpt.value="";
                defaultOpt.textContent="-";
                defaultOpt.selected=true;
                defaultOpt.disabled=true; // Make placeholder unselectable after choosing
                s.appendChild(defaultOpt);

                // Populate order numbers
                for(let j=1;j<=numItems;j++){
                    const opt=document.createElement('option');
                    opt.value=j;
                    opt.textContent=j;
                    s.appendChild(opt);
                }

                s.addEventListener('change', checkCompletion); // Check completion on change

                const sp=document.createElement('span');
                sp.className='ordering-text';
                sp.textContent=itemText;

                d.append(s,sp);
                oC.appendChild(d);
            });
            c.appendChild(oC);
        }

        // --- Interaction Handlers ---
        function handleMatchingClick(event) {
            const clickedItem = event.target.closest('.matching-item');
            if (!clickedItem || clickedItem.disabled) return; // Ignore if disabled (after submit)

            const isRTL = mainContainerElement.classList.contains('rtl-layout');
            const isPrompt = clickedItem.classList.contains('prompt-item');
            const isMatch = clickedItem.classList.contains('match-item');
            const isAlreadyMatched = clickedItem.classList.contains('matched');
            const clickedIndex = clickedItem.dataset.index;

            // --- Case 1: Clicked a Matched Item (to unmatch) ---
            if (isAlreadyMatched) {
                let promptIndexToClear = -1;
                let matchIndexToClear = -1;

                // Find the corresponding prompt/match index
                if (isPrompt) {
                    promptIndexToClear = clickedIndex;
                    matchIndexToClear = quizState.matchingState.userPairs[promptIndexToClear];
                } else { // Clicked on a matched 'match' item
                    matchIndexToClear = clickedIndex;
                    // Find the prompt index that maps to this match index
                    promptIndexToClear = Object.keys(quizState.matchingState.userPairs).find(
                        pIdx => quizState.matchingState.userPairs[pIdx] == matchIndexToClear // Use == for potential string/number comparison
                    );
                }

                // If we found the pair, unmatch them
                if (promptIndexToClear != -1 && matchIndexToClear !== undefined && promptIndexToClear !== undefined) {
                    const promptElement = document.getElementById(`prompt-${promptIndexToClear}`);
                    const matchElement = document.getElementById(`match-${matchIndexToClear}`);

                    if (promptElement) promptElement.classList.remove('matched', 'selected');
                    if (matchElement) matchElement.classList.remove('matched', 'selected');

                    delete quizState.matchingState.userPairs[promptIndexToClear]; // Remove from state
                    removeArrow(promptIndexToClear); // Remove visual arrow

                    // Reset selection state if needed
                    quizState.matchingState.selectedPromptElement = null;
                    quizState.matchingState.selectedMatchElement = null;

                     // Disable submit button as the match is now incomplete
                    const submitBtn = document.getElementById('submit-btn');
                    if (submitBtn) submitBtn.disabled = true;
                }
                return; // Stop further processing for unmatching
            }

            // --- Case 2: Clicked an Unmatched Item ---
            const currentSelectedPrompt = quizState.matchingState.selectedPromptElement;
            const currentSelectedMatch = quizState.matchingState.selectedMatchElement;

            if (isRTL) { // Right-to-Left Logic (Match -> Prompt)
                 if (isMatch) { // Clicked a match item
                     if (clickedItem === currentSelectedMatch) { // Clicked same match again: Deselect
                         clickedItem.classList.remove('selected');
                         quizState.matchingState.selectedMatchElement = null;
                     } else { // Clicked a new match item
                         if (currentSelectedMatch) currentSelectedMatch.classList.remove('selected'); // Deselect old
                         clickedItem.classList.add('selected'); // Select new
                         quizState.matchingState.selectedMatchElement = clickedItem;
                         // If a prompt was also selected, deselect it (only one side active)
                         if (currentSelectedPrompt) {
                             currentSelectedPrompt.classList.remove('selected');
                             quizState.matchingState.selectedPromptElement = null;
                         }
                     }
                 } else if (isPrompt && currentSelectedMatch) { // Clicked a prompt WHILE a match is selected: Create Pair
                     const matchIndex = currentSelectedMatch.dataset.index;
                     const promptIndex = clickedIndex;

                     quizState.matchingState.userPairs[promptIndex] = parseInt(matchIndex, 10); // Store pair

                     // Update visual state
                     currentSelectedMatch.classList.remove('selected');
                     currentSelectedMatch.classList.add('matched');
                     clickedItem.classList.add('matched'); // Mark prompt as matched too
                     drawArrow(clickedItem, currentSelectedMatch, promptIndex); // Draw arrow (prompt -> match)

                     // Reset selection
                     quizState.matchingState.selectedMatchElement = null;

                     // Check if all prompts are matched to enable submit
                     const totalPrompts = document.querySelectorAll('.prompt-item').length;
                     const matchedCount = Object.keys(quizState.matchingState.userPairs).length;
                     const submitBtn = document.getElementById('submit-btn');
                     if (submitBtn && totalPrompts > 0 && totalPrompts === matchedCount) {
                         submitBtn.disabled = false;
                     }
                 }

            } else { // Left-to-Right Logic (Prompt -> Match) - Default
                 if (isPrompt) { // Clicked a prompt item
                     if (clickedItem === currentSelectedPrompt) { // Clicked same prompt again: Deselect
                         clickedItem.classList.remove('selected');
                         quizState.matchingState.selectedPromptElement = null;
                     } else { // Clicked a new prompt item
                         if (currentSelectedPrompt) currentSelectedPrompt.classList.remove('selected'); // Deselect old
                         clickedItem.classList.add('selected'); // Select new
                         quizState.matchingState.selectedPromptElement = clickedItem;
                          // If a match was also selected, deselect it (only one side active)
                         if (currentSelectedMatch) {
                             currentSelectedMatch.classList.remove('selected');
                             quizState.matchingState.selectedMatchElement = null;
                         }
                     }
                 } else if (isMatch && currentSelectedPrompt) { // Clicked a match WHILE a prompt is selected: Create Pair
                     const promptIndex = currentSelectedPrompt.dataset.index;
                     const matchIndex = clickedIndex;

                     quizState.matchingState.userPairs[promptIndex] = parseInt(matchIndex, 10); // Store pair

                     // Update visual state
                     currentSelectedPrompt.classList.remove('selected');
                     currentSelectedPrompt.classList.add('matched');
                     clickedItem.classList.add('matched'); // Mark match as matched too
                     drawArrow(currentSelectedPrompt, clickedItem, promptIndex); // Draw arrow (prompt -> match)

                     // Reset selection
                     quizState.matchingState.selectedPromptElement = null;

                     // Check if all prompts are matched to enable submit
                     const totalPrompts = document.querySelectorAll('.prompt-item').length;
                     const matchedCount = Object.keys(quizState.matchingState.userPairs).length;
                     const submitBtn = document.getElementById('submit-btn');
                     if (submitBtn && totalPrompts > 0 && totalPrompts === matchedCount) {
                         submitBtn.disabled = false;
                     }
                 }
            }
        }


        // --- Arrow Drawing ---
        function drawArrow(pE, mE, pI) {
            const outerDiv = document.getElementById(`matching-outer-${quizState.currentQuestionIndex}`);
            // Ensure SVG element exists or try to find it again
            if (!matchingSvgElement) {
                const svgContainer = outerDiv?.querySelector('svg#matching-arrow-svg');
                if (svgContainer) { matchingSvgElement = svgContainer; }
                 else { console.error("drawArrow: SVG element '#matching-arrow-svg' not found within outerDiv:", outerDiv?.id); return; }
            }
            if (!pE || !mE || !outerDiv) {
                 console.warn("drawArrow: Missing required elements (prompt, match, or outer div). Prompt:", pE?.id, "Match:", mE?.id, "Index:", pI);
                 return;
            }

            const svgRect = matchingSvgElement.getBoundingClientRect();
            const pR = pE.getBoundingClientRect();
            const mR = mE.getBoundingClientRect();
            const isRTL = mainContainerElement.classList.contains('rtl-layout');

            let startX, startY, endX, endY;
            // Calculate midpoints relative to the SVG container
            const promptMidY = pR.top + pR.height / 2 - svgRect.top;
            const matchMidY  = mR.top + mR.height / 2 - svgRect.top;

            if (isRTL) {
                // Start at the LEFT edge of the MATCH item
                startX = mR.left - svgRect.left;
                startY = matchMidY;
                // End at the RIGHT edge of the PROMPT item
                endX   = pR.right - svgRect.left;
                endY   = promptMidY;
            } else { // LTR
                // Start at the RIGHT edge of the PROMPT item
                startX = pR.right - svgRect.left;
                startY = promptMidY;
                // End at the LEFT edge of the MATCH item
                endX   = mR.left - svgRect.left;
                endY   = matchMidY;
            }

            // Find or create the line element
            let line = matchingSvgElement.querySelector(`#arrow-${pI}`);
            if (!line) {
                line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.id = `arrow-${pI}`;
                line.style.opacity = '0'; // Start invisible for fade-in
                line.style.transition = 'stroke 0.3s ease, opacity 0.3s ease';
                matchingSvgElement.appendChild(line);
            }

             // Safety check for coordinates
            if (isNaN(startX) || isNaN(startY) || isNaN(endX) || isNaN(endY) || !isFinite(startX) || !isFinite(startY) || !isFinite(endX) || !isFinite(endY)) {
                console.error("drawArrow: Invalid coordinates calculated.", { startX, startY, endX, endY, pI, isRTL });
                line.style.opacity = '0'; // Keep invisible if coords are bad
                return;
            }


            // Set line attributes
            line.setAttribute('x1', startX);
            line.setAttribute('y1', startY);
            line.setAttribute('x2', endX);
            line.setAttribute('y2', endY);
            line.setAttribute('stroke', 'var(--accent-color)'); // Default color
            line.setAttribute('stroke-width', '2');
            line.setAttribute('marker-end', 'url(#arrowhead)');

            // Fade in smoothly
            requestAnimationFrame(() => {
                line.style.opacity = '1';
            });
        }

        function removeArrow(pI){
            if(!matchingSvgElement)return;
            const l=matchingSvgElement.querySelector(`#arrow-${pI}`);
            if(l){
                l.style.opacity='0'; // Fade out
                setTimeout(()=>l.remove(),300); // Remove after fade out
            }
        }

        function updateAllArrowPositions(){
             // Only run if in matching question context
            if(!matchingSvgElement || !quizState || !quizState.questions[quizState.currentQuestionIndex] || quizState.questions[quizState.currentQuestionIndex].type !== 'matching') {
                 return;
            }
            const userPairs = quizState.matchingState.userPairs;
            for (const promptIndex in userPairs) {
                 if (userPairs.hasOwnProperty(promptIndex)) {
                     const matchIndex = userPairs[promptIndex];
                     const promptElement = document.getElementById(`prompt-${promptIndex}`);
                     const matchElement = document.getElementById(`match-${matchIndex}`);
                     if (promptElement && matchElement) {
                         drawArrow(promptElement, matchElement, promptIndex); // Redraw with current positions
                     } else {
                         // If elements are missing (shouldn't happen often), remove the arrow
                         removeArrow(promptIndex);
                     }
                 }
            }
        }

        function setupArrowObserver(){
            const targetNode = document.getElementById('matching-cols'); // Observe the columns container
            if (!targetNode || !matchingSvgElement) {
                 console.warn("Observer setup failed: Target 'matching-cols' or SVG missing.");
                 return;
            }

             // Disconnect previous observer if exists
            if (matchingArrowObserver) {
                matchingArrowObserver.disconnect();
            }

            // Configuration for the observer: observe layout changes
            const config = { attributes: true, childList: true, subtree: true, characterData: true }; // Watch everything for robustness

            // Callback function to execute when mutations are observed (debounced)
            const callback = debounce(updateAllArrowPositions, 50); // Debounce to avoid excessive calls

            // Create an observer instance linked to the callback function
            matchingArrowObserver = new MutationObserver(callback);

            // Start observing the target node for configured mutations
            matchingArrowObserver.observe(targetNode, config);

            // Also observe the main quiz container for potential class changes affecting layout
            const quizContainerTarget = document.getElementById('quiz-container');
            if(quizContainerTarget) {
                 matchingArrowObserver.observe(quizContainerTarget, { attributes: true, subtree: false }); // Observe class changes etc.
            }

            // Initial call to position arrows correctly after setup
             setTimeout(updateAllArrowPositions, 100); // Small delay ensures initial render is complete
        }


        // --- Answer Checking ---
        function checkAnswer(){
            if(!feedbackContainerElement||!quizButtonsContainerElement)return;

            // Disconnect observer to prevent updates during feedback display
            if(matchingArrowObserver){
                matchingArrowObserver.disconnect();
                matchingArrowObserver = null;
            }

            const cQ=quizState.questions[quizState.currentQuestionIndex];
            let result = {isCorrect:false, feedback:'', userResponse:null, scoreIncrement:0};
            const strings = getStrings(); // Get current language strings

            try{
                switch(cQ.type){
                    case "matching":
                        result = checkMatching(cQ); // <-- Modified function below
                        break;
                    case "ordering":
                        result = checkOrdering(cQ); // <-- Modified function below
                        break;
                    case "multiple_choice":
                    default:
                        result = checkMultipleChoice(cQ); // <-- Modified function below
                        break;
                }
            } catch(e){
                console.error("Error checking answer:", e);
                result = {isCorrect:false, feedback:`<div class="incorrect-feedback">${strings.defaultErrorMessage || 'Error checking answer.'}</div>`, userResponse:null, scoreIncrement:0};
            }

            // Store user's answer (or null if none selected)
            quizState.selectedAnswers[quizState.currentQuestionIndex]=result.userResponse;

            // Update score if correct
            if(result.scoreIncrement > 0) {
                quizState.correctAnswers+=result.scoreIncrement;
            }

            // Display feedback
            feedbackContainerElement.innerHTML=result.feedback; // This now includes the explanation
            feedbackContainerElement.classList.remove('hidden');

            // Disable inputs after answering
            disableInputs();

            // Show 'Next' or 'View Results' button, hide 'Submit'
            const submitBtn=quizButtonsContainerElement.querySelector('#submit-btn');
            const nextBtn=quizButtonsContainerElement.querySelector('#next-btn');

            if(submitBtn) submitBtn.classList.add('hidden');
            if(nextBtn) {
                // Determine text for the next button
                const nextBtnTextKey = (quizState.currentQuestionIndex === quizState.totalQuestions - 1 && quizState.totalQuestions > 0) ? 'viewResults' : 'next';
                const textSpan = nextBtn.querySelector('.btn-text');
                if (textSpan) textSpan.textContent = strings[nextBtnTextKey] || nextBtnTextKey; // Update text
                nextBtn.classList.remove('hidden'); // Show the button
            }
        }

        // *** MODIFIED checkMultipleChoice ***
        function checkMultipleChoice(q) {
            const sR = document.querySelector('input[name="question-option"]:checked');
            const strings = getStrings();

            if (!sR) {
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.selectAnswerPrompt || 'Please select an answer.'}</div>`, userResponse: null, scoreIncrement: 0 };
            }

            const sI = parseInt(sR.value, 10);
            const cAT = q.answer;
            const sAT = q.options?.[sI];
            const iC = sAT === cAT;

            document.querySelectorAll('.option-label').forEach((l, i) => {
                const ip = l.querySelector('input');
                if (q.options?.[i] === cAT) {
                    l.classList.add('correct-option');
                }
                if (ip && ip.checked && !iC) {
                    l.classList.add('incorrect-option');
                }
            });

            // Generate primary feedback HTML
            let fH = iC
                ? `<div class="correct-feedback">${strings.correctFeedback || 'Correct! ✓'}</div>`
                : `<div class="incorrect-feedback">${strings.incorrectFeedback || 'Incorrect.'} <span>${strings.correctAnswerIs || 'Correct answer:'} ${cAT || 'N/A'}</span></div>`;

            // *** ADD EXPLANATION ***
            if (q.explanation) {
                // Check if explanation needs specific text direction
                const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"'; // Basic check for Arabic characters
                fH += `<div class="feedback-explanation"${dirAttr}>${q.explanation}</div>`; // Append explanation HTML with directionality hint
            }
            // *** END ADD EXPLANATION ***

            return { isCorrect: iC, feedback: fH, userResponse: sI, scoreIncrement: iC ? 1 : 0 };
        }

        // *** MODIFIED checkMatching ***
        function checkMatching(q) {
            const uP = quizState.matchingState.userPairs;
            const cP = q.answer || {};
            const tCP = Object.keys(cP).length;
            let cMC = 0;
            const strings = getStrings();

            if (tCP === 0) {
                return { isCorrect: true, feedback: `<div class="correct-feedback">${strings.matchingNoMatchNeeded || 'No matching needed.'}</div>`, userResponse: uP, scoreIncrement: 0 };
            }

            for (const pI in cP) {
                if (uP.hasOwnProperty(pI) && uP[pI] == cP[pI]) { // Use == safety
                    cMC++;
                }
            }

            const iFC = cMC === tCP && Object.keys(uP).length === tCP;
            const iPC = cMC > 0 && !iFC;

            // Generate primary feedback message
            let fH = "";
            if (iFC) {
                fH = `<div class="correct-feedback">${strings.matchingAllCorrect || 'Correct! ✓ All matched.'}</div>`;
            } else if (iPC) {
                fH = `<div class="partial-feedback">${(strings.matchingPartialCorrect || 'Partial correct: {correct}/{total}.').replace('{correct}', cMC).replace('{total}', tCP)}</div>`;
            } else {
                fH = `<div class="incorrect-feedback">${(strings.matchingNoneCorrect || 'Incorrect: 0/{total} matched.').replace('{total}', tCP)}</div>`;
            }

            // *** ADD EXPLANATION ***
            if (q.explanation) {
                const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                fH += `<div class="feedback-explanation"${dirAttr}>${q.explanation}</div>`;
            }
            // *** END ADD EXPLANATION ***

            // Apply visual feedback to arrows and items
            for (const pI in uP) {
                if (uP.hasOwnProperty(pI)) {
                    const uMI = uP[pI];
                    const cMI = cP[pI];
                    const isPairCorrect = cMI !== undefined && uMI == cMI; // Use == safety

                    const line = matchingSvgElement?.querySelector(`#arrow-${pI}`);
                    const promptEl = document.getElementById(`prompt-${pI}`);
                    const userMatchEl = document.getElementById(`match-${uMI}`);

                    if (!line || !promptEl || !userMatchEl) continue;

                    if (isPairCorrect) {
                        line.style.stroke = 'var(--correct-border)';
                        line.querySelector('polygon')?.setAttribute('fill', 'var(--correct-border)');
                        promptEl.style.borderColor = 'var(--correct-border)';
                        userMatchEl.style.borderColor = 'var(--correct-border)';
                    } else {
                        line.style.stroke = 'var(--incorrect-border)';
                        line.querySelector('polygon')?.setAttribute('fill', 'var(--incorrect-border)');
                        promptEl.style.borderColor = 'var(--incorrect-border)';
                        userMatchEl.style.borderColor = 'var(--incorrect-border)';
                    }
                }
            }

            return { isCorrect: iFC, feedback: fH, userResponse: uP, scoreIncrement: iFC ? 1 : 0 };
        }

        // *** MODIFIED checkOrdering ***
        function checkOrdering(q) {
            const oI = q.items || [];
            const cAO = q.answer || [];
            const nI = oI.length;
            const strings = getStrings();

            if (nI === 0 || !Array.isArray(cAO) || nI !== cAO.length) {
                console.error("Invalid ordering question data:", q);
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.orderingInvalidData || 'Error: Invalid ordering setup.'}</div>`, userResponse: null, scoreIncrement: 0 };
            }

            const uOM = {};
            const selectedPositions = new Set();
            let allSelected = true;
            let hasDuplicates = false;

            const selectElements = document.querySelectorAll("#ordering-list .ordering-select");
            if (selectElements.length !== nI) {
                console.error("Ordering Error: Select element count mismatch.");
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.orderingSelectionError || 'Error processing selections.'}</div>`, userResponse: null, scoreIncrement: 0 };
            }

            selectElements.forEach(s => {
                const itemIndex = parseInt(s.dataset.itemIndex, 10);
                const selectedValue = s.value;
                if (selectedValue === "") {
                    allSelected = false;
                } else {
                    const position = parseInt(selectedValue, 10);
                    if (isNaN(position) || position < 1 || position > nI) { allSelected = false; return; }
                    uOM[itemIndex] = position;
                    if (selectedPositions.has(position)) { hasDuplicates = true; }
                    selectedPositions.add(position);
                }
            });

            if (!allSelected) { return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.orderingSelectAll || 'Please select an order for all items.'}</div>`, userResponse: uOM, scoreIncrement: 0 }; }
            if (hasDuplicates || selectedPositions.size !== nI) {
                const numText = nI > 1 ? (strings.orderingUseEachNumOncePlural || 'numbers 1-{n}').replace('{n}', nI) : (strings.orderingUseEachNumOnceSingular || 'number 1');
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${(strings.orderingDuplicateUse || 'Please use each order {nums} exactly once.').replace('{nums}', numText)}</div>`, userResponse: uOM, scoreIncrement: 0 };
            }

            const userOrderedItems = new Array(nI).fill(null);
            let constructionOk = true;
            for (const itemIndexStr in uOM) {
                if (uOM.hasOwnProperty(itemIndexStr)) {
                    const itemIndex = parseInt(itemIndexStr, 10);
                    const itemText = oI[itemIndex];
                    const userPosition = uOM[itemIndex] - 1;
                    if (itemText === undefined || userPosition < 0 || userPosition >= nI || userOrderedItems[userPosition] !== null) { constructionOk = false; break; }
                    userOrderedItems[userPosition] = itemText;
                }
            }
            if (!constructionOk || userOrderedItems.some(i => i === null)) {
                console.error("Ordering Error: Failed to construct user sequence.", uOM, userOrderedItems);
                return { isCorrect: false, feedback: `<div class="incorrect-feedback">${strings.orderingSequenceError || 'Error processing sequence.'}</div>`, userResponse: userOrderedItems, scoreIncrement: 0 };
            }

            const iC = JSON.stringify(userOrderedItems) === JSON.stringify(cAO);

            // Generate primary feedback HTML
            let fH = iC
                ? `<div class="correct-feedback">${strings.correctFeedback || 'Correct! ✓'}</div>`
                : `<div class="incorrect-feedback">${strings.incorrectFeedback || 'Incorrect.'} <span>${strings.correctAnswerIs || 'Correct order:'} ${cAO.join(" → ")}</span></div>`;

            // *** ADD EXPLANATION ***
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                fH += `<div class="feedback-explanation"${dirAttr}>${q.explanation}</div>`;
            }
            // *** END ADD EXPLANATION ***

            // Apply visual feedback to selects
            selectElements.forEach(s => {
                const itemIndex = parseInt(s.dataset.itemIndex, 10);
                const itemText = oI[itemIndex];
                const userSelectedPosition = uOM[itemIndex];
                const correctPosition = cAO.indexOf(itemText) + 1;
                if (userSelectedPosition === correctPosition) {
                    s.style.borderColor = "var(--correct-border)"; s.style.backgroundColor = "var(--correct-bg)";
                } else {
                    s.style.borderColor = "var(--incorrect-border)"; s.style.backgroundColor = "var(--incorrect-bg)";
                }
                s.style.borderWidth = "2px";
            });

            return { isCorrect: iC, feedback: fH, userResponse: userOrderedItems, scoreIncrement: iC ? 1 : 0 };
        }

        function disableInputs(){
            // Disable radio buttons and selects
            document.querySelectorAll('input[name="question-option"], .ordering-select')
                .forEach(i=>i.disabled=true);
            // Make radio labels non-clickable
            document.querySelectorAll('.option-label')
                .forEach(l=>l.style.cursor='default');
            // Make matching items non-clickable
            document.querySelectorAll('.matching-item')
                .forEach(i=>{
                    i.style.pointerEvents='none'; // Prevents click events
                    i.style.cursor='default';
                    // i.tabIndex = -1; // Remove from tab order if keyboard nav was added
                });
        }


        // --- Navigation and Results ---
        function nextQuestion(){
            quizState.currentQuestionIndex++;
            if(quizState.currentQuestionIndex<quizState.totalQuestions){
                displayQuestion(); // Display next question
            } else {
                quizState.endTime=new Date(); // Mark end time
                displayResults(); // Show results view
            }
        }

        function displayResults(){
            if(!quizContainerElement||!feedbackContainerElement||!quizButtonsContainerElement||!quizTitleElement)return;

            // Clear previous quiz content
            quizContainerElement.innerHTML='';
            feedbackContainerElement.classList.add('hidden');
            quizButtonsContainerElement.innerHTML='';

            const strings = getStrings();
            quizTitleElement.textContent = strings.viewResults || 'Quiz Results'; // Update title

            // Calculate time and score
            const timeTaken=quizState.endTime&&quizState.startTime?Math.round((quizState.endTime-quizState.startTime)/1000):0;
            const timeString=formatTime(timeTaken);
            const score = quizState.totalQuestions>0?(quizState.correctAnswers/quizState.totalQuestions)*100:0;
            const scoreRounded=score.toFixed(0);

            // Save stats if there were questions
            if(quizState.totalQuestions>0){
                 saveLessonStats(quizState.subject,quizState.semester,quizState.unit,quizState.lesson,quizState.correctAnswers,quizState.totalQuestions,timeTaken);
                 updateLessonBoxDisplays(); // Update the display on the topic list in the background
            }

            // Determine result message
            let resultMessageKey = 'quizResultPractice';
            if (quizState.totalQuestions === 0) resultMessageKey = 'quizResultNoQuestions';
            else if (score >= 90) resultMessageKey = 'quizResultExcellent';
            else if (score >= 70) resultMessageKey = 'quizResultGreat';
            else if (score >= 50) resultMessageKey = 'quizResultGood';
            const resultMessage = strings[resultMessageKey] || '';

            // Create results container
            const rD=document.createElement('div');
            rD.className='results-container';
            rD.innerHTML=`
                <h2 class="results-header">${resultMessage}</h2>
                <div class="results-score">
                    <div class="score-circle">
                        <span class="score-number">${scoreRounded}</span>
                        <span class="score-percent-sign">%</span>
                    </div>
                </div>
                <div class="results-details">
                    <p data-detail-key="subject"><span class="detail-icon">📚</span><strong>${strings.resultsSubjectLabel || 'Subject:'}</strong> <span class="detail-value">${quizState.subject||'N/A'}</span></p>
                    <p data-detail-key="semester"><span class="detail-icon">🗓️</span><strong>${strings.resultsSemesterLabel || 'Semester:'}</strong> <span class="detail-value">${quizState.semester||'N/A'}</span></p>
                    <p data-detail-key="unit"><span class="detail-icon">🔖</span><strong>${strings.resultsUnitLabel || 'Unit:'}</strong> <span class="detail-value">${quizState.unit||'N/A'}</span></p>
                    <p data-detail-key="lesson"><span class="detail-icon">📖</span><strong>${strings.resultsLessonLabel || 'Lesson:'}</strong> <span class="detail-value">${quizState.lesson||'N/A'}</span></p>
                    <p data-detail-key="correct"><span class="detail-icon">✅</span><strong>${strings.resultsCorrectLabel || 'Correct:'}</strong> <span class="detail-value">${quizState.correctAnswers}/${quizState.totalQuestions}</span></p>
                    <p data-detail-key="time"><span class="detail-icon">⏱️</span><strong>${strings.resultsTimeLabel || 'Time:'}</strong> <span class="detail-value">${timeString}</span></p>
                </div>
            `;
            quizContainerElement.appendChild(rD);

            // Create action buttons container
            const aD=document.createElement('div');
            aD.className='results-actions quiz-buttons'; // Use quiz-buttons for consistent styling

            // Redo Button
            const rB=document.createElement('button');
            rB.className='btn redo-btn';
            rB.id='redo-btn';
            rB.innerHTML=`🔄 <span class="btn-text">${strings.redoQuiz || 'Redo Quiz'}</span>`;
            rB.onclick=()=>{
                 // Restart the quiz with the original questions
                 startQuiz(quizState.subject,quizState.semester,quizState.unit,quizState.lesson,quizState.originalQuestions);
            };
            aD.appendChild(rB);

            // Review Button (only if there were questions)
            if(quizState.totalQuestions>0){
                const revB=document.createElement('button');
                revB.id='review-btn';
                revB.className='btn review-btn';
                revB.innerHTML=`🧐 <span class="btn-text">${strings.reviewAnswers || 'Review Answers'}</span>`;
                revB.onclick=reviewAnswers;
                aD.appendChild(revB);
            }

            // Back to Topics Button
            const bTB=document.createElement('button');
            bTB.className='btn back-to-topics-btn'; // Common class for styling
            bTB.id='back-to-topics-btn-results'; // Specific ID
            bTB.innerHTML=`<span>⬅️</span> <span class="btn-text">${strings.backToTopics || 'Back to Topics'}</span>`;
            bTB.onclick=showTopicList;
            aD.appendChild(bTB);

            quizButtonsContainerElement.appendChild(aD); // Add actions to the button container
        }


        // --- Answer Review ---
        function reviewAnswers(){
            if(!quizContainerElement||!feedbackContainerElement||!quizButtonsContainerElement||!quizTitleElement)return;

            // Clear results view
            quizContainerElement.innerHTML='';
            feedbackContainerElement.classList.add('hidden');
            quizButtonsContainerElement.innerHTML='';

            const strings = getStrings();
            quizTitleElement.textContent = `${strings.reviewTitlePrefix || 'Review'}: ${quizState.lesson || ''}`; // Update title

            const rD=document.createElement('div');
            rD.className='review-container';

            // Iterate through each question and its stored answer
            quizState.questions.forEach((q,i)=>{
                const questionDiv=document.createElement('div');
                const userAnswer=quizState.selectedAnswers[i]; // Get the stored answer/state

                // Determine status class and text
                let {correctnessClass: statusClass, statusText} = calculateReviewStatus(q, userAnswer);

                questionDiv.className=`question-review ${statusClass}`; // Apply class (correct, incorrect, partial)
                const questionTypeDisplay=(q.type||'multiple_choice').replace('_',' '); // Format type for display

                // Header with question number, type, and status
                questionDiv.innerHTML=`
                    <div class="review-question-header">
                        <span class="review-question-number">Q ${i+1} (${questionTypeDisplay})</span>
                        <span class="review-status">${statusText}</span>
                    </div>
                    <p class="review-question-text">${q.question||'?'}</p>
                    <div class="review-answer-content" id="review-answer-content-${i}"></div>
                `;
                rD.appendChild(questionDiv);

                // Get the content area and render the specific review details
                const contentArea=questionDiv.querySelector(`#review-answer-content-${i}`);
                if(contentArea){
                    try{
                        switch(q.type){
                            case"matching":
                                reviewMatchingReview(q,userAnswer,contentArea); // <-- Modified below
                                break;
                            case"ordering":
                                reviewOrderingReview(q,userAnswer,contentArea); // <-- Modified below
                                break;
                            case"multiple_choice":
                            default:
                                reviewMultipleChoiceReview(q,userAnswer,contentArea); // <-- Modified below
                                break;
                        }
                    } catch(e) {
                        console.error("Error rendering review answer for Q", i+1, e);
                        contentArea.innerHTML=`<p style="color:red">Error displaying review details.</p>`;
                    }
                } else {
                    console.warn(`Could not find content area for review question ${i}`);
                }
            });

            quizContainerElement.appendChild(rD); // Add all review questions to the container

            // Add action buttons for review view
            const aD=document.createElement('div');
            aD.className='review-actions quiz-buttons';

            // Back to Results Button
            const bRB=document.createElement('button');
            bRB.className='btn back-btn'; // Generic back button style
            bRB.id = 'back-btn'; // Specific ID
            bRB.innerHTML=`<span>←</span> <span class="btn-text">${strings.backToResults || 'Back to Results'}</span>`;
            bRB.onclick=displayResults; // Go back to the results summary
            aD.appendChild(bRB);

            // Back to Topics Button
            const bTB=document.createElement('button');
            bTB.className='btn back-to-topics-btn';
            bTB.id = 'back-to-topics-btn-review'; // Specific ID
            bTB.innerHTML=`<span>⬅️</span> <span class="btn-text">${strings.backToTopics || 'Back to Topics'}</span>`;
            bTB.onclick=showTopicList; // Go directly back to topics
            aD.appendChild(bTB);

            quizButtonsContainerElement.appendChild(aD);

            // Scroll to the top of the review container
            quizContainerElement.scrollIntoView({behavior:'smooth',block:'start'});
        }

        // calculateReviewStatus remains the same as it determines the overall status, not the detailed display
        function calculateReviewStatus(q, uA){
            let correctnessClass='incorrect'; // Default to incorrect
            let statusText = getStrings().reviewStatusIncorrect || '✗ Incorrect';
            let isCorrect = false;
            let isPartial = false;
            const strings = getStrings();

            try{
                switch(q.type){
                    case"matching":
                        const correctPairs = q.answer || {};
                        const totalCorrectPairs = Object.keys(correctPairs).length;
                        let correctlyMatchedCount = 0;

                        if(totalCorrectPairs > 0 && uA && typeof uA === 'object') {
                            for(const pI in correctPairs) {
                                // Use == for potential type difference (string index vs number value)
                                if(uA.hasOwnProperty(pI) && uA[pI] == correctPairs[pI]) {
                                    correctlyMatchedCount++;
                                }
                            }
                        }

                        // Determine status based on counts
                        isCorrect = totalCorrectPairs > 0 && correctlyMatchedCount === totalCorrectPairs && Object.keys(uA || {}).length === totalCorrectPairs;
                        isPartial = totalCorrectPairs > 0 && correctlyMatchedCount > 0 && !isCorrect;

                        if (isCorrect) {
                            correctnessClass = "correct";
                            statusText = strings.reviewStatusCorrect || "✓ Correct";
                        } else if (isPartial) {
                            correctnessClass = "partial";
                            statusText = (strings.reviewStatusPartial || "~ Partial ({correct}/{total})")
                                .replace('{correct}', correctlyMatchedCount)
                                .replace('{total}', totalCorrectPairs);
                        } else if (uA === null || Object.keys(uA || {}).length === 0 && totalCorrectPairs > 0) {
                            // If there were pairs to match, but none were attempted
                            statusText = strings.reviewStatusUnanswered || 'Unanswered';
                        } // else remains 'incorrect'
                        break;

                    case"ordering":
                        // Check if user answer exists and matches the correct answer array
                        isCorrect = uA && Array.isArray(uA) && q.answer && Array.isArray(q.answer) && JSON.stringify(uA) === JSON.stringify(q.answer);

                        if (uA === null || !Array.isArray(uA)) {
                            statusText = strings.reviewStatusUnanswered || 'Unanswered';
                            correctnessClass = 'incorrect'; // Unanswered is treated as incorrect
                        } else if (isCorrect) {
                            correctnessClass = "correct";
                            statusText = strings.reviewStatusCorrect || "✓ Correct";
                        } // else remains 'incorrect'
                        break;

                    case"multiple_choice":
                    default:
                        // Check if user answer (index) maps to the correct answer text
                        isCorrect = uA !== null && q.options && q.answer && q.options[uA] === q.answer;

                        if (uA === null) { // User didn't select anything
                            statusText = strings.reviewStatusUnanswered || 'Unanswered';
                            correctnessClass = 'incorrect'; // Unanswered is incorrect
                        } else if (isCorrect) {
                            correctnessClass = "correct";
                            statusText = strings.reviewStatusCorrect || "✓ Correct";
                        } // else remains 'incorrect'
                        break;
                }
            } catch(e) {
                console.error("Error calculating review status:", e);
                correctnessClass = 'incorrect';
                statusText = 'Error'; // Indicate an error occurred
            }
            return { correctnessClass, statusText };
        }

        // *** MODIFIED reviewMultipleChoiceReview ***
        function reviewMultipleChoiceReview(q, uAI, c) { // uAI is User Answer Index
            const strings = getStrings();
            const d = document.createElement("div");
            d.className = "review-mc-answer";

            const userSelectedText = (uAI !== null && q.options?.[uAI] !== undefined)
                ? q.options[uAI]
                : `(${strings.reviewStatusUnanswered || "No answer"})`; // Handle unanswered

            const isCorrect = (uAI !== null && userSelectedText === q.answer);

            let userAnswerHTML = `<span class="user-answer-text`;
            if (uAI === null) userAnswerHTML += `">`; // No specific style for unanswered text itself
            else if (isCorrect) userAnswerHTML += ` correct">`;
            else userAnswerHTML += ` incorrect">`; // Incorrect will have line-through via CSS
            userAnswerHTML += `${userSelectedText}</span>`;

            let htmlContent = `<p><strong>${strings.resultsYourAnswerLabel || 'Your Answer:'}</strong> ${userAnswerHTML}</p>`;

            // Show correct answer if user was incorrect OR unanswered
            if (!isCorrect) {
                htmlContent += `<p><strong>${strings.resultsCorrectAnswerLabel || 'Correct Answer:'}</strong> <span class="correct-answer-text">${q.answer || "N/A"}</span></p>`;
            }

            // *** ADD EXPLANATION ***
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                htmlContent += `<div class="feedback-explanation"${dirAttr}>${q.explanation}</div>`;
            }
            // *** END ADD EXPLANATION ***

            d.innerHTML = htmlContent;
            c.appendChild(d);
        }

        // *** MODIFIED reviewMatchingReview ***
        function reviewMatchingReview(q, userPairs, container) {
            const strings = getStrings();
            const reviewDiv = document.createElement("div");
            reviewDiv.className = "review-matching-answer"; // Use existing class

            const correctPairs = q.answer || {};
            const promptsList = q.prompts || [];
            const matchesList = q.matches || [];

            // Build the grid HTML (copied logic from previous implementation for display)
            let gridHtml = `<div class="review-matching-grid">`;
            const promptsCol = `<div class="review-matching-column">`;
            const matchesCol = `<div class="review-matching-column">`;
            let promptsColContent = '';
            let matchesColContent = '';

            promptsList.forEach((promptText, promptIndex) => {
                const userMatchIndex = userPairs ? userPairs[promptIndex] : null;
                const correctMatchIndex = correctPairs[promptIndex];
                const isPairCorrect = (userMatchIndex !== null && userMatchIndex == correctMatchIndex); // Use == safety

                const promptDivClass = isPairCorrect ? "review-matched-pair-correct" : "review-matched-pair-incorrect";
                promptsColContent += `<div class="${promptDivClass}">${promptIndex + 1}. ${promptText}</div>`;

                const correctMatchText = (correctMatchIndex !== undefined && matchesList[correctMatchIndex] !== undefined) ? matchesList[correctMatchIndex] : "(N/A)";
                const userMatchText = (userMatchIndex !== null && matchesList[userMatchIndex] !== undefined) ? matchesList[userMatchIndex] : `(${strings.reviewStatusUnanswered || 'Unanswered'})`;

                let matchDivContent = '';
                if (isPairCorrect) {
                    matchDivContent = correctMatchText;
                    matchesColContent += `<div class="review-matched-pair-correct">${matchDivContent}</div>`;
                } else {
                    matchDivContent = `<span style="text-decoration:line-through;">${userMatchText}</span> <span style="font-weight:500;">(${correctMatchText})</span>`;
                    matchesColContent += `<div class="review-matched-pair-incorrect">${matchDivContent}</div>`;
                }
            });

            gridHtml += promptsCol + promptsColContent + `</div>` + matchesCol + matchesColContent + `</div></div>`; // Close columns and grid

            // Start building final HTML content
            let htmlContent = `<p><strong>${strings.matchingMatchesHeader || 'Matches'}:</strong></p>` + gridHtml;

            // *** ADD EXPLANATION ***
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                htmlContent += `<div class="feedback-explanation"${dirAttr} style="margin-top: 15px;">${q.explanation}</div>`;
            }
            // *** END ADD EXPLANATION ***

            reviewDiv.innerHTML = htmlContent;
            container.appendChild(reviewDiv);
        }

        // *** MODIFIED reviewOrderingReview ***
        function reviewOrderingReview(q, uOI, c) { // uOI is User Ordered Items array
            const strings = getStrings();
            const d = document.createElement("div");
            d.className = "review-ordering-answer";

            const correctOrder = q.answer || [];

            // Header
            let htmlContent = `<p><strong>${(strings.orderingInstruction || 'Ordering:').split(':')[0]}:</strong></p>`;

            // Build the list HTML
            let listHtml = `<div class="review-ordering-list">`;
            correctOrder.forEach((correctItemText, correctIndex) => {
                const itemDiv = document.createElement("div"); // Use createElement to set style easily
                itemDiv.className = "review-ordering-list-item";

                const userIndex = uOI ? uOI.indexOf(correctItemText) : -1;
                const userPosition = (userIndex !== -1) ? userIndex + 1 : null;
                const correctPosition = correctIndex + 1;

                let numberSpanHTML = '';
                if (userPosition === correctPosition) {
                    numberSpanHTML = `<span class="review-order-number review-order-correct">${correctPosition}.</span>`;
                    itemDiv.style.backgroundColor = 'var(--correct-bg)';
                } else if (userPosition !== null) {
                    numberSpanHTML = `<span class="review-order-number review-order-incorrect">${userPosition}.</span> <span class="review-order-number review-order-correct">(${correctPosition}.)</span>`;
                    itemDiv.style.backgroundColor = 'var(--incorrect-bg)';
                } else {
                    numberSpanHTML = `<span class="review-order-number review-order-incorrect">(${strings.reviewStatusUnanswered || 'NP'})</span> <span class="review-order-number review-order-correct">(${correctPosition}.)</span>`;
                    itemDiv.style.backgroundColor = 'var(--partial-bg)';
                }

                itemDiv.innerHTML = `${numberSpanHTML} ${correctItemText}`;
                listHtml += itemDiv.outerHTML; // Add the styled item's HTML
            });
             listHtml += `</div>`; // Close list

            htmlContent += listHtml;

            // *** ADD EXPLANATION ***
            if (q.explanation) {
                 const dirAttr = /[\u0600-\u06FF]/.test(q.explanation) ? '' : ' dir="ltr"';
                htmlContent += `<div class="feedback-explanation"${dirAttr} style="margin-top: 15px;">${q.explanation}</div>`;
            }
            // *** END ADD EXPLANATION ***

            d.innerHTML = htmlContent;
            c.appendChild(d);
        }


        // --- Error Display ---
        function showError(subj, unit, lesson, customMessage = '') {
            if(!quizContainerElement||!feedbackContainerElement||!quizButtonsContainerElement||!quizTitleElement)return;

            showQuizView(); // Ensure the quiz view area is visible
            const strings = getStrings();

            // Set title to indicate an error
            quizTitleElement.textContent = strings.defaultErrorMessage.includes('load')
                ? strings.defaultErrorMessage
                : 'Error';

            // Clear previous content
            quizContainerElement.innerHTML='';
            feedbackContainerElement.classList.add('hidden');
            quizButtonsContainerElement.innerHTML='';

            // Prepare error message
            const defaultMsg = (strings.defaultErrorMessage || "Could not load questions for \"{lesson}\" in \"{unit}\".").replace('{lesson}', lesson || 'N/A').replace('{unit}', unit || 'N/A');
            const displayMsg = customMessage || defaultMsg;

            // Create error display elements
            const errorDiv=document.createElement('div');
            errorDiv.className='error-display';
            errorDiv.innerHTML=`<div class="error-message">${displayMsg}</div>`;

            // Add a "Back to Topics" button
            const backBtn=document.createElement('button');
            backBtn.className='btn back-to-topics-btn';
            backBtn.id='back-to-topics-btn-error'; // Specific ID
            backBtn.innerHTML=`<span>⬅️</span> <span class="btn-text">${strings.backToTopics || 'Back to Topics'}</span>`;
            backBtn.onclick=showTopicList;
            errorDiv.appendChild(backBtn);

            quizContainerElement.appendChild(errorDiv); // Add error display to container
        }


        // --- Get Questions Data ---
        function getQuestions(subj,sem,unitT,lessonT){
            if(!subj||!sem||!unitT||!lessonT){
                console.error("Missing getQuestions parameters:",{subj,sem,unitT,lessonT});
                return[]; // Return empty array on error
            }
            try{
                const sD=topicsData[subj]?.[sem]; // Semester Data
                if(!sD?.units){
                    console.warn(`Units missing for subject/semester: ${subj} -> ${sem}`);
                    return[];
                }
                const u=sD.units.find(un=>un?.title===unitT); // Unit
                if(!u?.lessons){
                     console.warn(`Unit not found or has no lessons: "${unitT}" in ${subj} -> ${sem}.`);
                     return[];
                }
                const l=u.lessons.find(ls=>ls?.title===lessonT); // Lesson
                if(!l){
                     console.warn(`Lesson not found: "${lessonT}" in unit "${unitT}".`);
                     return[];
                }

                // Check if questions exist and is an array
                if(Array.isArray(l.questions) && l.questions.length>0){
                    // Ensure all questions have a type (default to multiple_choice if missing)
                    return l.questions.map(q=>({
                        ...(q.type ? {} : { type: 'multiple_choice' }), // Add default type if missing
                        ...q
                    }));
                } else {
                     console.log(`No questions found for lesson "${lessonT}".`);
                     return[]; // Return empty array if no questions defined
                }
            }catch(e){
                console.error("Error retrieving questions:",e);
                return[]; // Return empty array on unexpected errors
            }
        }

        // --- END OF questions.js ---
    </script>

</body>
</html>
